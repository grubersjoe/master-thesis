<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Jonathan Gruber" />
    <meta name="description" content="Entwicklung eines Transpilers zur Übersetzung von Flow nach TypeScript" />
    <title>
      Statische Typsysteme für JavaScript - Masterarbeit Jonathan Gruber
    </title>

    <link
      href="https://fonts.googleapis.com/css2?family=PT+Mono&family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap"
      rel="stylesheet"
    />
    <link href="normalize.css" rel="stylesheet" />
    <link href="styles.css" rel="stylesheet" />
  </head>

  <body>
    <header class="title">
      <h1>Statische Typsysteme für JavaScript</h1>
      <div class="subtitle">Entwicklung eines Transpilers zur Übersetzung von Flow nach TypeScript</div>
      <p>
        Masterarbeit <a href="https://jogruber.de">Jonathan Gruber</a><br />
        <a href="https://www.htwk-leipzig.de">Hochschule für Technik, Wirtschaft und Kultur Leipzig</a><br />
        <a href="https://www.spreadshirt.de">sprd.net AG (Spreadshirt)</a><br />
        1. Dezember 2019<br />
      </p>
      <p>Diese Arbeit kann auch im <a href="thesis.pdf">Originalformat (PDF)</a> gelesen werden.</p>
    </header>
    <article id="zusammenfassung">
      <h2 class="h3">Zusammenfassung</h2>
      <p>
        Die vorliegende Masterarbeit behandelt die Systeme Flow <a class="citation" href="#ref-FLOW:PAPER">[1]</a> und
        TypeScript <a class="citation" href="#ref-TYPESCRIPT:SPEC">[2]</a>, die eine statische Typisierung in JavaScript
        ermöglichen. Dabei wird die Implementierung eines Transpilers auf Basis von Babel
        <a class="citation" href="#ref-BABEL">[3]</a> ausgeführt, der beliebige durch Flow typisierte
        JavaScript-Programme in äquivalenten TypeScript-Code übersetzen kann. Mittels des entwickelten Transpilers
        wurden zwei reale Projekte des Unternehmens Spreadshirt erfolgreich nach TypeScript migriert. Es kann auf
        Grundlage empirischer Daten, die anhand der übersetzten Projekte gewonnen wurden, gezeigt werden, dass
        TypeScript verschiedene Vorteile im Vergleich zu Flow aufweist: So sind durch den Wechsel des Typsystems neue
        Programmfehler aufgedeckt worden, und es kann belegt werden, dass TypeScript eine umfangreichere Unterstützung
        für externe Softwarebibliotheken mittels Typdefinitionen bietet. Darüber hinaus geht aus der Untersuchung
        hervor, dass TypeScript transparenter als Flow entwickelt wird. Schließlich kann in einigen Fällen bei
        TypeScript ein besseres Laufzeitverhalten der Typüberprüfungen gegenüber Flow nachgewiesen werden.
      </p>
    </article>
    <nav id="TOC" role="doc-toc">
      <h2 class="h3">Inhalt</h2>
      <ul>
        <li>
          <a href="#chap:motiviation">Motivation</a>
          <ul>
            <li><a href="#historischer-abriss-von-javascript">Historischer Abriss von JavaScript</a></li>
            <li><a href="#javascripts-dynamische-typisierung">JavaScripts dynamische Typisierung</a></li>
            <li>
              <a href="#motivation-für-den-einsatz-statischer-typsysteme"
                >Motivation für den Einsatz statischer Typsysteme</a
              >
            </li>
            <li><a href="#zielsetzung-und-aufbau-der-arbeit">Zielsetzung und Aufbau der Arbeit</a></li>
          </ul>
        </li>
        <li>
          <a href="#chap:basics">Grundlagen</a>
          <ul>
            <li>
              <a href="#konzepte-und-begriffe-der-typentheorie">Konzepte und Begriffe der Typentheorie</a>
              <ul>
                <li><a href="#korrektheit-von-typsystemen">Korrektheit von Typsystemen</a></li>
                <li><a href="#subtyping">Subtyping</a></li>
                <li><a href="#nominale-und-strukturelle-typen">Nominale und strukturelle Typen</a></li>
              </ul>
            </li>
            <li>
              <a href="#sec:static-typesystems-for-js">Statische Typsysteme für JavaScript</a>
              <ul>
                <li><a href="#sec:flow">Flow</a></li>
                <li><a href="#sec:typescript">TypeScript</a></li>
              </ul>
            </li>
            <li>
              <a href="#sec:transpilers">Transpilierung von Quelltexten</a>
              <ul>
                <li><a href="#sec:transpiler-concepts">Konzepte und Aufbau von Transpilern</a></li>
                <li><a href="#sec:js-transpilers">Evaluation bestehender Werkzeuge zur Quelltexttransformation</a></li>
                <li><a href="#sec:babel">Babel</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          <a href="#chap:analysis">Ziel- und Anforderungsanalyse</a>
          <ul>
            <li>
              <a href="#sec:status-quo">Ausgangslage und Rahmenbedingungen</a>
              <ul>
                <li><a href="#sec:teamshirts-projects">Kurzvorstellung der Projekte von TeamShirts</a></li>
                <li>
                  <a href="#sec:evaluation-other-transpilers"
                    >Evaluation bestehender Ansätze zur Transpilierung von Flow</a
                  >
                </li>
              </ul>
            </li>
            <li>
              <a href="#sec:goals">Ziele der Migration zu TypeScript</a>
              <ul>
                <li>
                  <a href="#erkennung-weiterer-typ--und-programmfehler">Erkennung weiterer Typ- und Programmfehler</a>
                </li>
                <li><a href="#unterstützung-externer-bibliotheken">Unterstützung externer Bibliotheken</a></li>
                <li><a href="#performance-der-typüberprüfungen">Performance der Typüberprüfungen</a></li>
                <li><a href="#sec:goal:transparency">Zukunftssicherheit und Transparenz der Technologie</a></li>
              </ul>
            </li>
            <li>
              <a href="#sec:requirements">Technische Anforderungen an den Transpiler</a>
              <ul>
                <li>
                  <a href="#sec:requirement:completeness">Äquivalente und vollständige Übersetzung der Flow-Typen</a>
                </li>
                <li>
                  <a href="#sec:requirement:semantic-equivalence"
                    >Semantisch äquivalente Transpilierung des Quelltexts</a
                  >
                </li>
                <li>
                  <a href="#sec:requirement:syntax"
                    >Unterstützung aktueller und vorläufiger JavaScript- sowie JSX-Syntax</a
                  >
                </li>
                <li><a href="#sec:requirement:batch-processing">Verarbeitung gesamter Projektverzeichnisse</a></li>
                <li><a href="#sec:requirement:format">Beibehaltung der Quelltextformatierung</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          <a href="#chap:implementation">Umsetzung</a>
          <ul>
            <li><a href="#sec:software-architecture">Softwarearchitektur</a></li>
            <li>
              <a href="#entwicklungsprozess">Entwicklungsprozess</a>
              <ul>
                <li><a href="#sec:tdd">Testgetriebene Entwicklung</a></li>
                <li><a href="#statische-typisierung-von-babel">Statische Typisierung von Babel</a></li>
              </ul>
            </li>
            <li>
              <a href="#sec:implementation">Implementierung als Babel-Plugin</a>
              <ul>
                <li>
                  <a href="#überblick-über-ablauf-der-transpilierung">Überblick über Ablauf der Transpilierung</a>
                </li>
                <li><a href="#sec:flow-transpilation">Transpilierung der Flow-Typen</a></li>
                <li><a href="#sec:optimizations">Weitere Optimierungen</a></li>
              </ul>
            </li>
            <li><a href="#sec:cli-program">Erweiterung als Kommandozeilenprogramm</a></li>
            <li><a href="#sec:formatting">Formatierung des Ausgabequelltexts</a></li>
          </ul>
        </li>
        <li>
          <a href="#chap:evaluation">Auswertung und Diskussion</a>
          <ul>
            <li><a href="#durchführung-der-migration">Durchführung der Migration</a></li>
            <li>
              <a href="#bewertung-der-ergebnisse-hinsichtlich-der-zielvorgabe"
                >Bewertung der Ergebnisse hinsichtlich der Zielvorgabe</a
              >
              <ul>
                <li><a href="#goal:new-type-errors">Erkennung weiterer Typ- und Programmfehler</a></li>
                <li><a href="#unterstützung-externer-bibliotheken-1">Unterstützung externer Bibliotheken</a></li>
                <li><a href="#performance-der-typüberprüfungen-1">Performance der Typüberprüfungen</a></li>
                <li>
                  <a href="#zukunftssicherheit-und-transparenz-der-technologie"
                    >Zukunftssicherheit und Transparenz der Technologie</a
                  >
                </li>
              </ul>
            </li>
            <li>
              <a href="#erfüllung-der-technischen-anforderungen">Erfüllung der technischen Anforderungen</a>
              <ul>
                <li>
                  <a href="#sec:interpretation:equivalent-translation"
                    >Äquivalente und vollständige Übersetzung der Flow-Typen</a
                  >
                </li>
                <li>
                  <a href="#semantisch-äquivalente-transpilierung-des-quelltexts"
                    >Semantisch äquivalente Transpilierung des Quelltexts</a
                  >
                </li>
                <li>
                  <a href="#unterstützung-aktueller-und-vorläufiger-javascript--sowie-jsx-syntax"
                    >Unterstützung aktueller und vorläufiger JavaScript- sowie JSX-Syntax</a
                  >
                </li>
                <li>
                  <a href="#verarbeitung-gesamter-projektverzeichnisse">Verarbeitung gesamter Projektverzeichnisse</a>
                </li>
                <li><a href="#sec:results-formatting">Beibehaltung der Quelltextformatierung</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          <a href="#chap:conclusion">Schlussbetrachtung</a>
          <ul>
            <li><a href="#zusammenfassung-der-ergebnisse">Zusammenfassung der Ergebnisse</a></li>
            <li><a href="#mögliche-erweiterungen-des-projekts">Mögliche Erweiterungen des Projekts</a></li>
          </ul>
        </li>
      </ul>
    </nav>
    <main>
      <section>
        <h1 id="chap:motiviation"><span class="chap-number">1</span>Motivation</h1>
        <h2 id="historischer-abriss-von-javascript">
          <span class="chap-number">1.1</span>Historischer Abriss von JavaScript
        </h2>
        <p>
          Als JavaScript 1995 von Brendan Eich in nur zehn Tagen als Bestandteil des Webbrowsers
          <em>Netscape Communicator</em> entworfen wurde <a class="citation" href="#ref-SEVERANCE:2012">[4]</a>, war
          nicht abzusehen, welche Relevanz die Sprache über 20 Jahre später besitzen würde: Heute wird JavaScript oft
          als die am weitesten verbreitete Programmiersprache der Welt angesehen
          <a class="citation" href="#ref-PAULSON:2007">[5]</a>,
          <a class="citation" href="#ref-CROCKFORD:JS_POPULAR">[6]</a>. Dies belegt beispielsweise die alljährliche
          Umfrage „<em>Stack Overflow Developer Survey</em>“ der Programmierer-Plattform <em>Stack Overflow</em>, welche
          die Ergebnisse der weltweiten Befragung von circa 90.000 Softwareentwicklern auswertet
          <a class="citation" href="#ref-STACKOVERFLOW:SURVEY">[7]</a>. Bereits das siebte Jahr in Folge führt
          JavaScript dort die Rangliste der populärsten Programmiersprachen an. Der seit vielen Jahren anhaltende Trend,
          dass zunehmend mehr Software als Webanwendung statt konventioneller Desktop-Anwendung realisiert wird, hat die
          Bedeutung von JavaScript stark erhöht <a class="citation" href="#ref-TAIVALSAARI:2017">[8]</a>,
          <a class="citation" href="#ref-CASTELEYN:2014">[9]</a>.
        </p>
        <p>
          Die heutige große Beliebtheit der Sprache steht in starkem Kontrast zu ihren Anfängen. Zunächst besaß
          JavaScript eine zweifelhafte Reputation und wurde aus verschiedenen Gründen von professionellen
          Softwareentwicklern als eine mangelhaft entworfene Programmiersprache angesehen
          <a class="citation" href="#ref-CROCKFORD:JS_POPULAR">[6]</a>: Die uneinheitliche und teilweise fehlerbehaftete
          Implementierung in den frühen Webbrowsern und der Mangel an Entwicklungswerkzeugen wie Debuggern erschwerte
          die Programmierung von JavaScript-Anwendungen enorm
          <a class="citation" href="#ref-OREILLY:JS_HOW_DID_WE_GET_THERE">[10]</a>. Darüber hinaus behinderte die
          anfängliche Unbeständigkeit der Sprache und die „schlechte Qualität“
          <a class="citation" href="#ref-CROCKFORD:JS_MISUNDERSTOOD">[11]</a> der ersten Versionen der
          ECMAScript-Spezifikation<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
          <a class="citation" href="#ref-ECMASCRIPT:1997">[12]</a> eine breite Akzeptanz der Sprache in der damaligen
          Entwickler-Szene. Ein weiterer Aspekt von JavaScript, der bis heute kritisch betrachtet wird, ist die
          dynamische Typisierung der Sprache, weil diese die Entwicklung sicherer und korrekter Software erschwert
          <a class="citation" href="#ref-NIKHIL:2014">[13]</a>, <a class="citation" href="#ref-PRADEL:2015">[14]</a>. Im
          Folgenden soll dieser Gesichtspunkt näher beleuchtet werden, um die Problematik zu verdeutlichen.
        </p>
        <h2 id="javascripts-dynamische-typisierung">
          <span class="chap-number">1.2</span>JavaScripts dynamische Typisierung
        </h2>
        <p>
          Eine dynamische Typisierung ist dadurch charakterisiert, dass jedem Wert der Programmiersprache zur
          <em>Laufzeit</em> ein Typ zugewiesen wird und sich dieser je nach Striktheit des Typsystems zu einem späteren
          Zeitpunkt implizit oder explizit ändern kann <a class="citation" href="#ref-WALDMANN:PPS">[15, S. 45]</a>.
          Typfehler werden dabei durch dynamische Überprüfungen der Laufzeitumgebung erkannt
          <a class="citation" href="#ref-CARDELLI:TYPE_SYSTEMS">[16, S. 37]</a>. JavaScript besitzt die folgenden sieben
          Datentypen <a class="citation" href="#ref-ECMASCRIPT:2019">[17, S. 25]</a>. Diese legen fest, wie Werte des
          Programms zur Laufzeit interpretiert werden, welchen Wertebereich sie umfassen und welche Operationen mit
          ihnen möglich sind. Alle Datentypen außer <code>Object</code> sind dabei primitiv, das heißt nicht weiter
          zerlegbar (atomar) <a class="citation" href="#ref-ECMASCRIPT:2019">[17, S. 8]</a>.
        </p>
        <ul>
          <li>
            <span><code>Undefined</code></span
            >: Undefinierte Werte
          </li>
          <li>
            <span><code>Null</code></span
            >: Nullwert
          </li>
          <li>
            <span><code>Boolean</code></span
            >: Boolesche Werte
          </li>
          <li>
            <span><code>String</code></span
            >: Zeichenketten
          </li>
          <li>
            <span><code>Symbol</code></span
            >: Eindeutige Bezeichner
          </li>
          <li>
            <span><code>Number</code></span
            >: Gleitkommazahlen
          </li>
          <li>
            <span><code>Object</code></span
            >: Alles Weitere (Felder, Funktionen, Objekte, usw.)
          </li>
        </ul>
        <p>
          Der Typ von Werten wird in JavaScript während der Programmausführung bei Bedarf automatisch implizit
          umgewandelt (<em>type coercion</em>) <a class="citation" href="#ref-RICHARDS:2010">[18]</a>. Einerseits kann
          argumentiert werden, dass eine derartige Flexibilität den Entwicklungsprozess beschleunigt
          <a class="citation" href="#ref-FLOW:PAPER">[1, S. 1]</a>, andererseits birgt dies das Risiko von
          Programmfehlern, da Typverletzungen erst zur Laufzeit festgestellt werden können
          <a class="citation" href="#ref-ANDERSON:2005">[19]</a>. Weil eine Typisierung von Ausdrücken syntaktisch nicht
          möglich ist, ist nicht immer offensichtlich, welche Datentypen in JavaScript-Quelltexten vorliegen. Deshalb
          ist die Programmierung so fehleranfällig. Problematisch für die Entwicklung korrekter Anwendungen ist darüber
          hinaus, dass JavaScript viele Operationen, die traditionell als dynamischer Typfehler gelten, nicht als solche
          behandelt, sondern die Programmausführung fortsetzt <a class="citation" href="#ref-NIKHIL:2014">[13]</a>. So
          kann beispielsweise auf nicht-existente Attribute von Objekten zugegriffen werden, ohne dass dies eine
          Typverletzung verursacht. Infolgedessen ist es möglich, dass inkorrektes Programmverhalten zunächst unentdeckt
          bleibt, weil nicht unmittelbar ein fataler Fehler auftritt.
        </p>
        <h2 id="motivation-für-den-einsatz-statischer-typsysteme">
          <span class="chap-number">1.3</span>Motivation für den Einsatz statischer Typsysteme
        </h2>
        <p>
          Viele der anfänglichen Unzulänglichkeiten von JavaScript konnten durch Erweiterungen der Spezifikation und
          zunehmend konsistenter Implementierungen nach und nach behoben werden. Swamy et al. führen aber aus, dass die
          dynamische Typisierung der Sprache weiterhin ein Hindernis für die Entwicklung sicherer und korrekter
          Anwendungen darstellen kann <a class="citation" href="#ref-NIKHIL:2014">[13]</a>. Auch Bierman et al.
          vertreten die These, dass JavaScript nach wie vor ungeeignet sei für die Entwicklung und Wartung umfangreicher
          Software <a class="citation" href="#ref-BIERMAN:2014">[20, S. 1]</a>. Über die Jahre sind verschiedene Ansätze
          entstanden, um diese Problematik zu überwinden, indem JavaScript um ein <em>statisches</em> Typsystem
          erweitert wird. Der wesentliche Zweck statischer Typsysteme ist die Vermeidung von Programmfehlern
          <a class="citation" href="#ref-CARDELLI:TYPE_SYSTEMS">[16, S. 1]</a>. Dies wird durch die statische Analyse
          des Quelltexts realisiert, sodass Typverletzungen bereits vor der Programmausführung festgestellt werden
          können. Im Gegensatz zu einer dynamischen Typisierung wird der Typ von Ausdrücken in statischen Systemen
          explizit deklariert oder kann selbstständig inferiert (abgeleitet) werden
          <a class="citation" href="#ref-WALDMANN:PPS">[15, S. 45]</a>. Eine <em>explizite</em> Typisierung bedeutet,
          dass Typdeklarationen Bestandteil der Syntax der Programmiersprache bzw. des Systems sind
          <a class="citation" href="#ref-CARDELLI:TYPE_SYSTEMS">[16, S. 2]</a>.
        </p>
        <p>
          Ein statisches Typsystem bietet verschiedene Vorteile für den Softwareentwicklungsprozess: Da Typen als ein
          Attribut angesehen werden können, die eine bestimmte Eigenschaft des Programms mittels der Mechanismen des
          Typsystems beweisen, tragen sie zur Verifizierung der Programmkorrektheit bei
          <a class="citation" href="#ref-SMITH:TYPE_SYSTEMS">[21]</a>. Weil der Compiler statisch berechnen kann, ob bei
          Ausdrücken und Anweisungen Typverletzungen auftreten, können semantische Probleme wie Logik- und
          Flüchtigkeitsfehler aufgedeckt und korrigiert werden. Sofern alle Schnittstellen und Datenstrukturen typisiert
          sind, wird deren inkorrekte Verwendung unmittelbar erkannt
          <a class="citation" href="#ref-CARDELLI:TYPE_SYSTEMS">[16, S. 6]</a>. Weiterhin ist es möglich, die
          Einschränkungen und Regeln der gegebenen Anwendungsdomäne durch das Typsystem präzise zu modellieren und deren
          Einhaltung mit Hilfe des System zu erzwingen. Auch erfordert die Deklaration expliziter Typen, dass der
          Entwickler die Absicht seines Programms klar formuliert, wodurch sich die Ausdruckskraft und Lesbarkeit des
          Codes erhöht <a class="citation" href="#ref-WALDMANN:PPS">[15, S. 96]</a>. Durch eine Typisierung wird das
          Verhalten und die Struktur der Software darüber hinaus bereits grundlegend dokumentiert
          <a class="citation" href="#ref-MITCHELL:CONCEPTS">[22, Abschn. 6.1.1]</a>.
        </p>
        <p>
          Derzeit existieren zwei populäre Technologien, die eine statische Typisierung in JavaScript ermöglichen und so
          die Defizite des dynamischen Typsystems ausgleichen: einerseits <em>Flow</em>
          <a class="citation" href="#ref-FLOW:PAPER">[1]</a>, andererseits <em>TypeScript</em>
          <a class="citation" href="#ref-TYPESCRIPT:SPEC">[2]</a>. Eine nach wie vor ungelöste Problemstellung ist
          jedoch die äquivalente Übersetzung dieser Systeme ineinander. Die Motivation für eine derartige Transformation
          ist es, den Wechsel des eingesetzten statischen Typsystems mit möglichst geringem manuellen Aufwand zu
          realisieren. Die händische Übertragung umfangreicher Projekte ist impraktikabel, weil dies sehr zeitaufwändig
          und fehleranfällig wäre.
        </p>
        <h2 id="zielsetzung-und-aufbau-der-arbeit">
          <span class="chap-number">1.4</span>Zielsetzung und Aufbau der Arbeit
        </h2>
        <p>
          Die vorliegende Masterarbeit beschäftigt sich mit der Lösung dieser aufgeworfenen Problemstellung, der
          automatischen Migration von Flow nach TypeScript, und ist in Zusammenarbeit mit dem Unternehmen
          <em>sprd.net AG</em> (<em>Spreadshirt</em>) entstanden. Ziel der Arbeit ist die Entwicklung eines
          <em>Transpilers</em> (auch Transcompiler genannt), der es ermöglicht, den gesamten Quelltext eines durch Flow
          typisierten JavaScript-Projekts in äquivalenten TypeScript-Code zu übersetzen. Unter einem Transpiler wird ein
          spezieller Compiler verstanden, der den Quelltext einer Programmiersprache in eine andere Programmiersprache
          mit ähnlichem Abstraktionsniveau bedeutungsgleich übersetzt
          <a class="citation" href="#ref-EVGENIY:2016">[23]</a>. Der Wechsel des eingesetzten Typsystems wird durch
          Spreadshirt angestrebt, da angenommen wird, dass TypeScript verschiedener Vorteile gegenüber Flow aufweist. So
          wird vermutet, dass TypeScript Typ- und Programmfehler in höherem Maße erkennt und externe
          Softwarebibliotheken besser unterstützt. Außerdem erwartet man sich, dass TypeScript Flow hinsichtlich der
          Performance, Transparenz und Zukunftssicherheit überlegen ist. Die Verifizierung dieser Thesen auf Grundlage
          empirischer Daten und der gesammelten Erfahrung während der Projektmigration ist Gegenstand der anschließenden
          Untersuchung.
        </p>
        <p>
          Der Aufbau der Arbeit gliedert sich in sechs Kapitel: Nachfolgend werden zunächst die benötigten theoretischen
          Grundlagen bezüglich statischer Typsysteme und der Transpilierung von Programmen geschaffen. Weiterhin werden
          die Typsysteme sowohl von Flow, als auch von TypeScript charakterisiert und voneinander abgegrenzt.
          Anschließend werden die Rahmenbedingungen zu Beginn der Arbeit beschrieben, die Ziele des Wechsels von Flow zu
          TypeScript erläutert und die Anforderungen an den angestrebten Transpiler ausgeführt. Daraufhin werden
          Architektur und Details der Implementierung des Übersetzers ausführlich betrachtet. In Kapitel
          <a href="#chap:evaluation" data-reference-type="ref" data-reference="chap:evaluation">5</a> wird die
          Durchführung der Migration der JavaScript-Projekte von Spreadshirt mittels des umgesetzten Transcompilers
          dargelegt und gewonnene Erfahrungen beschrieben. Außerdem werden hier die Ergebnisse der Migration
          ausgewertet, kritisch diskutiert und hinsichtlich der Zielvorgabe bewertet. Bereits heute bestehen Ansätze zur
          Transpilierung von Flow, die aber weder vollständig noch fehlerfrei sind. Der realisierte Transpiler wird
          diesen bestehenden Werkzeugen gegenübergestellt, sodass die erzielten Ergebnisse besser eingeordnet werden
          können. Zuletzt wird ein Fazit der gesamten Arbeit gezogen und ein Ausblick über mögliche Erweiterungen
          gegeben.
        </p>
      </section>
      <section>
        <h1 id="chap:basics"><span class="chap-number">2</span>Grundlagen</h1>
        <p>
          Bevor die Ziele der Migration von Flow zu TypeScript im nächsten Kapitel detailliert dargelegt werden, sollen
          zunächst die nötigen theoretischen Grundlagen dargestellt werden, um die Nachvollziehbarkeit der weiteren
          Ausführungen zu erleichtern. Dazu werden im Folgenden drei Konzepte aus der Theorie der Typensysteme
          erläutert, die relevant für die Differenzierung von Flow gegenüber TypeScript sind.
        </p>
        <h2 id="konzepte-und-begriffe-der-typentheorie">
          <span class="chap-number">2.1</span>Konzepte und Begriffe der Typentheorie
        </h2>
        <h3 id="korrektheit-von-typsystemen"><span class="chap-number">2.1.1</span>Korrektheit von Typsystemen</h3>
        <p>
          Ein wichtige Eigenschaft von Typsystemen ist deren logische <em>Korrektheit</em
          ><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a
          >. Dieses Kriterium beschreibt, ob das System garantieren kann, dass ein Programm während dessen Ausführung
          tatsächlich keine Typfehler verursacht, sofern keine statischen Typverletzungen bestehen
          <a class="citation" href="#ref-WRIGHT:1994">[24]</a>. In einem solchen System stimmt also der Typ eines zur
          Laufzeit ausgewerteten Ausdrucks stets mit dem statischen Typ überein
          <a class="citation" href="#ref-DART:TYPE_SYSTEM">[25]</a>. Durch mathematische Formalisierung kann diese
          Eigenschaft bewiesen werden <a class="citation" href="#ref-CARDELLI:TYPE_SYSTEMS">[16, S. 7]</a>. Das
          Gegenstück von Korrektheit ist <em>Vollständigkeit</em>. Während ein korrektes System alle Fehler
          identifiziert, die zur Laufzeit auftreten können, findet ein vollständiges System nur diejenigen Fehler, die
          tatsächlich während der Ausführung eintreten
          <a class="citation" href="#ref-FLOW:TYPES_AND_EXPRESSIONS">[26]</a>. Im ersten Fall werden unter Umständen
          Fehler entdeckt, die zur Laufzeit praktisch nicht vorkommen (falsch positiver Fehler), im zweiten Fall treten
          dagegen eventuell Laufzeitfehler auf, obwohl keine Typverletzung festgestellt wurde (falsch negativer Fehler).
          Im Idealfall ist ein Typsystem sowohl korrekt als auch vollständig.
        </p>
        <p>
          Das Typsystem mancher Programmiersprachen ist nicht korrekt. So ist die Semantik bestimmter Operationen in C
          wie beispielsweise die Dereferenzierung des Nullzeigers in der Sprachspezikation undefiniert
          <a class="citation" href="#ref-ISO:C99">[27, S. 79]</a>. Obwohl ein solches Programm durch den Compiler
          akzeptiert wird, also keine Typverletzungen aufweist, können hier Laufzeitfehler auftreten.
        </p>
        <h3 id="subtyping"><span class="chap-number">2.1.2</span>Subtyping</h3>
        <p>
          Die zwei in dieser Arbeit betrachteten Typsysteme Flow <a class="citation" href="#ref-FLOW:PAPER">[1]</a> und
          TypeScript <a class="citation" href="#ref-TYPESCRIPT:SPEC">[2]</a> setzen <em>Subtyping</em> ein, um die
          Beziehung zwischen Super- und Subtypen abzubilden <a class="citation" href="#ref-FLOW:PAPER">[1]</a>,
          <a class="citation" href="#ref-BIERMAN:2014">[20]</a>. Grundsätzlich kann ein Typ als eine Menge von Werten
          betrachtet werden, die eine gemeinsame Struktur oder Form besitzen
          <a class="citation" href="#ref-AMADIO:1993">[28, S. 3]</a>. Subtyping stellt die reflexive und transitive
          Relation dar, die aussagt, ob ein Typ T Untertyp eines anderen Typen S ist
          <a class="citation" href="#ref-CARDELLI:TYPE_SYSTEMS">[16, S. 27]</a>. Hierfür muss das Kriterium der
          <em>Subsumtion</em> erfüllt sein. Diese besteht, wenn die Menge, die S darstellt, jeden Wert von T beinhaltet.
          Folglich kann der Typ T überall dort eingesetzt werden, wo S erwartet wird (<em
            >Liskovsches Substitutionsprinzip</em
          >). Existiert zum Beispiel ein Typ Z, der allen ganzen Zahlen entspricht, und weiterhin ein Typ N, der alle
          natürlichen Zahlen beinhaltet, so ist N Subtyp von Z, weil Z die Menge N umfasst.
        </p>
        <p>
          Zwei weitere Begriff in diesem Zusammenhang, die in den weiteren Ausführungen verwendet werden, sind
          <em>Kovarianz</em> und <em>Kontravarianz</em>. Dabei bedeutet Kovarianz eine Betrachtung <em>in</em> Richtung
          der Subtyp-Hierarchie, Kontravarianz <em>entgegen</em> dieser
          <a class="citation" href="#ref-VARIANCE">[29]</a>. Im Fall von Kovarianz werden Subtypen, aber keine
          Supertypen akzeptiert, bei Kontravarianz hingegen nur Supertypen, aber keine Subtypen
          <a class="citation" href="#ref-FLOW:VARIANCE">[30]</a>.
        </p>
        <h3 id="nominale-und-strukturelle-typen">
          <span class="chap-number">2.1.3</span>Nominale und strukturelle Typen
        </h3>
        <p>
          Eine Möglichkeit, Typsysteme zu klassifizieren, ist die Verwendung von <em>nominalen</em> bzw.
          <em>strukturellen</em> Typen. Da sich Flow und TypeScript in diesem Aspekt unterscheiden, soll auch diese
          Differenzierung dargelegt werden. Entscheidend ist hierbei, ob unabhängige Typen durch das Typsystem als
          äquivalent angesehen werden oder nicht <a class="citation" href="#ref-CARDELLI:TYPE_SYSTEMS">[16, S. 9]</a>.
          Auch die Subtyp-Relation wird hierdurch beeinflusst: Bei strukturellen Typen liegt ein Subtyp vor, wenn dessen
          Attribute eine Obermenge des anderen Typs sind <a class="citation" href="#ref-MALAYERI:2008">[31]</a>. Liegt
          hingegen ein nominaler Typ vor, so besteht eine solche Beziehung nur genau dann, wenn sie explizit syntaktisch
          deklariert wird<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a
          >. Die Typsysteme der meisten Programmiersprachen setzen sowohl nominale als auch strukturelle Typen ein
          <a class="citation" href="#ref-CARDELLI:TYPE_SYSTEMS">[16, S. 9]</a>. Anhand eines Beispiels in Pseudocode
          (Quelltext
          <a href="#code:type-equivalence" data-reference-type="ref" data-reference="code:type-equivalence"
            >[code:type-equivalence]</a
          >) soll der Unterschied verdeutlicht werden.
        </p>
        <pre><code>class A { prop: string; }
class B { prop: string; }
function f(arg: A) {}
f(new B()); // &lt;&lt; Typfehler?</code></pre>
        <p>
          In den ersten beiden Zeilen werden zunächst zwei Klassen <span><code>A</code></span> und
          <span><code>B</code></span> definiert. Weiterhin wird eine Funktion <span><code>f</code></span> angegeben, die
          einen Parameter vom Typ <span><code>A</code></span> erwartet. Bei Aufruf dieser Funktion mit einer Instanz der
          Klasse <span><code>B</code></span> sind nun zwei Fälle möglich: Entweder spezifiziert das System, dass Typen
          mit unterschiedlichen Namen stets inkompatibel sind, oder die Typen <span><code>A</code></span> und
          <span><code>B</code></span> werden als äquivalent betrachtet, da ihre Struktur übereinstimmt. Im ersten Fall
          würde in Zeile 4 eine Typverletzung auftreten, weil der Typ des Ausdrucks
          <span><code>new B()</code></span> nicht <span><code>A</code></span
          >, sondern <span><code>B</code></span> ist. Läge hingegen eine strukturelle Typisierung vor, so würde das
          Programm akzeptiert werden, da der Aufbau der Klassen <span><code>A</code></span> und
          <span><code>B</code></span> identisch ist. Beide enthalten genau ein Attribut
          <span><code>prop</code></span> mit demselben Typ <span><code>string</code></span
          >.
        </p>
        <h2 id="sec:static-typesystems-for-js">
          <span class="chap-number">2.2</span>Statische Typsysteme für JavaScript
        </h2>
        <p>
          In den nachfolgenden Abschnitten sollen nun die charakteristischen Merkmale der zwei in dieser Arbeit
          behandelten statischen Typsysteme <em>Flow</em> <a class="citation" href="#ref-FLOW:PAPER">[1]</a> und
          <em>TypeScript</em> <a class="citation" href="#ref-TYPESCRIPT:SPEC">[2]</a> näher beleuchtet werden, um deren
          Unterschiede und Gemeinsamkeiten herauszuarbeiten.
        </p>
        <h3 id="sec:flow"><span class="chap-number">2.2.1</span>Flow</h3>
        <h4 id="charakterisierung">Charakterisierung</h4>
        <p>
          Flow <a class="citation" href="#ref-FLOW:PAPER">[1]</a> ist ein durch das US-amerikanische Unternehmen
          <em>Facebook Inc.</em> entwickeltes Software-System, das statische Typüberprüfungen in JavaScript durch das
          Einfügen von Typannotationen in den Quelltext ermöglicht. Derartige Annotationen sind eine syntaktische
          Erweiterung, die vor Auslieferung des Codes mittels eines geeigneten Werkzeugs wie beispielsweise Babel
          <a class="citation" href="#ref-BABEL">[3]</a> entfernt werden muss, damit wieder regulärer JavaScript-Code
          entsteht <a class="citation" href="#ref-FLOW:INSTALLATION">[32]</a>. Flow ist seit 2014 frei und quelloffen
          unter der MIT-Lizenz verfügbar <a class="citation" href="#ref-LICENSE:MIT">[33]</a>,
          <a class="citation" href="#ref-FLOW:GITHUB">[34]</a>. Das Typsystem von Flow wird in der akademischen Arbeit
          „<em>Fast and Precise Type Checking for JavaScript</em>“
          <a class="citation" href="#ref-FLOW:PAPER">[1]</a> von Chaudhuri et al. ausführlich beschrieben. Die
          nachfolgenden Erläuterungen beziehen sich vorrangig auf den Inhalt dieser Veröffentlichung.
        </p>
        <p>
          Flow verfolgt zwei primäre Ziele <a class="citation" href="#ref-FLOW:TYPE_SYSTEM">[35]</a>: Erstens soll eine
          möglichst hohe Präzision durch die Typüberprüfungen erreicht werden, um möglichst zuverlässige Ergebnisse, das
          heißt eine geringe Quote falsch positiver und falsch negativer Fehler, zu erzielen. Zweitens müssen diese
          Ergebnisse selbst bei einer sehr umfangreichen Codebasis schnell berechnet werden können, damit der Workflow
          des Programmierers nicht verlangsamt wird.
        </p>
        <p>
          Das erste Ziel wird zum einen anhand einer pfadsensitiven Datenflussanalyse, zum anderen durch die Korrektheit
          des Typsystems realisiert <a class="citation" href="#ref-FLOW:TYPE_SYSTEM">[35]</a>. Mittels einer solchen
          Datenflussanalyse kann das Laufzeitverhalten von Software präzise modelliert und so der Typ von Ausdrücken
          durch Einbeziehung der Programmverzweigungen (der Pfade) auf speziellere Untertypen abgebildet werden (<em
            >type refinement</em
          >) <a class="citation" href="#ref-FLOW:PAPER">[1, S. 2]</a>,
          <a class="citation" href="#ref-WINTER:2013">[36]</a>. Um die Korrektheit des Typsystems sicherzustellen,
          berücksichtigt Flow während der Typüberprüfung von Ausdrücken alle theoretisch möglichen Fälle
          <a class="citation" href="#ref-FLOW:TYPES_AND_EXPRESSIONS">[26]</a>. Wie ausgeführt birgt diese Präferenz von
          Korrektheit über Vollständigkeit den Nachteil, dass unter Umständen Typfehler angezeigt werden, die zur
          Laufzeit tatsächlich gar nicht auftreten. Gleichzeitig steigt aber durch diesen Ansatz die Sicherheit, weil
          damit die Wahrscheinlichkeit sinkt, dass Laufzeitfehler durch das Typsystem unentdeckt bleiben.
        </p>
        <p>
          Die zweite Zielvorgabe, die Steigerung der Geschwindigkeit der Typüberprüfungen, wird durch eine
          Modularisierung des Verfahrens erreicht, sodass die Berechnung anhand mehrerer Threads stark parallelisiert
          werden kann (<em>Multithreading</em>) <a class="citation" href="#ref-FLOW:PAPER">[1, S. 4]</a>. Flow nutzt den
          Umstand, dass in modernen JavaScript-Projekten üblicherweise genau eine Datei pro Modul vorliegt. Unabhängige
          Module können somit auf verschiedenen Prozessorkernen gleichzeitig überprüft werden. Daraufhin werden die
          Ergebnisse der einzelnen Berechnungen durch einen MapReduce-Algorithmus, der auf einer geteilten
          Heap-Datenstruktur arbeitet, zum Gesamtergebnis der Typüberprüfung rekombiniert
          <a class="citation" href="#ref-FLOW:PAPER">[1, S. 22]</a>.
        </p>
        <p>
          Flow ist in der Lage Typen global zu inferieren
          <a class="citation" href="#ref-FLOW:PAPER">[1, S. 25]</a>. Das heißt, der Typ vieler Ausdrücke muss nicht
          explizit angegeben werden, sondern kann durch das Typsystem selbstständig abgeleitet werden. Deshalb kann
          bereits mit wenigen expliziten Annotationen eine hohe Abdeckung des gesamten Quelltexts durch das Typsystem
          erzielt werden. So führen Chaudhuri et al. aus, dass in einer circa 13 Millionen Zeilen umfassenden Codebasis
          von Facebook im Median nur 29% aller Stellen, an denen Typannotationen möglich sind, nötig waren, um eine
          vollständige Abdeckung durch Flow zu erzielen <a class="citation" href="#ref-FLOW:PAPER">[1, S. 24]</a>.
        </p>
        <p>
          Eine weitere Eigenschaft von Typsystemen ist deren Verwendung von nominalen und strukturellen Typen. Flow
          behandelt Klassen und opake Typen<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"
            ><sup>4</sup></a
          >
          hierbei nominal, alle anderen Typen dagegen strukturell
          <a class="citation" href="#ref-FLOW:NOMINAL_TYPES">[37]</a>. Somit werden diese Typen stets als inkompatibel
          angesehen, selbst wenn ihr struktureller Aufbau dies zuließe.
        </p>
        <h4 id="architektur">Architektur</h4>
        <p>
          Die Architektur von Flow gliedert sich in einen Server, einen Client und einen Dateisystemüberwacher
          <a class="citation" href="#ref-FLOW:PAPER">[1, S. 22]</a>. Der Server liest zunächst den Quelltext des
          gesamten Projekts ein und überprüft diesen hinsichtlich Typverletzungen. Daraufhin läuft der Prozess im
          Hintergrund weiter und ist bereit, Anfragen des Clients entgegen zu nehmen. Der Client – zum Beispiel die
          integrierte Entwicklungsumgebung – kann nun durch Kommandos einerseits den generellen Status der
          Typüberprüfung abrufen, andererseits spezifischere Informationen wie beispielsweise den Typ eines bestimmten
          Ausdrucks abfragen. Sobald eine Datei editiert, neu erstellt oder gelöscht wird, wird dies dem Server durch
          den Dateisystemüberwacher mitgeteilt. Daraufhin überprüft der Server die Typkorrektheit inkrementell auf
          Grundlage des modifizierten Quelltexts erneut. Dabei werden nur geänderte Module und deren Abhängigkeiten
          betrachtet, sodass der Berechnungs- und damit Zeitaufwand stark reduziert werden kann. Weil die aktuellen
          Ergebnisse stets im Arbeitsspeicher vorgehalten werden, können nachfolgende Anfragen des Clients schnell
          beantwortet werden.
        </p>
        <h4 id="beispiel">Beispiel</h4>
        <p>
          Zur Veranschaulichung, wie Flow konkret benutzt wird, soll in Quelltext
          <a href="#code:example-flow" data-reference-type="ref" data-reference="code:example-flow"
            >[code:example-flow]</a
          >
          die Typisierung eines einfachen JavaScript-Programms anhand des Algorithmus der linearen Suche gezeigt werden.
          <!-- In diesem und allen weiteren Quelltexten werden dabei die Schlüsselworte von JavaScript bzw. TypeScript <span><b><code>fett</code></b></span> und Typannotationen <span><i><code>kursiv</code></i></span> abgedruckt. -->
        </p>
        <pre><code>// @flow
function linearSearch&lt;T&gt;(list: Array&lt;T&gt;, searchValue: T): number | empty {
  for (const [index, value] of list.entries()) {
    if (value === searchValue) {
      return index;
    }
  }
  throw new Error(&#39;Not found&#39;);
}

linearSearch&lt;number&gt;([3, 1, 10, 56], 10);        // 2
linearSearch&lt;number&gt;([3, 1, 10, 56], 12);        // Exception (Not Found)
linearSearch&lt;string&gt;([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;], 3);  // Typfehler (3 ist kein String)</code></pre>
        <p>
          Das Programm beginnt in Zeile 1 mit einem speziellen Zeilenkommentar (<span><code>@flow</code></span
          >). Durch diese Direktive werden diejenigen Dateien markiert, die von Flow auf Typverletzungen überwacht
          werden sollen. In Zeile 2 wird anschließend die Funktion <span><code>linearSearch</code></span> definiert, die
          den Suchalgorithmus implementiert. Deren formale Parameter werden durch einen generischen Typparameter
          <span><code>T</code></span
          >, der in spitzen Klammern hinter dem Funktionsnamen deklariert wird, typisiert. Typannotationen werden durch
          Angabe eines Doppelpunkts, gefolgt von einem Typ notiert. Auf diese Weise wird festgelegt, dass der erste
          Parameter <span><code>list</code></span> ein homogenes Feld mit Werten des Typs
          <span><code>T</code></span> und der zweite Parameter <span><code>searchValue</code></span> ein Wert desselben
          Typs sein muss. Mit Hilfe dieser Einschränkung werden unsinnige Funktionsaufrufe mit Suchwerten, die aufgrund
          der Typisierung gar nicht Bestandteil des Felds sein <em>können</em>, statisch erkannt (vgl. Zeile 13). Dabei
          wird der Typparameter <span><code>T</code></span> beim Aufruf der Methode explizit gesetzt. Der Algorithmus
          liefert entweder den Feldindex des Suchwerts zurück, sofern dieser in der Liste vorkommt, oder löst eine
          <em>Exception</em> aus<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a
          >. Flow bietet für den zweiten Fall den adäquaten Typ <span><code>empty</code></span
          >, welcher dem leeren Typ <span class="math inline">⊥</span> (<em>bottom type</em>) entspricht. Der korrekte
          Rückgabetyp der Funktion ist somit der Vereinigungstyp aus <span><code>number</code></span> und
          <span><code>empty</code></span
          >. Dieser wird durch einen senkrechten Strich notiert und hinter der Auflistung der formalen Parameter
          deklariert. Die Typen der Ausdrücke innerhalb des Funktionskörpers müssen nicht explizit annotiert werden, da
          Flow diese inferieren kann.
        </p>
        <h4 id="typen">Typen</h4>
        <p>
          Nachfolgend sollen nun alle Sprachkonstrukte von Flow kurz beschrieben werden, um das Verständnis der späteren
          Erläuterung der Transpilierung zu vereinfachen. Die Syntax lässt sich in drei Kategorien einordnen:
          Basistypen, Hilfstypen und Typdeklarationen. Unter Basistypen werden in dieser Arbeit die regulären
          Typannotationen von Flow verstanden. Diese machen den größten Teil der Online-Dokumentation
          <a class="citation" href="#ref-FLOW:TYPE_ANNOTATIONS">[38]</a> aus. Hilfstypen (<em>Utility types</em>) sind
          spezielle Typen, die einen oder mehrere andere Typen als Argument erhalten und so einen neuen Typ mit
          zusätzlichen, nützlichen Eigenschaften berechnen. Typdeklarationen ermöglichen es schließlich, die
          Schnittstellen externer Bibliotheken und Frameworks durch spezielle Deklarationsdateien zu definieren. Auf
          diese Weise kann auch die Benutzung untypisierter Abhängigkeiten statisch überprüft werden.
        </p>
        <h4 id="sec:flow:base-types">Basistypen</h4>
        <p>
          Tabelle
          <a href="#tab:flow-base-types" data-reference-type="ref" data-reference="tab:flow-base-types"
            >[tab:flow-base-types]</a
          >
          listet die Basistypen von Flow auf, beschreibt deren Zweck und zeigt ein Beispiel. Um die Nachvollziehbarkeit
          zur Online-Dokumentation und der in Kapitel
          <a href="#chap:implementation" data-reference-type="ref" data-reference="chap:implementation">4</a>
          ausgeführten Implementierung zu erleichtern, werden die englischen Typbezeichnungen beibehalten und nicht ins
          Deutsche übersetzt. Die Beispiele und Erläuterungen versuchen den Großteil der Funktionalität von Flow zu
          veranschaulichen, jedoch können nicht alle Details ausführlich behandelt werden, da dies den Umfang der Arbeit
          überschreiten würde.
        </p>
        <p>TODO: base-types.tex</p>
        <h4 id="sec:flow:utility-types">Hilfstypen</h4>
        <p>
          Die Hilfstypen von Flow werden analog zu den Basistypen in Tabelle
          <a href="#tab:flow-utility-types" data-reference-type="ref" data-reference="tab:flow-utility-types"
            >[tab:flow-utility-types]</a
          >
          beschrieben. Es gilt anzumerken, dass die drei kursiv markierten Typen <em>Existential type</em>,
          <em>Subtype</em> und <em>Supertype</em> in der Dokumentation von Flow als überholt (<em>deprecated</em>)
          markiert wurden <a class="citation" href="#ref-FLOW:UTILITY_TYPES">[39]</a>. Diese sollten daher nicht mehr
          eingesetzt werden.
        </p>
        <p>TODO: utility-types.tex</p>
        <h4 id="sec:type-declarations">Typdeklarationen</h4>
        <p>
          Tabelle
          <a href="#tab:flow-type-declarations" data-reference-type="ref" data-reference="tab:flow-type-declarations"
            >[tab:flow-type-declarations]</a
          >
          zeigt schließlich exemplarisch die Syntax von Typdeklarationen. Für jede externe Bibliothek, die typisiert
          werden soll, wird hierbei eine eigene Datei angelegt, die das Modul annotiert. Standardmäßig liest Flow
          derartige Definitionsdateien aus dem Verzeichnis <span><code>flow-typed/</code></span> im Wurzelverzeichnis
          eines Projekts ein und bezieht diese bei der Typüberprüfung der gesamten Codebasis mit ein
          <a class="citation" href="#ref-FLOW:LIBRARY_DEFINITIONS">[40]</a>.
        </p>
        <p>TODO: declaration.tex</p>
        <h3 id="sec:typescript"><span class="chap-number">2.2.2</span>TypeScript</h3>
        <p>
          Nachdem das Typsystem von Flow charakterisiert wurde, sollen im Folgenden auch die Prinzipien und der Aufbau
          von TypeScript erklärt werden, um die Unterschiede der Ansätze zu verdeutlichen. Durch die Gegenüberstellung
          wird die Argumentation in der Auswertung der Ergebnisse in Kapitel
          <a href="#chap:evaluation" data-reference-type="ref" data-reference="chap:evaluation">5</a> vereinfacht.
        </p>
        <h4 id="charakterisierung-1">Charakterisierung</h4>
        <p>
          TypeScript <a class="citation" href="#ref-TYPESCRIPT:SPEC">[2]</a> ist eine frei verfügbare, quelloffene
          Programmiersprache, deren primäres Ziel die Bereitstellung einer statischen Typisierung für JavaScript ist
          <a class="citation" href="#ref-BIERMAN:2014">[20, S. 2]</a>. Die Sprache wird von der
          <em>Microsoft Corporation</em> entwickelt und wurde 2012 unter der <em>Apache License 2.0</em>
          <a class="citation" href="#ref-LICENSE:APACHE20">[41]</a> veröffentlicht
          <a class="citation" href="#ref-TYPESCRIPT:GITHUB">[42]</a>. Die Architektur von TypeScript wurde maßgeblich
          durch den dänischen Programmierer Anders Hejlsberg entworfen, der bereits unter anderem C# konzipiert hat
          <a class="citation" href="#ref-GITHUB:HEJLSBERG">[43]</a>. Eine formale Spezifikation
          <a class="citation" href="#ref-TYPESCRIPT:SPEC">[2]</a> beschreibt die Grammatik und das Verhalten der
          Sprache. In der Publikation „<em>Understanding TypeScript</em>“
          <a class="citation" href="#ref-BIERMAN:2014">[20]</a> werden darüber hinaus die theoretischen Konzepte und das
          Typsystem von TypeScript dargelegt.
        </p>
        <p>
          Obwohl TypeScript eine unabhängige, vollständige Programmiersprache ist, wurde diese klar mit der Intension
          entwickelt, möglichst zugänglich für JavaScript-Programmierer zu sein. So stellt die Syntax beispielsweise
          eine strikte Obermenge von ECMAScript dar <a class="citation" href="#ref-FLOW:PAPER">[1, S. 25]</a>. Folglich
          ist jedes JavaScript-Programm auch ein syntaktisch korrektes TypeScript-Programm. Der Funktionsumfang von
          TypeScript orientiert sich an der fortlaufenden Weiterentwicklung von ECMAScript
          <a class="citation" href="#ref-BIERMAN:2014">[20, S. 1]</a>. Erweiterungen von JavaScript werden in der Regel
          auch in TypeScript integriert. Somit können JavaScript-Entwickler mit Hilfe von TypeScript eine bereits
          größtenteils bekannte Syntax einsetzen, um Anwendungen statisch zu typisieren.
        </p>
        <p>
          Durch den TypeScript-Compiler (TSC) wird die Übersetzung von TypeScript-Quelltexten in standardkonformes
          JavaScript ermöglicht<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a
          >. Dabei werden alle Spuren der statischen Typisierung entfernt, nachdem die Typkorrektheit verifiziert wurde
          <a class="citation" href="#ref-BIERMAN:2014">[20, S. 3]</a>. Das Laufzeitverhalten des Programms wird also
          nicht durch TypeScript beeinflusst, weil die Typen ausschließlich statisch überprüft werden. Der
          TypeScript-Compiler besitzt eine Vielzahl von Optionen, die unter anderem den Umfang der statischen Analyse,
          die Einbindung von Standardbibliotheken und die Generierung der JavaScript-Ausgabe beeinflussen
          <a class="citation" href="#ref-TSC:OPTIONS">[45]</a>. Insbesondere kann hier auch die Striktheit der
          Typüberprüfungen verschärft werden. Diese sind normalerweise weniger streng als es möglich wäre, um die
          Einführung von TypeScript in bestehende Projekten zu erleichtern. Standardmäßig können beispielsweise die
          Werte <span><code>null</code></span> und <span><code>undefined</code></span> jedem Typ fehlerfrei zugewiesen
          werden <a class="citation" href="#ref-TSC:OPTIONS">[45]</a>. Da dies oftmals nicht das erwünschte Verhalten
          des Typsystems ist, kann eine solche Operation durch Setzen der Option „<code>strictNullChecks</code>“ als
          Typfehler deklariert werden.
        </p>
        <p>
          Wie ausgeführt legen die Autoren von Flow großen Wert auf die Korrektheit des Typsystems. TypeScript verfolgt
          hier bewusst einen anderen Ansatz: Es ist ausdrücklich nicht Ziel, ein beweisbares, absolut korrektes System
          zu entwickeln, sondern es soll eine „Balance zwischen Korrektheit und Produktivität“
          <a class="citation" href="#ref-TYPESCRIPT:DESIGN_GOALS">[46]</a> gefunden werden. Bierman et al. führen aus,
          dass auch ein Typsystem, das nicht vollständig korrekt ist, in der Praxis nützlich sein kann, um
          Programmfehler aufzudecken <a class="citation" href="#ref-BIERMAN:2014">[20, S. 3]</a>. Ein weiterer
          Unterschied zu Flow besteht darin, dass TypeScript sämtliche Typen strukturell behandelt
          <a class="citation" href="#ref-TYPESCRIPT:SPEC">[2, S. 38]</a>. Die Autoren begründen diese Entscheidung
          damit, dass nur eine strukturelle Typisierung der dynamischen Natur von JavaScript gerecht würde. So werden
          zum Beispiel häufig Lambda-Funktionen in JavaScript eingesetzt und Objekte im Allgemeinen nicht durch Klassen,
          sondern bei Bedarf durch Literale erzeugt <a class="citation" href="#ref-BIERMAN:2014">[20, S. 3]</a>. Deren
          Benutzung hängt deshalb nur von ihrem konkreten Aufbau ab, sodass eine strukturelle Betrachtung Sinn ergibt.
        </p>
        <p>
          Ferner unterstützt TypeScript eine graduelle Typisierung (<em>gradual typing</em>), wie sie durch
          <a class="citation" href="#ref-SIEK:2007">47</a>
          <a class="citation" href="#ref-SIEK:2007">[47]</a> beschrieben wurde. Hierdurch ist es möglich, nur bestimmte
          Teilstücke eines Programms zu typisieren, sodass die übrigen Ausdrücke, deren Typ nicht automatisch ermittelt
          werden kann, implizit den dynamischen Typ <em>any</em> erhalten
          <a class="citation" href="#ref-TYPESCRIPT:DESIGN_GOALS">[46]</a>. Wie Flow setzt auch TypeScript Typinferenz
          ein, um Typen automatisch abzuleiten, wodurch sich die Zahl benötigter Typannotationen reduziert
          <a class="citation" href="#ref-BIERMAN:2014">[20, S. 4]</a>.
          <a class="citation" href="#ref-FLOW:PAPER">1</a> weisen darauf hin, dass die Typinferenz von TypeScript aber
          im Gegensatz zu Flow nicht global, sondern nur lokal und an einigen Stellen kontextuell ist
          <a class="citation" href="#ref-FLOW:PAPER">[1, S. 24]</a>. Deshalb seien im Allgemeinen bei TypeScript mehr
          Typannotationen notwendig als bei Flow.
        </p>
        <h4 id="architektur-1">Architektur</h4>
        <figure>
          <embed src="src/2_Grundlagen/fig/ts-architecture.pdf" id="fig:ts-architecture" />
          <figcaption>
            Überblick über die Architektur von TypeScript nach
            <a class="citation" href="#ref-TYPESCRIPT:ARCHITECTURE">[48]</a>.
          </figcaption>
        </figure>
        <p>
          Die Architektur TypeScripts kann in mehrere Teile gegliedert werden: Auf unterster Ebene steht der
          TypeScript-Compiler, der die üblichen Funktionen wie die lexikalische, syntaktische und semantische Analyse
          des Quelltexts sowie die Codegenerierung umsetzt<a
            href="#fn7"
            class="footnote-ref"
            id="fnref7"
            role="doc-noteref"
            ><sup>7</sup></a
          >
          <a class="citation" href="#ref-TYPESCRIPT:ARCHITECTURE">[48]</a>. Auch die Typüberprüfung wird durch den
          Compiler innerhalb der semantischen Analyse durchgeführt. Zwei Softwarekomponenten liegen über dem Compiler
          und greifen auf diesen zu: Einerseits kann die Übersetzung von Quelltexten durch ein Kommandozeilenprogramm
          (<em>Standalone TypeScript Compiler</em>), das die zentrale Benutzerschnittstelle darstellt, angestoßen
          werden, andererseits wird der „Sprachservice“ (<em>Language Service</em>) als Schnittstelle für Editoren
          bereit gestellt. Durch den Sprachservice werden Editoren und integrierten Entwicklungsumgebungen Operationen
          wie Autovervollständigung von Anweisungen, Anzeige von Signaturen oder inferierten Typen, grundlegende
          Refactoring-Funktionen et cetera ermöglicht <a class="citation" href="#ref-TYPESCRIPT:ARCHITECTURE">[48]</a>.
          Auf oberster Ebene steht schließlich der TypeScript-Server (<em>Standalone Server</em>). Dieser legt die
          Funktionen des Sprachservices durch ein JSON-basiertes Kommunikationsprotokoll offen, sodass der Service durch
          andere Anwendungen oder den Benutzer angesprochen werden kann
          <a class="citation" href="#ref-TYPESCRIPT:TSSERVER">[49]</a>.
        </p>
        <h4 id="beispiel-1">Beispiel</h4>
        <p>
          Entsprechend der Veranschaulichung der Benutzung von Flow soll die Typisierung des Algorithmus der linearen
          Suche auch durch TypeScript demonstriert werden, um die Typsysteme voneinander abzugrenzen (Quelltext
          <a href="#code:example-ts" data-reference-type="ref" data-reference="code:example-ts">[code:example-ts]</a>).
          Die Quelltexte ähneln sich stark, da sich der Funktionsumfang und die Syntax der Typannotationen von Flow und
          TypeScript nur in einigen Punkten unterscheidet<a
            href="#fn8"
            class="footnote-ref"
            id="fnref8"
            role="doc-noteref"
            ><sup>8</sup></a
          >.
        </p>
        <pre><code>function linearSearch&lt;T&gt;(list: Array&lt;T&gt;, searchValue: T): number | never {
  for (const [index, value] of list.entries()) {
    if (value === searchValue) {
      return index;
    }
  }
  throw new Error(&#39;Not found&#39;);
}

linearSearch([3, 1, 10, 56], 10);        // 2
linearSearch([3, 1, 10, 56], 12);        // Exception (Not found)
linearSearch([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;], 3);  // Typfehler (3 ist kein String)</code></pre>
        <p>
          Ein syntaktischer Unterschied liegt beispielsweise beim Schlüsselwort für den leeren Typ. Während dieser in
          Flow
          <span><code>empty</code></span> genannt wird, heißt dieser in TypeScript
          <span><code>never</code></span> (Zeile 1). Eine weitere interessante Differenzierung ist das Inferenzverhalten
          des Typsystems bezüglich des Typparameters <span><code>T</code></span
          >. Im Gegensatz zu Flow ist TypeScript im gegebenen Fall in der Lage, den Typ von
          <span><code>T</code></span> bei Aufruf der Funktion <span><code>linearSearch</code></span> in den Zeilen
          10 ff. selbstständig abzuleiten, sodass dessen konkreter Typ nicht explizit in spitzen Klammern angegeben
          werden muss. Auf Grundlage des Typs des ersten Funktionsarguments wird der Typ des zweiten Arguments durch
          TypeScript implizit eingeschränkt. Flow inferiert Typparameter generell nicht, sodass diese dort angegeben
          werden müssen <a class="citation" href="#ref-FLOW:GENERICS">[50]</a>. Die Syntax und Benutzung der
          Typannotationen im Beispiel ist ansonsten analog zu Flow.
        </p>
        <h2 id="sec:transpilers"><span class="chap-number">2.3</span>Transpilierung von Quelltexten</h2>
        <p>
          Um die Problemstellung dieser Arbeit, die Übersetzung von Flow nach TypeScript, praktisch zu lösen, soll ein
          Transpiler umgesetzt werden, welcher die Flow-Typisierung eines Eingabequelltexts in entsprechenden
          TypeScript-Code transformiert. Bevor dessen Implementierung in Kapitel
          <a href="#chap:implementation" data-reference-type="ref" data-reference="chap:implementation">4</a>
          ausführlich dargelegt wird, werden zunächst die grundlegenden Konzepte und der Aufbau von Transcompilern
          betrachtet.
        </p>
        <h3 id="sec:transpiler-concepts"><span class="chap-number">2.3.1</span>Konzepte und Aufbau von Transpilern</h3>
        <p>
          Ein Transpiler oder Transcompiler ist ein spezieller Compiler, der den Quelltext einer höheren
          Programmiersprache in eine andere höhere Programmiersprache übersetzt
          <a class="citation" href="#ref-AHO:COMPILERS">[51, S. 3]</a>. Anders als bei konventionellen Compilern wird
          also kein unmittelbar ausführbarer architekturspezifischer Maschinencode erzeugt, sondern der ursprüngliche
          Quelltext in eine andere Sprache überführt. Auch möglich als Ziel der Transpilierung ist die gleiche
          Programmiersprache, wenn beispielsweise das Eingabeprogramm entsprechend eines neueren oder älteren
          Sprachstandards umgeformt werden soll <a class="citation" href="#ref-EVGENIY:2016">[23]</a>. Abbildung
          <a href="#fig:transpiler-architecture" data-reference-type="ref" data-reference="fig:transpiler-architecture"
            >2.2</a
          >
          zeigt den typischen Aufbau eines Transcompilers. Die Architektur lässt sich wie bei Compilern in zwei Phasen
          mit mehreren Unterpunkten gliedern: Während die Eingabe im <em>Frontend</em> syntaktisch und semantisch
          analysiert wird, wird das Programm im <em>Backend</em> optimiert und der Ausgabequelltext generiert
          <a class="citation" href="#ref-APPEL:2003">[52, S. 136]</a>.
        </p>
        <figure>
          <embed src="src/2_Grundlagen/fig/transpiler-architecture.pdf" id="fig:transpiler-architecture" />
          <figcaption>
            Architektur eines typischen Transpilers nach
            <a class="citation" href="#ref-EVGENIY:2016">[23]</a> und
            <a class="citation" href="#ref-TORCZON:2007">[53, S. 8]</a>.
          </figcaption>
        </figure>
        <p>
          Zunächst wird der Eingabequelltext innerhalb der Analysephase durch den Lexer oder Tokenizer Zeichen für
          Zeichen eingelesen, um diesen in lexikalisch bedeutungsvolle Zeichenketten, sogenannte <em>Lexeme</em>, zu
          zerlegen <a class="citation" href="#ref-AHO:COMPILERS">[51, S. 43]</a>. Daraufhin werden
          <em>Tokens</em> gebildet, indem jedes dieser Wörter einer syntaktischen Klasse zugeordnet wird. Diese geben
          die Bedeutung eines Tokens an (zum Beispiel <span><code>3</code></span> <span class="math inline">↦</span>
          <span><code>INT(3)</code></span> oder <span><code>!=</code></span> <span class="math inline">↦</span>
          <span><code>NEQ</code></span
          >) <a class="citation" href="#ref-TORCZON:2007">[53, S. 26]</a>. Die Tokens entsprechen dabei den
          Terminalsymbolen der formalen Grammatik der Programmiersprache
          <a class="citation" href="#ref-AHO:COMPILERS">[51, S. 43]</a>.
        </p>
        <pre><code>function square(x) {
  return x ** 2;
}</code></pre>
        <!-- TODO -->
        <p>
          ] [Identifier<span>[]</span>, edge label=<span>node[edge]<span>params</span></span> [x, edge label=<span
            >node[edge]<span>name</span></span
          >] ] [BlockStatement, for tree = <span>s sep=1.3cm</span>, edge label=<span>node[edge]<span>body</span></span>
          [ReturnStatement, edge label=<span>node[edge]<span>body</span></span> [BinaryExpression, edge label=<span
            >node[edge]<span>argument</span></span
          >
          [Identifier, edge label=<span>node[edge]<span>left</span></span> [x, tier=last, edge label=<span
            >node[edge]<span>name</span></span
          >] ] [**, tier=last, edge label=<span>node[edge]<span>operator</span></span
          >] [Literal, edge label=<span>node[edge]<span>right</span></span> [2, tier=last, edge label=<span
            >node[edge]<span>value</span></span
          >] ] ] ] ] ]
        </p>
        <p>
          Im zweiten Schritt, der syntaktischen Analyse oder dem <em>Parsen</em>, wird anschließend überprüft, ob die
          Tokenfolge eine Ableitung der kontextfreien Grammatik der Quellsprache darstellen, indem versucht wird, einen
          entsprechenden <em>konkreten</em> Syntaxbaum aufzubauen
          <a class="citation" href="#ref-SCHOEPP:COMPILER">[54]</a>. Ein Syntax- oder Ableitungsbaum ist ein Graph, der
          die syntaktische Struktur eines Programms gemäß der zugehörigen Grammatik hierarchisch modelliert. Abbildung
          <a href="#fig:ast" data-reference-type="ref" data-reference="fig:ast">[fig:ast]</a> zeigt exemplarisch den
          <em>abstrakten</em> Syntaxbaum (AST) einer simplen JavaScript-Funktion. Ein abstrakter Syntaxbaum ist eine
          kompaktere Form des konkreten Baums und zeigt lediglich „wesentliche Teile“
          <a class="citation" href="#ref-WALDMANN:PPS">[15, S. 21]</a> davon. Falls der Ableitungsbaum nicht erstellt
          werden kann, so liegt ein Syntaxfehler in der Eingabe vor.
        </p>
        <p>
          Danach prüft der Transpiler, ob ein gültiges Programm der Eingabesprache vorliegt, indem die statische
          Semantik analysiert wird <a class="citation" href="#ref-AHO:COMPILERS">[51, S. 8]</a>. Hierunter fällt
          beispielsweise, dass Variablen in vielen Programmiersprachen vor deren Benutzung zunächst deklariert werden
          müssen. Um ein solches kontextuelles Programmverhalten zu untersuchen, können Attributgrammatiken verwendet
          werden <a class="citation" href="#ref-TORCZON:2007">[53, S. 161]</a>. Während dieser Phase wird auch die
          Typkorrektheit überprüft, sofern ein statisches Typsystem vorliegt
          <a class="citation" href="#ref-SCHOEPP:COMPILER">[54]</a>. Es ist hervorzuheben, dass nicht alle Transcompiler
          eine semantische Analyse durchführen, sondern manche unmittelbar zum nächsten Schritt übergehen. Folglich
          werden hier semantische Programmfehler nicht erkannt und einfach übernommen. Zuletzt wird durch das Frontend
          ein <em>Zwischencode</em
          ><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> des Programms erzeugt,
          der an das Backend übergeben wird. Ein Zwischencode ist im Allgemeinen eine von der Quellsprache und
          Zielarchitektur unabhängige Datenstruktur innerhalb von Compilern, die das betrachtete Programm modelliert
          <a class="citation" href="#ref-TORCZON:2007">[53, S. 6]</a>. Wie Abschnitt
          <a href="#sec:js-transpilers" data-reference-type="ref" data-reference="sec:js-transpilers">2.3.2</a> zeigen
          wird, verwenden viele Transpiler im JavaScript-Umfeld den abstrakten Syntaxbaum als Zwischencode.
        </p>
        <p>
          Der erste Schritt der darauffolgenden Synthesephase besteht darin, den Zwischencode gegebenenfalls zu
          transformieren, um gewünschte Programmeigenschaften herzustellen. Zum Beispiel könnte hier veraltete Syntax
          durch modernere Notationen ersetzt werden. Als nächstes wird das Programm sprachunabhängig optimiert, das
          heißt, die Laufzeit oder der Speicherplatzbedarf werden auf Basis einer Programmanalyse reduziert
          <a class="citation" href="#ref-TORCZON:2007">[53, S. 405]</a>. Hierbei können eine Vielzahl unterschiedlicher
          Transformationen angewandt werden. Möglich ist zum Beispiel die Entfernung nicht erreichbarer Programmstücke
          (<em>dead code elimination</em>) oder die Inline-Ersetzung von Konstanten und Schleifen
          <a class="citation" href="#ref-TORCZON:2007">[53]</a>,
          <a class="citation" href="#ref-SCHOEPP:COMPILER">[54]</a>. Auch hier gilt es zu betonen, dass nicht alle
          Transcompiler eine derartige Optimierungsphase besitzen.
        </p>
        <p>
          Schließlich kann im letzten Schritt der endgültige Quelltext in der Zielsprache durch den modifizierten
          Zwischencode generiert werden <a class="citation" href="#ref-AHO:COMPILERS">[51, S. 505]</a>. Die erzeugte
          Ausgabe kann dabei dem ursprünglichen Programm ähneln oder völlig andersartig aufgebaut sein, wenn
          beispielsweise die Namen aller Bezeichner im Quelltext gekürzt wurden, um ein kleineres Programm zu erzeugen
          (<em>minification</em>) <a class="citation" href="#ref-FOWLER:TRANSPARENT">[55]</a>.
        </p>
        <h3 id="sec:js-transpilers">
          <span class="chap-number">2.3.2</span>Evaluation bestehender Werkzeuge zur Quelltexttransformation
        </h3>
        <p>
          Im Umfeld von JavaScript sind im Lauf der Jahre eine Vielzahl von Parsern, Codegeneratoren und Transpilern
          entstanden, welche die Entwicklung weiterer Software wie die des angestrebten Flow-Transcompilers stark
          vereinfachen können. Weil diese Werkzeuge bereits einen Großteil der benötigten Standardfunktionalität wie das
          Einlesen und Generieren von Code bereitstellen, muss oftmals nur der Kern des Übersetzers, also im
          vorliegenden Fall die Transformation der Flow-Typen nach TypeScript, implementiert werden. Im Folgenden sollen
          einige der relevantesten aktuellen Werkzeuge bezüglich verschiedener Aspekte gegenüber gestellt werden, sodass
          daraufhin die Entscheidung getroffen werden kann, welcher der Ansätze als Grundlage für die Umsetzung des
          Transpilers herangezogen wird. Dabei wird nur frei verfügbare, quelloffene Software betrachtet.
        </p>
        <p>
          Die Auswahl des Werkzeugs hängt entscheidend von der Erfüllung mehrerer technischer Anforderungen ab, die auf
          Basis der gegebenen Rahmenbedingungen innerhalb des Unternehmens Spreadshirt erarbeitet wurden und in Kapitel
          <a href="#chap:analysis" data-reference-type="ref" data-reference="chap:analysis">3</a> ausführlich dargelegt
          werden. Die erste Vorgabe ist die vollumfängliche Unterstützung aktueller JavaScript-Syntax gemäß der
          ECMAScript-Spezifikation 2019 <a class="citation" href="#ref-ECMASCRIPT:2019">[17]</a>. Weiterhin muss die
          Verarbeitung von <em>vorläufiger</em> Syntax durch den Transpiler möglich sein. Darunter werden in dieser
          Arbeit Erweiterungen von JavaScript verstanden, die noch nicht endgültiger Bestandteil des
          ECMAScript-Standards sind. Dieser wird kontinuierlich durch das <em>Technical Committee 39</em> (TC39)
          <a class="citation" href="#ref-TC39_COMMITTEE">[56]</a> weiterentwickelt. Vorgeschlagene Spracherweiterungen
          durchlaufen dabei einen mehrstufigen Standardisierungsprozess, der letztlich in die Aufnahme in die
          Spezifikation münden kann <a class="citation" href="#ref-TC39_PROCESS">[57]</a>. Derartige Syntax einlesen zu
          können, ist ebenfalls eine Anforderung, weil diese zum Teil bereits heute in den gegebenen Projekte von
          Spreadshirt eingesetzt werden<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"
            ><sup>10</sup></a
          >. Damit die Übersetzung der Flow-Typen nach TypeScript möglich ist, muss ferner sowohl die Syntax von Flow
          als auch von TypeScript vollständig unterstützt werden. Darüber hinaus muss sogenannte JSX-Syntax
          <a class="citation" href="#ref-SOFTWARE:JSX">[58]</a> (<em>JavaScript XML</em>) eingelesen werden können, weil
          die zu migrierenden Projekte auch diese Notation einsetzen. Die letzte Anforderung ist schließlich, dass auf
          Grundlage des transformierten Programms entsprechender TypeScript-Code generiert werden kann.
        </p>
        <p>TODO: tools.tex</p>
        <p>
          Die Eigenschaften der in Betracht kommenden Werkzeuge werden in Tabelle
          <a href="#tab:transpilers" data-reference-type="ref" data-reference="tab:transpilers">[tab:transpilers]</a>
          aufgelistet. Dabei werden verschiedene Parser (<em>Acorn</em>, <em>Esprima</em>), Codegeneratoren
          (<em>Astring</em>, <em>Escodegen</em>) und ganze Transpiler (<em>Babel</em>, <em>Recast</em>) für JavaScript
          betrachtet. Jedes der Werkzeuge benutzt intern den abstrakten Syntaxbaum der Eingabe als Zwischencode. Da
          außer Babel alle Alternativen die Spezifikation <em>ESTree</em> für den Aufbau des abstrakten Syntaxbaums
          verwenden, können diese Parser und Codegeneratoren prinzipiell beliebig kombiniert werden, um einen
          Transcompiler zusammenzusetzen. Der ESTree-Standard wird von Mitgliedern verschiedener Projekte im Umfeld der
          statischen Analyse von JavaScript stetig weiterentwickelt und spezifiziert den Aufbau abstrakter Syntaxbäume
          von ECMAScript-Programmen <a class="citation" href="#ref-ESTREE_SPEC">[59]</a>. Weil aber weder Astring noch
          Escodegen TypeScript als Ausgabesprache unterstützen, kann dieser Ansatz nicht verfolgt werden, um die
          gegebene Problemstellung zu lösen.
        </p>
        <p>
          Nach Kenntnisstand des Autors existieren außer Babel und Recast keine weiteren Werkzeuge, die einen
          Codegenerator bereitstellen, der TypeScript auf Grundlage von JavaScript-Syntaxbäumen erzeugen kann. Auch sind
          diese Projekte die einzigen der betrachteten, die aktuelle und vorläufige JavaScript-Syntax sowie Flow,
          TypeScript und JSX vollständig verarbeiten können. Jedoch wird dies in Recast nur bei Verwendung des Parsers
          von Babel
          <a class="citation" href="#ref-BABEL:PARSER">[60]</a> erzielt. Recast setzt standardmäßig Esprima als Parser
          ein, aber es können auch andere Parser wie Babel verwendet werden, um nicht standardkonforme
          Syntaxerweiterungen von JavaScript einzulesen. Ein interessantes Merkmal von Recast ist, dass hier die
          Formatierung des ursprünglichen Quelltexts konsistent beibehalten wird, indem die abstrakten Syntaxbäume der
          Ein- und Ausgabe verglichen werden, sodass daraufhin nur der Code der geänderten Teilbäume neu generiert wird
          <a class="citation" href="#ref-RECAST">[61]</a>. Dieser Ansatz wirkt zunächst aussichtsreich, weil so
          vermeintlich die originalgetreue Formatierung der TypeScript-Ausgabe erreicht werden kann. Jedoch hat sich
          experimentell gezeigt, dass der Programmierstil der modifizierten und damit neu erstellten Programmteile,
          anders als von Recast behauptet, zum Teil doch vom ursprünglichen Code abweicht. Die Formatierung
          unveränderter Abschnitte wird aber tatsächlich präzise beibehalten. Auch wurde festgestellt, dass Kommentare
          innerhalb der modifizierten Ausdrücke komplett verloren gehen, was für die Erzielung einer korrekten
          Übersetzung inakzeptabel ist.
        </p>
        <p>
          Wie die Tabelle zeigt, ist Babel zudem im Vergleich zu Recast deutlich verbreiteter und wird aktiver
          entwickelt. Deshalb kann Babel als die ausgereiftere Software betrachtet werden. Weiterhin bietet Babel eine
          gute Erweiterbarkeit durch ein Plugin-System
          <a class="citation" href="#ref-BABEL:HANDBOOK">[62]</a> und besitzt eine umfangreiche Dokumentation
          <a class="citation" href="#ref-BABEL:DOCS">[63]</a>. Aufgrund dieser Vorteile und Alleinstellungsmerkmale wird
          Babel als Grundlage für die Implementierung gewählt.
        </p>
        <h3 id="sec:babel"><span class="chap-number">2.3.3</span>Babel</h3>
        <h4 id="funktionsweise">Funktionsweise</h4>
        <p>
          Zur Erleichterung des Verständnisses der Ausführung des umgesetzten Flow-Transpilers in Kapitel
          <a href="#chap:implementation" data-reference-type="ref" data-reference="chap:implementation">4</a> soll
          zunächst die grundsätzliche Funktionsweise von Babel umrissen werden. Die Ausführung von Babel gliedert sich
          in folgende drei Phasen <a class="citation" href="#ref-BABEL:HANDBOOK">[62]</a>. Diese sind in weiten Teilen
          analog zu dem beschriebenen Aufbau eines typischen Transcompilers.
        </p>
        <ol>
          <li>
            <p>
              Zunächst wird der Eingabequelltext in zwei Schritten eingelesen, um den abstrakten Syntaxbaum des
              Programms zu erzeugen: Als Erstes wird der Code während der lexikalischen Analyse mittels des Lexers in
              Tokens zerlegt. Anschließend werden diese in der syntaktischen Analyse zu einer Datenstruktur umgeformt,
              die den zugehörigen abstrakten Syntaxbaum repräsentiert. Jedem Knoten des Baums wird dabei ein eindeutiger
              Tokentyp zugewiesen, der dessen syntaktische Bedeutung widerspiegelt.
            </p>
          </li>
          <li>
            <p>
              Während der zweiten Phase wird daraufhin die Kernfunktionalität von Babel, die Programmtransformation
              umgesetzt: Dabei wird der abstrakte Syntaxbaum durch das <em>Besucher</em>-Entwurfsmuster<a
                href="#fn11"
                class="footnote-ref"
                id="fnref11"
                role="doc-noteref"
                ><sup>11</sup></a
              >
              rekursiv traversiert und die Knoten des Baums sukzessive modifiziert, gelöscht bzw. neu erstellte Elemente
              eingefügt. Das Entwurfsmuster beschreibt, wie ein Algorithmus auf einer komplexen Objektdatenstruktur,
              unabhängig von der konkreten Implementierung der zugrunde liegenden Klassen, ausgeführt werden kann
              <a class="citation" href="#ref-FREEMAN:2004">[65, S. 634]</a>. Im vorliegenden Fall ermöglicht die
              Anwendung die individuelle Adressierung einer bestimmten Untermenge der Knoten des Syntaxbaums, sodass
              dort die gewünschte Transformation des Programms durchgeführt werden kann.
            </p>
          </li>
          <li>
            <p>
              Schließlich kann der Ausgabecode generiert werden: Hierbei werden alle Knoten des abstrakten Syntaxbaums
              durch Anwendung einer Tiefensuche durchlaufen und eine Zeichenkette aufgebaut, die den endgültigen,
              modifizierten Quelltext darstellt.
            </p>
          </li>
        </ol>
        <p>
          Während der Ausführung der Implementierung des Transpilers in Abschnitt
          <a href="#sec:implementation" data-reference-type="ref" data-reference="sec:implementation">4.3</a> wird
          hauptsächlich die zweite Phase betrachtet, da hier die vorliegende Problemstellung, die Transformation der
          Flow-Typannotationen nach TypeScript, umgesetzt wird. Das Parsen des Eingabequelltexts und das Generieren der
          Ausgabe kann durch Verwendung der gegebenen Bibliotheksfunktionen von Babel simpel realisiert werden und
          bedarf keiner genaueren Untersuchung.
        </p>
        <h4 id="sec:babel-plugins">Babel-Plugins</h4>
        <p>
          Da die entscheidende Phase der Transpilierung, die Programmtransformation, bei Babel durch Plugins erzielt
          wird, sollen diese genauer betrachtet werden. Plugins sind die elementaren Bausteine, die eine flexible
          Erweiterung von Babel ermöglichen. Selbst der Kern des Transcompilers ist aus einer Vielzahl von
          Standard-Plugins zusammengesetzt, die in ihrer Gesamtheit die Funktionalität des Systems abbilden
          <a class="citation" href="#ref-BABEL">[3]</a>. Dies verdeutlicht die tiefgreifende Modularität der Architektur
          von Babel.
        </p>
        <p>
          Ein Babel-Plugin ist eine JavaScript-Funktion, welche gemäß der vorgegebenen Schnittstellen ein Objekt mit
          verschiedenen Attributen zurückliefern muss. Mindestens anzugeben ist dabei lediglich die Abbildung der
          gewünschten Knotentypen des abstrakten Syntaxbaums auf Besucherfunktionen
          <a class="citation" href="#ref-BABEL:HANDBOOK">[62]</a>. Deren Implementierung setzt die angestrebte
          Quelltexttransformation um. Es ist in der Praxis gängig, mehrere Plugins einzusetzen, sodass ein Knoten
          während der Verarbeitung durch Babel eine Reihe unabhängiger Transformationen durchlaufen kann. Hierdurch kann
          die erwünschte Transpilierung von JavaScript-Quelltexten flexibel durch Kombination vieler kleiner Bausteine
          realisiert werden. Auch möglich ist die Angabe einer hierarchischen Abhängigkeitsstruktur, sodass die
          Verwendung eines Plugins zur impliziten Aktivierung weiterer Plugins führt
          <a class="citation" href="#ref-BABEL:HANDBOOK">[62]</a>.
        </p>
        <pre><code>// var foo =&gt; var FOO
module.exports = function() {
  return {
    visitor: {
      Identifier(path) {
        path.node.name = path.node.name.toUpperCase();
      }
    }
  };
};</code></pre>
        <p>
          Der konkrete Aufbau von Babel-Plugins soll durch ein Minimalbeispiel gezeigt werden. Quelltext
          <a
            href="#code:babel-plugin-definition"
            data-reference-type="ref"
            data-reference="code:babel-plugin-definition"
            >[code:babel-plugin-definition]</a
          >
          zeigt den Code eines simplen, aber vollständigen Plugins, welches lediglich den Namen aller Bezeichner (<span
            ><code>Identifier</code></span
          >) eines JavaScript-Programms in Großbuchstaben setzt. Hierfür wird eine gleichnamige Besucherfunktion für den
          Knotentyp <span><code>Identifier</code></span> definiert (Zeile 5). Diese erhält den <em>Pfad</em> der so
          adressierten Identifier-Knoten als Argument und kann diesen wie gewünscht transformieren. Der Pfad eines
          AST-Knotens ist ein Objekt, das die Beziehung des Knotens zu seinen Elternelementen modelliert und diesen um
          Metainformationen anreichert <a class="citation" href="#ref-BABEL:HANDBOOK">[62]</a>. Es enthält eine Vielzahl
          von Methoden, mittels derer der Pfad und der Syntaxbaum als Ganzes manipuliert werden kann.
        </p>
        <p>
          Alle Knotentypen des abstrakten Syntaxbaums von Babel werden einerseits in der Spezifikation des Parsers
          <a class="citation" href="#ref-BABEL:PARSER_SPEC">[60]</a>,
          <a class="citation" href="#ref-BABEL:PARSER">[66]</a>, andererseits in der Dokumentation der Bibliothek
          <span><code>@babel/types</code></span> <a class="citation" href="#ref-BABEL:TYPES">[67]</a> beschrieben. Der
          Aufbau des von Babel eingesetzten abstrakten Syntaxbaums liegt in einem eigenen Format vor, das auf dem
          ESTree-Standard <a class="citation" href="#ref-ESTREE_SPEC">[59]</a> basiert. Mit der sechsten Version von
          Babel wurde entschieden, von der ESTree-Spezifikation abzuweichen, damit auch vorläufige
          JavaScript-Erweiterungen unterstützen werden können
          <a class="citation" href="#ref-BABEL:STATE_OF_BABEL">[68]</a>.
        </p>
      </section>
      <section>
        <h1 id="chap:analysis"><span class="chap-number">3</span>Ziel- und Anforderungsanalyse</h1>
        <p>
          Nachdem die Grundlagen der Thematik erörtert wurden, werden nachfolgend die Ziele der Migration von Flow nach
          TypeScript innerhalb des Unternehmens Spreadshirt und die Anforderung an die Implementierung des Transpilers
          definiert. Zunächst soll jedoch die Ausgangslage zu Beginn dieser Arbeit beschrieben werden, um die
          Rahmenbedingungen zu verdeutlichen.
        </p>
        <h2 id="sec:status-quo"><span class="chap-number">3.1</span>Ausgangslage und Rahmenbedingungen</h2>
        <h3 id="sec:teamshirts-projects">
          <span class="chap-number">3.1.1</span>Kurzvorstellung der Projekte von TeamShirts
        </h3>
        <p>
          Das Leipziger Unternehmen <em>sprd.net AG</em> (<em>Spreadshirt</em>) ist ein seit 2002 bestehender Anbieter
          verschiedener eCommerce-Plattformen, welche die individuelle On-Demand-Bedruckung von Kleidung und Accessoires
          ermöglichen <a class="citation" href="#ref-SPREADSHIRT:ABOUT">[69]</a>. Die Produkte können dabei von den
          Kunden online durch vorgegebene oder eigene Motive gestaltet und anschließend bestellt werden. Um weitere
          Zielgruppen wie Sportmannschaften, Vereine, Belegschaften usw. besser anzusprechen, wurde 2014 der
          Geschäftsbereich <em>TeamShirts</em> gegründet <a class="citation" href="#ref-TEAMSHIRTS:ABOUT">[70]</a>, in
          dessen Kontext diese Arbeit entstanden ist. TeamShirts betreibt verschiedene Webanwendungen, deren Frontend
          vorrangig auf JavaScript basiert. Innerhalb des Unternehmens gibt es strategische Überlegungen, die
          bestehenden Projekte nach TypeScript zu migrieren, um die derzeitige Typisierung mit Flow so zu ersetzen. Die
          Gründe hierfür werden in Abschnitt
          <a href="#sec:goals" data-reference-type="ref" data-reference="sec:goals">3.2</a> ausführlich dargelegt. Der
          Wechsel zu TypeScript wurde durch den in dieser Arbeit entworfenen und realisierten Transpiler für zwei dieser
          Projekte umgesetzt. Um die Nachvollziehbarkeit der weiteren Ausführungen zu erleichtern, sollen diese kurz
          vorgestellt werden.
        </p>
        <h4 id="components">Components</h4>
        <p>
          Alle Frontend-Projekte von TeamShirts bauen auf der Softwarebibliothek <em>React</em>
          <a class="citation" href="#ref-SOFTWARE:REACT">[71]</a> auf, welche die Programmierung von Benutzeroberflächen
          auf Basis von sogenannten <em>Komponenten</em
          ><a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> ermöglicht
          <a class="citation" href="#ref-ACM:REACT">[74]</a>. Diese stellen wiederverwendbare, voneinander unabhängige
          Elemente dar, die aus HTML, CSS und JavaScript aufgebaut sind und durch Komposition zu komplexeren Strukturen
          zusammengesetzt werden können. Das erste Projekt von TeamShirts <em>Components</em> stellt eine Bibliothek
          derartiger React-Komponenten dar, die abteilungsintern in verschiedenen anderen Softwaremodulen eingesetzt
          wird.
        </p>
        <h4 id="helios">Helios</h4>
        <p>
          <em>Helios</em> ist ein Service für <em>Server-Side Rendering</em> (SSR). Unter
          <em>Server-Side Rendering</em> versteht man die Generierung des gesamten Quelltexts einer Webseite durch einen
          Server. Dies ist insbesondere für Webanwendungen interessant, deren Aufbau normalerweise clientseitig mittels
          JavaScript realisiert wird, da sich auf diese Weise verschiedene Performance-Vorteile ergeben. So wird
          beispielsweise eine schnellere Interaktivität<a
            href="#fn13"
            class="footnote-ref"
            id="fnref13"
            role="doc-noteref"
            ><sup>13</sup></a
          >
          der Seite erreicht, da durch SSR weniger Berechnungen im Webbrowser nötig sind
          <a class="citation" href="#ref-GOOGLE:RENDERING_ON_THE_WEB">[75]</a>. TeamShirts verwendet Helios, um Seiten,
          die durch verschiedene React-Komponenten aufgebaut sind, serverseitig zu erstellen und auszuliefern.
        </p>
        <h3 id="sec:evaluation-other-transpilers">
          <span class="chap-number">3.1.2</span>Evaluation bestehender Ansätze zur Transpilierung von Flow
        </h3>
        <p>
          Vor Beginn der Arbeit wurde evaluiert, ob bereits Lösungsansätze für die gegebene Problemstellung, die
          Transpilierung von Flow-Typen nach TypeScript, bestehen. Tatsächlich existierten zum damaligen Zeitpunkt im
          Februar 2019 zwei Projekte auf der Software-Plattform GitHub, welche das gleiche Ziel wie diese Arbeit
          verfolgen: Bereits im November 2017 begann der Programmierer Boris Cherny mit der Entwicklung eines
          Babel-Plugins zur Transpilierung von Flow <a class="citation" href="#ref-CHERNY:FLOW_TO_TS">[76]</a>.
          Weiterhin ist im April 2018 ein vergleichbares Projekt durch Yuichiro Kikura entstanden
          <a class="citation" href="#ref-KIKURA:FLOW_TO_TS">[77]</a>. Nach näherer Betrachtung und Erprobung der zwei
          Plugins wurde jedoch rasch festgestellt, dass sich beide Werkzeuge noch in einem frühen Stadium befinden und
          deren Funktionsumfang unvollständig ist. Da die Weiterentwicklung der Plugins darüber hinaus nur sporadisch
          vorangetrieben wurde, wurde angenommen, dass die Projekte inaktiv sind. Eine korrekte, ganzheitliche
          Übersetzung der vorliegenden JavaScript-Quelltexte von TeamShirts war somit nicht umsetzbar. Folglich wurde
          beschlossen, selbst einen Transpiler für Flow zu entwickeln, der allen in Abschnitt
          <a href="#sec:requirements" data-reference-type="ref" data-reference="sec:requirements">3.3</a> ausgeführten
          Anforderungen gerecht wird.
        </p>
        <p>
          Einige Monate später im Sommer 2019 ist die Arbeit von Yuichiro Kikura an dessen Plugin wieder aufgenommen
          worden und es ist ein drittes Projekt von Kevin Barabash, Mitarbeiter der eLearning-Plattform
          <em>Khan Academy</em> <a class="citation" href="#ref-KHAN_ACADEMY">[78]</a>, hinzu gekommen
          <a class="citation" href="#ref-BARABASH:FLOW_TO_TS">[79]</a>. Das etwa zeitgleiche Aufkommen mehrerer Projekte
          mit der gleichen Zielsetzung wie diese Arbeit kann als Beleg dafür betrachtet werden, dass ein großer Bedarf
          zu existieren scheint die vorliegende Problemstellung zu lösen. Der in dieser Arbeit umgesetzte Transpiler
          wird in Kapitel
          <a href="#chap:evaluation" data-reference-type="ref" data-reference="chap:evaluation">5</a> den
          konkurrierenden Ansätzen bezüglich verschiedener Aspekte gegenüber gestellt, sodass die erreichten Ergebnisse
          durch den Vergleich besser eingeordnet werden können.
        </p>
        <h2 id="sec:goals"><span class="chap-number">3.2</span>Ziele der Migration zu TypeScript</h2>
        <p>
          In Zusammenarbeit mit den Softwareentwicklern bei TeamShirts wurden die folgenden vier Ziele der Migration von
          Flow nach TypeScript definiert. Diese und die im darauffolgenden Abschnitt dargelegten Anforderungen an den
          Transpiler bilden die Grundlage für die kritische Bewertung der Ergebnisse in Kapitel
          <a href="#chap:evaluation" data-reference-type="ref" data-reference="chap:evaluation">5</a>.
        </p>
        <h3 id="erkennung-weiterer-typ--und-programmfehler">
          <span class="chap-number">3.2.1</span>Erkennung weiterer Typ- und Programmfehler
        </h3>
        <p>
          Die Hauptmotivation für den Wechsel des Typsystems bei TeamShirts ist die Erkennung weiterer Typ- und
          Programmfehler im bestehenden und zukünftigen Code der Frontend-Projekte. Es wird angenommen, dass TypeScript
          hier, insbesondere auch durch die im nächsten Abschnitt beschriebene Unterstützung externer Bibliotheken, Flow
          überlegen ist und damit langfristig mehr Typfehler aufgedeckt werden können.
        </p>
        <p>
          Im Umfeld einer eCommerce-Plattform sind JavaScript-Laufzeitfehler in der Produktivumgebung fatal, da diese
          zum Beispiel im vorliegenden Fall bei TeamShirts Bestellabschlüsse verhindern können und dies zu
          Umsatzeinbußen führt. Folglich besteht ein starkes Interesse des Unternehmens, die Qualität und Robustheit der
          betriebenen Software weiter zu steigern, indem bestehende Mängel behoben und zukünftige Programmfehler
          vermieden werden. Es gilt daher in der Auswertung zu zeigen, dass TypeScript in der Lage ist, tatsächliche
          Programmfehler im bestehenden Quelltext durch Typverletzungen aufzudecken.
        </p>
        <h3 id="unterstützung-externer-bibliotheken">
          <span class="chap-number">3.2.2</span>Unterstützung externer Bibliotheken
        </h3>
        <p>
          Da alle Projekte von TeamShirts auf einer Vielzahl externer Softwarebibliotheken wie React
          <a class="citation" href="#ref-SOFTWARE:REACT">[71]</a> et cetera aufbauen, ist die umfassende Unterstützung
          dieser durch das Typsystem eine wichtige Zielvorgabe. Sowohl Flow als auch TypeScript ermöglichen es, den
          Funktionsumfang und die Struktur von Bibliotheken durch Typdeklarationen in Definitionsdateien zu
          beschreiben<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a
          >. Hierdurch können Module, die selbst keine Typdeklarationen mitliefern, nachträglich um eine Typisierung in
          Flow oder TypeScript erweitert werden, sodass die Vorteile statischer Typsysteme auch hier genutzt werden
          können. Das Risiko, dass Bibliotheken inkorrekt verwendet werden, kann so erheblich reduziert werden, weil zum
          Beispiel fehlerhafte Funktionsaufrufe durch das Typsystem unmittelbar erkannt werden.
        </p>
        <p>
          Da es aufwändig und fehleranfällig ist selbst korrekte Typdeklarationen für fremde Bibliotheken anzufertigen,
          ist es für deren tiefgreifende Unterstützung durch das Typsystem ausschlaggebend, dass bereits qualitativ
          hochwertige Typisierungen extern vorliegen. Dies bedeutet, dass die Definitionen möglichst vollständig und
          aktuell hinsichtlich der Softwareversion des Pakets sind. Einige Bibliotheken stellen selbst
          Deklarationsdateien bereit, für andere existieren separate Typisierungen, die durch die Entwicklergemeinschaft
          fortlaufend aktualisiert werden. Es besteht die Vermutung, dass bei TypeScript im Vergleich zu Flow
          Typdeklarationen für eine insgesamt größere Zahl von Bibliotheken bestehen und diese in mindestens
          gleichwertiger Qualität vorliegen. Falls sich diese These als tatsächlich haltbar erweist, ist das Ziel
          erreicht.
        </p>
        <h3 id="performance-der-typüberprüfungen">
          <span class="chap-number">3.2.3</span>Performance der Typüberprüfungen
        </h3>
        <p>
          Ein weiterer Aspekt, der durch die Migration zu TypeScript verbessert werden soll, ist die Performance, das
          heißt, die Schnelligkeit der Typüberprüfungen. Üblicherweise wird der Flow- bzw. TypeScript-Sprachserver, der
          das gesamte Projekt und insbesondere offene Dateien im Hintergrund kontinuierlich auf Typverletzungen
          überprüft, durch den Editor oder die integrierte Entwicklungsumgebung gestartet. Es ist entscheidend, dass die
          Ergebnisse dieser Berechnung der Typkorrektheit möglichst schnell vorliegen, damit etwaige Fehler unmittelbar
          im Editor angezeigt werden können. Falls diese stark verzögert erst nach einigen Sekunden ausgegeben werden,
          so verlangsamt dies den Workflow des Programmierers und beeinträchtigt dessen effizientes Arbeiten. Neben
          diesen inkrementellen Überprüfungen ist auch die Laufzeit der vollständige Berechnung der Typkorrektheit
          bedeutsam, da derartige Tests beispielsweise im Zuge der kontinuierlichen Softwareintegration ausgeführt
          werden. Ein weiteres Erfolgskriterium des Wechsels zu TypeScript ist damit die Erzielung einer mindestens
          gleichwertigen Performance der Typüberprüfungen.
        </p>
        <h3 id="sec:goal:transparency">
          <span class="chap-number">3.2.4</span>Zukunftssicherheit und Transparenz der Technologie
        </h3>
        <p>
          Zuletzt ist einerseits die Zukunftssicherheit, andererseits die Transparenz der eingesetzten Technologie von
          Bedeutung. Hierunter werden innerhalb dieser Arbeit verschiedene Fragestellungen verstanden: Existiert ein
          öffentlich einsehbarer Projektplan (<em>Roadmap</em>) für die Weiterentwicklung des Systems? Wie gesichert ist
          die langfristige Unterstützung des Projekts durch die ursprünglichen Autoren<a
            href="#fn15"
            class="footnote-ref"
            id="fnref15"
            role="doc-noteref"
            ><sup>15</sup></a
          >
          der Technologie? Werden strategische Entscheidungen öffentlich kommuniziert? Wird die Software quelloffen oder
          proprietär entwickelt? Werden gemeldete Programmfehler innerhalb einer angemessenen Zeitspanne behoben?
        </p>
        <p>
          All diesen Fragen gemein ist das Bedürfnis der Benutzer nach Stabilität, Transparenz und Verlässlichkeit der
          eingesetzten Technologie. Das Entwicklerteam von TeamShirts hat den Eindruck gewonnen, dass die Entwicklung
          von Flow oftmals intransparent voran getrieben wird, sodass eine gewisse Verunsicherung bezüglich der Zukunft
          der Technologie besteht. Die Autoren von Flow räumen im 2019 veröffentlichten Artikel “”
          <a class="citation" href="#ref-FLOW:UPDATE_2019">[80]</a> selbst ein, dass die Kommunikation der Pläne für
          Flow zuletzt ungenügend war. Weil die Softwareprojekte bei TeamShirts für gewöhnlich über mehrere Jahre hinweg
          erweitert und gewartet werden, ist die Beständigkeit und die kontinuierliche Weiterentwicklung des
          eingesetzten Typsystems von großer Bedeutung für das Unternehmen. Das letzte Ziel der Migration ist deshalb
          die Steigerung der Zukunftssicherheit und Transparenz durch den Wechsel zu TypeScript.
        </p>
        <h2 id="sec:requirements"><span class="chap-number">3.3</span>Technische Anforderungen an den Transpiler</h2>
        <p>
          Neben den ausgeführten Zielen wurden weiterhin fünf technische Anforderungen an den Transpiler erarbeitet,
          welche die Grundlage für die spätere Bewertung der Implementierung bilden. Um sicherzustellen, dass das
          Werkzeug möglichst generisch einsetzbar ist, wurden die Anforderungen nur wo nötig speziell auf die
          Gegebenheiten bei TeamShirts zugeschnitten.
        </p>
        <h3 id="sec:requirement:completeness">
          <span class="chap-number">3.3.1</span>Äquivalente und vollständige Übersetzung der Flow-Typen
        </h3>
        <p>
          Die bedeutsamste Anforderung an den Transpiler ist die äquivalente Übersetzung sämtlicher Flow-Sprachelemente
          nach TypeScript. Durch die Forderung der Vollständigkeit wird erreicht, dass jedes beliebige
          Flow-Eingabeprogramm transpiliert werden kann. Da durch die Spezifikation des abstrakten Syntaxbaums von Babel
          <a class="citation" href="#ref-BABEL:PARSER_SPEC">[66]</a> klar definiert ist, welche der AST-Knoten
          Flow-Syntax darstellen, ist der Umfang einer vollständigen Implementierung exakt eingegrenzt. Jedoch werden
          einige der Funktionen von Flow wie beispielsweise opake Typen in TypeScript nicht unterstützt
          <a class="citation" href="#ref-TS:GITHUB:NO_OPAQUE_TYPE">[81]</a>, sodass eine absolut bedeutungsgleiche
          Übersetzung dieser Typen unmöglich ist. Der Verlust von Typinformation wird deshalb für diese Transformationen
          akzeptiert, allerdings soll der Benutzer bei Auftreten dieser Fälle durch eine aussagekräftige Warnung
          benachrichtigt werden.
        </p>
        <h3 id="sec:requirement:semantic-equivalence">
          <span class="chap-number">3.3.2</span>Semantisch äquivalente Transpilierung des Quelltexts
        </h3>
        <p>
          Darüber hinaus muss gewährleistet werden, dass die Semantik des ursprünglichen JavaScript-Programms durch den
          Transpilierungsprozess nicht verändert wird, um sicherzustellen, dass keine subtilen semantischen Fehler in
          den resultierenden TypeScript-Code eingeschleust werden. Die <em>Wirkung</em> der Gesamtheit aller
          Unterprogramme muss also vor und nach der Migration identisch sein. Ausgenommen hiervon sind die im vorherigen
          Abschnitt angeführten Flow-Typen, die von TypeScript nicht unterstützt werden und daher nicht vollkommen
          äquivalent übersetzt werden können.
        </p>
        <h3 id="sec:requirement:syntax">
          <span class="chap-number">3.3.3</span>Unterstützung aktueller und vorläufiger JavaScript- sowie JSX-Syntax
        </h3>
        <p>
          Aufgrund der kontinuierlichen Weiterentwicklung JavaScripts ist die Syntax der Sprache in den letzten Jahren
          wiederholt um neue Elemente erweitert worden. Beispielsweise wurden 2017 die Schlüsselworte
          <span><code>async</code></span> und <span><code>await</code></span> eingeführt, welche die asynchrone
          Programmierung in JavaScript erleichtern <a class="citation" href="#ref-ECMASCRIPT:2017">[82, S. 430]</a>.
          Damit eine universelle Übersetzung beliebiger Eingaben umsetzbar ist, ist es entscheidend, dass der Transpiler
          jegliche standardkonforme JavaScript-Syntax gemäß der aktuellen ECMAScript-Spezifikation 2019
          <a class="citation" href="#ref-ECMASCRIPT:2019">[17]</a> verarbeiten kann. Auch die Unterstützung vorläufiger,
          noch nicht endgültig standardisierter Spracherweiterungen stellt eine wesentliche Anforderung dar, weil diese
          im Umfeld einiger populärer Bibliotheken bereits heute verwendet werden. So wird zum Beispiel die Erweiterung
          „<em>Class field declarations for JavaScript</em>“
          <a class="citation" href="#ref-ES_PROPOSAL:CLASS_FIELDS">[83]</a> häufig von React-Programmierern benutzt, da
          deren Syntax die Verwendung mancher Funktionen der Bibliothek vereinfacht
          <a class="citation" href="#ref-REACT:HANDLING_EVENTS">[84]</a>. Weil alle Frontend-Projekte von TeamShirts,
          wie ausgeführt, auf React basieren, ist darüber hinaus die Unterstützung von JSX-Syntax
          <a class="citation" href="#ref-SOFTWARE:JSX">[58]</a> eine wesentliche Anforderung an den Transpiler. JSX (<em
            >JavaScript XML</em
          >) ist eine von React eingeführte syntaktische Erweiterung von JavaScript, die dazu verwendet wird den
          HTML-Aufbau von Komponenten anzugeben.
        </p>
        <h3 id="sec:requirement:batch-processing">
          <span class="chap-number">3.3.4</span>Verarbeitung gesamter Projektverzeichnisse
        </h3>
        <p>
          Eine umfangreiche Codebasis besteht im Normalfall aus Hunderten von Einzeldateien. Tabelle
          <a href="#tab:projects-loc" data-reference-type="ref" data-reference="tab:projects-loc">[tab:projects-loc]</a>
          gibt einen Überblick über die konkrete Anzahl und Zusammensetzung der JavaScript-Dateien im vorliegenden Fall
          bei TeamShirts. Um alle Dateien eines Projekts sukzessive übersetzen zu können, soll eine Stapelverarbeitung
          implementiert werden, welche das rekursive Einlesen und Verarbeiten eines gesamten Verzeichnisses realisiert.
          Dabei soll es auch möglich sein, nur bestimmte Dateien in Unterverzeichnissen ein- bzw. auszuschließen, sodass
          die Menge der Eingabedateien flexibel eingegrenzt werden kann.
        </p>
        <p>
          to &amp; &amp; &amp; &amp;<br />
          Components &amp; 331 &amp; 4.341 &amp; 963 &amp; 24.936<br />
          Helios &amp; 353 &amp; 4.814 &amp; 495 &amp; 40.127<br />
        </p>
        <p><span id="tab:projects-loc" label="tab:projects-loc">[tab:projects-loc]</span></p>
        <h3 id="sec:requirement:format">
          <span class="chap-number">3.3.5</span>Beibehaltung der Quelltextformatierung
        </h3>
        <p>
          Als letzte Anforderung wurde schließlich definiert, dass die Quelltextformatierung der Projekte nach
          Ausführung des Transpilers so originalgetreu wie möglich beibehalten werden muss, weil der Programmierstil
          bedeutsam für die Wartbarkeit und Verständlichkeit von Software ist
          <a class="citation" href="#ref-KERNIGHAN:1982">[85, S. 146]</a>. Darüber hinaus bestehen teaminterne
          Absprachen bezüglich des Aufbaus und der Formatierung des Codes, welche durch die Migration nicht verworfen
          werden dürfen. Unter der Formatierung wird nachfolgend die Einrückung des Codes, Zeilenumbrüche und die
          Position der Leerzeichen und -zeilen verstanden. Auch Block- und Zeilenkommentare müssen korrekt in die
          TypeScript-Ausgabe übernommen werden.
        </p>
        <p>
          Besonders hervorzuheben ist hierbei die Positionierung von speziellen Kommentaren, die verwendet werden, um
          Code-Fragmente von den Überprüfungen durch <em>ESLint</em>
          <a class="citation" href="#ref-ESLINT">[86]</a> auszunehmen. ESLint ist ein Werkzeug zur statischen Analyse
          von JavaScript- und TypeScript-Quelltexten, das die Einhaltung eines festgelegten Programmierstil ermöglicht,
          indem Ausdrücke, die eine dieser Regeln verletzen, offengelegt werden.
        </p>
      </section>
      <section>
        <h1 id="chap:implementation"><span class="chap-number">4</span>Umsetzung</h1>
        <p>
          Nachdem die Ziele der angestrebten TypeScript-Migration charakterisiert und die Anforderungen an den geplanten
          Transpiler zur Übersetzung von Flow nach TypeScript ausgeführt wurden, soll im Folgenden der Entwurf und die
          Details der Implementierung umfassend betrachtet werden. Auf Basis der Gegenüberstellung verschiedener
          Werkzeuge zur Transformation von JavaScript-Quelltexten in Abschnitt
          <a href="#sec:js-transpilers" data-reference-type="ref" data-reference="sec:js-transpilers">2.3.2</a> wurde
          Babel <a class="citation" href="#ref-BABEL">[3]</a> als Grundlage der vorliegenden Umsetzung gewählt.
        </p>
        <h2 id="sec:software-architecture"><span class="chap-number">4.1</span>Softwarearchitektur</h2>
        <p>
          Mit der Entscheidung, den Übersetzer als Babel-Plugin zu implementieren, ist dessen Grundarchitektur bereits
          in Teilen festgelegt, da alle Plugins die vorgegebenen Programmschnittstellen von Babel erfüllen müssen. Bevor
          auf Einzelheiten der Umsetzung näher eingegangen wird, soll zunächst der grundsätzliche konzeptionelle Aufbau
          der Anwendung skizziert werden. Abbildung
          <a href="#fig:architecture-overview" data-reference-type="ref" data-reference="fig:architecture-overview"
            >4.1</a
          >
          verschafft einen Überblick über die verschiedenen Komponenten des Systems und deren Beziehung zueinander.
        </p>
        <figure>
          <embed
            src="src/4_Umsetzung/fig/architecture-overview.pdf"
            id="fig:architecture-overview"
            style="width: 92%;"
          />
          <figcaption>Überblick über die Komponenten des Transpilers.</figcaption>
        </figure>
        <p>
          Die Architektur gliedert sich in zwei Teile: Ein Kommandozeilenprogramm stellt die Benutzerschnittstelle dar,
          welche die Eingabeverzeichnisse bzw. -dateien als Argument entgegen nimmt und verschiedene Optionen
          bereitstellt, um das Verhalten der Übersetzung zu beeinflussen<a
            href="#fn16"
            class="footnote-ref"
            id="fnref16"
            role="doc-noteref"
            ><sup>16</sup></a
          >. Die zweite Komponente ist das Babel-Plugin, das die Transpilierung des Flow-Codes nach TypeScript
          realisiert. Das Kommandozeilenprogramm liest sukzessive alle Eingabeverzeichnisse bzw. -dateien ein und
          startet intern die Übersetzung des Quelltexts durch Babel. Hierfür wird das umgesetzte Plugin geladen und
          dieses auf die Eingabe angewendet. Danach kann der TypeScript-Code generiert, formatiert und in Dateien oder
          auf die Standardausgabe geschrieben werden.
        </p>
        <p>
          Das Plugin setzt sich aus verschiedenen Modulen zusammen: Auf oberster Ebene befinden sich die
          Besucherfunktionen<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a
          >, welche die eigentliche Programmtransformation realisieren. Diese adressieren alle Pfade des abstrakten
          Syntaxbaums der Eingabe, die Flow-Syntax darstellen. Bei der Traversierung des Baums durch Babel werden so
          alle zugehörigen Knoten der Pfade durch Ausführung verschiedener <em>Konverter</em> in äquivalente
          TypeScript-Ausdrücke übersetzt. Dabei kann es während der Verarbeitung zu rekursiven Aufrufen weiterer
          Besucher bzw. Konverter kommen. In einigen Fällen liegen weiterhin Methoden zur Optimierung des
          Transformationsresultats vor, die nach der Konvertierung gegebenenfalls angewandt werden. Darüber hinaus
          beinhaltet das Plugin Hilfsfunktionen, um verschiedene Aufgaben wie die Ausgabe von Fehlern und Warnungen
          umzusetzen. Zuletzt enthält das Plugin eine Vielzahl von Modultests (<em>Unit tests</em>), welche die korrekte
          Funktionalität aller Komponenten überprüfen.
        </p>
        <h2 id="entwicklungsprozess"><span class="chap-number">4.2</span>Entwicklungsprozess</h2>
        <p>
          Bevor die Implementierung der Programmtransformation im Detail betrachtet wird, sollen zunächst zwei Aspekte
          des Entwicklungsprozesses dargelegt werden, die diesen wesentlich unterstützt haben.
        </p>
        <h3 id="sec:tdd"><span class="chap-number">4.2.1</span>Testgetriebene Entwicklung</h3>
        <p>
          Die korrekte Übersetzung der Flow-Typen nach TypeScript ist, wie ausgeführt, die wichtigste Anforderung an den
          Transpiler<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a
          >. Essentiell ist daher die Bereitstellung zuverlässiger Testmechanismen, um Softwareregressionen während der
          Entwicklungphase frühzeitig festzustellen. Unter Regressionen werden Programmfehler verstanden, die nach
          bestimmten Ereignissen wie der Implementierung weiterer Funktionen oder Software-Upgrades unvorhergesehen in
          bereits getesteten Modulen auftreten <a class="citation" href="#ref-DOR:SOFTWARE_TEST">[87, S. 218]</a>. Zur
          Erfüllung der Anforderung wurde der Ansatz der testgetriebenen Entwicklung<a
            href="#fn19"
            class="footnote-ref"
            id="fnref19"
            role="doc-noteref"
            ><sup>19</sup></a
          >
          gewählt, um die korrekte Funktionalität und Wechselwirkung aller Bestandteile des Transpilers kontinuierlich
          zu überprüfen. Die testgetriebene Entwicklung hat ihren Ursprung im Vorgehensmodell
          <em>Extreme Programming</em> <a class="citation" href="#ref-JEFFRIES:EXTREME_PROGRAMMING">[88]</a> aus der
          Softwareentwicklung und sieht im Gegensatz zu klassischen, seriellen Vorgehensweisen wie zum Beispiel dem
          Wasserfall-Modell vor, dass sämtliche Testfälle einer Funktionalität bereits <em>vor</em> dessen Umsetzung
          geschrieben werden müssen <a class="citation" href="#ref-BECK:EXTREME_PROGRAMMING">[89]</a>. Die Vorteile
          dieser Methodik ist die Gewährleistung einer hohen Testabdeckung
          <a class="citation" href="#ref-BECK:TDD">[90, S. 90]</a> und die Erzielung einer Implementierung, welche die
          Anforderungen vollständig erfüllt, sofern die Testfälle sorgfältig konstruiert werden
          <a class="citation" href="#ref-BECK:TDD">[90, S. 214]</a>. Wenn die Testfälle erst nach der Programmierung
          angelegt werden, besteht die Gefahr, dass diese lediglich die tatsächlich umgesetzten Funktionen betrachten,
          jedoch nicht den ursprünglichen, möglicherweise abweichenden Anforderungen gerecht werden.
        </p>
        <p>
          Der Testaufbau wurde im konkreten Fall wie folgt konzipiert: Pro Modul wird ein Verzeichnis mit einer Eingabe-
          und einer Ausgabedatei angelegt. Die Eingabe enthält dabei reguläres JavaScript, das mit Flow typisiert wurde,
          die Ausgabe den äquivalenten, manuell übersetzten TypeScript-Code. In den Dateien können beliebig viele
          Testfälle einer Kategorie spezifiziert werden, um eine bestimmte Funktionalität des Transpilers zu erproben.
          Derartige Dateien oder Objekte, die der Initialisierung von Modultests dienen, werden oft als
          „<em>Fixtures</em>“ bezeichnet
          <a class="citation" href="#ref-OLAN:2003">[91]</a>. Durch die bewusste Aufteilung auf zwei unabhängige Dateien
          kann die inhärente Validität der jeweiligen Quelltexte besser gewährleistet werden, da diese jeweils mittels
          Flow bzw. TypeScript auf Fehler überprüft werden können. Hierdurch wird vermieden, dass bereits die Testfälle
          fehlerhaft hinsichtlich der Syntax oder der Typisierung erstellt werden. Würden die Quelltexte als
          Zeichenketten innerhalb der Testumgebung angegeben werden, so wäre eine derartige Prüfung durch das statische
          Typsystem nicht möglich.
        </p>
        <p>
          Die Testdurchführung kann nun wie folgt umgesetzt werden: Der Transpiler wird auf die Eingabedatei angewandt
          und der auf diese Weise generierte TypeScript-Code wird anschließend Zeile für Zeile mit der erwarteten
          Ausgabe exakt verglichen. Um dies zu erreichen, wurde ein Skript geschrieben, welches das Verzeichnis mit den
          Modultests einliest, die Transpilierung anstößt und anschließend den zeilenweisen Vergleich durch das
          Test-Framework
          <em>Jest</em> <a class="citation" href="#ref-SOFTWARE:JEST">[92]</a> durchführt. Das angegebene Verzeichnis
          kann dabei, wie in Quelltext
          <a href="#code:fixture-tests" data-reference-type="ref" data-reference="code:fixture-tests"
            >[code:fixture-tests]</a
          >
          veranschaulicht, beliebig tief verschachtelte Unterverzeichnisse mit Fixture-Dateien enthalten.
        </p>
        <pre style="line-height: 1;"><code style="line-height: 1;">tests/fixtures
└── types
    ├── any
    │     ├── input.js
    │     └── output.ts
    ├── …
    └── utility
        └── call
            ├── input.js
            └── output.ts</code></pre>
        <p>
          Während der Entwicklung des Transpilers wurden nach und nach Modultests für alle Funktionen des Programms
          angelegt. Überprüft wird dabei die korrekte Übersetzung aller Flow-Typen, die Richtigkeit weiterer
          Optimierungen und die Formatierung der Ausgabe. Weiterhin wurden Tests zur Erprobung des
          Kommandozeilenprogramms und der allgemeinen Hilfsfunktionen geschrieben. Damit Regression während der
          fortlaufenden Entwicklung unmittelbar festgestellt werden, werden die Tests nach Einspielung von Änderungen in
          das Versionverwaltungssystem automatisch ausgeführt (<em>kontinuierliche Integration</em>). Insgesamt sind
          1022 Testfälle<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>
          entstanden und es wurde eine Testabdeckung von 93% erreicht.
        </p>
        <h3 id="statische-typisierung-von-babel">
          <span class="chap-number">4.2.2</span>Statische Typisierung von Babel
        </h3>
        <p>
          Der gesamte Transpiler, also sowohl das Babel-Plugin, als auch das zugehörige Kommandozeilenprogramm, wurde in
          TypeScript implementiert. Neben den allgemeinen, bereits ausgeführten Vorteilen statischer Typsysteme ist der
          primäre Grund hierfür, dass so die durch Babel bereitgestellten Typdeklarationen benutzt werden können. Diese
          unterstützen den Entwicklungsprozess sehr, weil die Attribute aller Knoten des abstrakten Syntaxbaums von
          Babel und die Signatur sämtlicher Methoden durch die Typisierung genau spezifiziert sind. Somit kann während
          der Entwicklung durch den TypeScript-Compiler unmittelbar festgestellt werden, ob fehlerhafte Aufrufe von
          Bibliotheksfunktionen oder anderweitige Typverletzungen bestehen. Folglich werden inkorrekte Transformationen
          und Laufzeitfehler reduziert.
        </p>
        <p>
          Quelltext
          <a href="#code:babel:static-types" data-reference-type="ref" data-reference="code:babel:static-types"
            >[code:babel:static-types]</a
          >
          zeigt exemplarisch den Aufbau einer solchen Typdeklaration von Babel anhand des Knotens für ein Typalias in
          Flow. Dieses besteht aus einem Bezeichner (<span><code>id</code></span
          >) und einem zugewiesenen Flow-Typ (<span><code>right</code></span
          >). Der zugewiesene Typ muss dabei ein Element des Vereinigungstyp <span><code>FlowType</code></span> sein,
          der alle möglichen Typen von Flow umfasst. Darüber hinaus können optional Typparameter des Alias angegeben
          werden.
        </p>
        <pre><code>interface TypeAlias extends BaseNode {
  type: &quot;TypeAlias&quot;;
  id: Identifier;
  typeParameters: TypeParameterDeclaration | null;
  right: FlowType;
}</code></pre>
        <p>
          Durch Vergleich der abstrakten Syntaxbäume eines äquivalenten Programmtexts in Flow und TypeScript ist
          nachvollziehbar, welche TypeScript-Token einem bestimmten Flow-Ausdruck entsprechen. Weil alle Methoden von
          Babel typisiert sind, ist damit auch bekannt, welche Typen als Argument der Funktion, die den
          bedeutungsgleichen TypeScript-Ausdruck herstellt, erwartet werden. Die Implementierung von Transformationen
          wird hierdurch erheblich vereinfacht, da so lediglich die Attribute des ursprünglichen Knotens richtig auf den
          Typ des jeweiligen Funktionsparameters abgebildet werden müssen. Es hat sich während der Entwicklung gezeigt,
          dass eine derartige Einschränkung durch die Typisierung sehr hilfreich ist: Wenn keine Typfehler mehr
          vorliegen, ist die Transformation des Flow-Typs nach TypeScript erfahrungsgemäß mit hoher Wahrscheinlichkeit
          korrekt.
        </p>
        <h2 id="sec:implementation"><span class="chap-number">4.3</span>Implementierung als Babel-Plugin</h2>
        <p>
          Nachfolgend soll nun der Aufbau und die konkrete Umsetzung des Babel-Plugins, das die Übersetzung der
          Flow-Typen nach TypeScript realisiert, erläutert werden.
        </p>
        <h3 id="überblick-über-ablauf-der-transpilierung">
          <span class="chap-number">4.3.1</span>Überblick über Ablauf der Transpilierung
        </h3>
        <p>
          Abbildung
          <a href="#fig:activity-diagram-plugin" data-reference-type="ref" data-reference="fig:activity-diagram-plugin"
            >4.2</a
          >
          veranschaulicht den konzeptionellen Aufbau der Transpilierung innerhalb des Babel-Plugins anhand eines
          Aktivitätsdiagramms. Aktivitätsdiagramme entstammen der Modellierungssprache
          <em>Unified Modeling Language</em> (UML) <a class="citation" href="#ref-OMG:UML">[93]</a> und veranschaulichen
          die Arbeitsweise von Prozessen innerhalb eines Softwaresystems. Zu Beginn wird das Plugin wie im
          Grundlagenteil in Quelltext
          <a
            href="#code:babel-plugin-definition"
            data-reference-type="ref"
            data-reference="code:babel-plugin-definition"
            >[code:babel-plugin-definition]</a
          >
          bereits exemplarisch gezeigt initialisiert, das heißt, es wird eine Abbildung der Flow-Knotentypen des
          abstrakten Syntaxbaums auf Besucherfunktionen definiert. Diese realisieren die Transformation aller
          Flow-Typannotationen in entsprechende TypeScript-Syntax. Weiterhin werden die Abhängigkeiten des Plugins
          spezifiziert. Dabei handelt es sich um weitere vorgegebene Babel-Plugins, die benötigt werden, um die Syntax
          von Flow, JSX und vorläufiger ECMAScript-Erweiterungen einlesen zu können<a
            href="#fn21"
            class="footnote-ref"
            id="fnref21"
            role="doc-noteref"
            ><sup>21</sup></a
          >. Auf Grundlage der konkreten Anforderungen bei TeamShirts wurden externe Plugins für folgende
          experimentellen Erweiterungen aktiviert:
        </p>
        <ul>
          <li>
            <em>Class field declarations for JavaScript</em>
            <a class="citation" href="#ref-ES_PROPOSAL:CLASS_FIELDS">[83]</a>
          </li>
          <li><em>JavaScript decorators</em> <a class="citation" href="#ref-ES_PROPOSAL:DECORATORS">[94]</a></li>
          <li><em>Dynamic imports</em> <a class="citation" href="#ref-ES_PROPOSAL:DYNAMIC_IMPORTS">[95]</a></li>
        </ul>
        <figure>
          <embed
            src="src/4_Umsetzung/fig/activity-diagram-plugin.pdf"
            id="fig:activity-diagram-plugin"
            style="width: 85%;"
          />
          <figcaption>Aktivitätsdiagramm des Transpilers (Babel-Plugin).</figcaption>
        </figure>
        <p>
          Nach der Initialisierung beginnt die rekursive Traversierung des abstrakten Syntaxbaums der Eingabe, um diese
          umzuformen. Die Datenstruktur des Syntaxbaums wird von Babel durch Parsen des Flow-Programms aufgebaut. Jeder
          Knoten des Baums wird dabei zunächst „betreten” und daraufhin wieder “verlassen“
          <a class="citation" href="#ref-BABEL:HANDBOOK">[62]</a>. Knoten werden verlassen, wenn bei der Beschreitung
          eines Pfads ein Blatt des Baums erreicht wird und die Traversierung daraufhin auf der höherliegenden Ebene
          fortgesetzt wird.
        </p>
        <p>
          Sofern eine Besucherfunktion für den aktuellen Knotentyp existiert, wird diese mit dem zugehörigen Pfad als
          Argument aufgerufen. Ansonsten wird das nächste Element des Syntaxbaums betreten bzw. die Transpilierung
          beendet, falls keine weiteren Knoten bestehen. Wenn innerhalb der Besucherfunktion festgestellt wird, dass
          Kindknoten vorliegen, so wird deren Pfad rekursiv beschritten. Andernfalls wird der Konverter für diesen
          speziellen Knotentyp ausgeführt, sodass der momentane Pfad anschließend mit dem auf diese Weise berechneten
          TypeScript-Gegenstück ersetzt werden kann. Gleichzeitig werden für einige Knotenarten Optimierungsfunktionen
          aufgerufen. Diese korrigieren beispielsweise fehlerhaft verwendete Typen und sind auf die Gegebenheiten der
          konkreten JavaScript-Projekte abgestimmt. Da viele der Typannotationen von Flow durch mehrere Typen
          zusammengesetzt werden (zum Beispiel <em>Union type</em>, <em>Intersection type</em>, usw.), werden diese
          Ausdrücke durch mehrere rekursive Aufrufe von Konvertern umgeformt. Zuletzt wird der momentane Pfad verlassen
          und die Prozedur beginnt von neuem, sofern weitere Elemente im abstrakten Syntaxbaum vorliegen. Sobald das
          gesamte Programm und damit sämtliche Flow-Typen übersetzt wurden, kann die TypeScript-Ausgabe mittels des
          Codegenerators von Babel <a class="citation" href="#ref-BABEL:GENERATOR">[96]</a> erzeugt werden.
        </p>
        <h3 id="sec:flow-transpilation"><span class="chap-number">4.3.2</span>Transpilierung der Flow-Typen</h3>
        <p>
          Im Folgenden soll nun genauer auf den Kern des Transpilers, die Konverterfunktionen, eingegangen werden. Diese
          realisieren die Übersetzung der einzelnen Flow-Typen nach TypeScript. Aufgrund der großen Zahl von Typen kann
          nicht die vollständige Umsetzung aller Transformationen und sämtlicher Grenzfälle ausführlich dargelegt
          werden, da dies den Umfang der Arbeit überschreiten würde. Deshalb wird nachfolgend lediglich ein Überblick
          über alle Übersetzungen gegeben. Jedoch wurden zur Verbesserung der Anschaulichkeit darüber hinaus einige
          repräsentative Beispiele ausgewählt, anhand derer das Prinzip der Transpilierung detaillierter erläutert wird,
          indem die zugrunde liegende Implementierung betrachtet wird. Die genaue Umsetzung aller Transformationen und
          die Behandlung der Spezialfälle kann mittels des veröffentlichten Quelltexts des Transpilers
          <a class="citation" href="#ref-REFLOW_GITHUB">[97]</a> nachvollzogen werden.
        </p>
        <h4 id="transpilierung-der-basistypen">Transpilierung der Basistypen</h4>
        <p>
          Die Mehrheit der in Tabelle
          <a href="#tab:flow-base-types" data-reference-type="ref" data-reference="tab:flow-base-types"
            >[tab:flow-base-types]</a
          >
          vorgestellten Basistypen von Flow kann innerhalb des Plugins simpel übersetzt werden, da der entsprechende Typ
          in TypeScript die gleiche Syntax besitzt oder sich lediglich das Schlüsselwort unterscheidet. Von den
          insgesamt 30 Basistypen können 18 dieser einfachen Kategorie zugeordnet werden. Die verbleibenden zwölf Typen
          erfordern komplexere Knotentransformationen, um die Annotationen in entsprechende TypeScript-Ausdrücke
          umzuwandeln.
        </p>
        <h5 id="simple-übersetzungen">Simple Übersetzungen</h5>
        <p>
          Tabelle
          <a
            href="#tab:transformation-base-types-simple"
            data-reference-type="ref"
            data-reference="tab:transformation-base-types-simple"
            >[tab:transformation-base-types-simple]</a
          >
          listet die 18 Flow-Typen auf, die simpel übersetzt werden können und zeigt beispielhaft deren Entsprechung in
          TypeScript. Abgesehen von den zwei kursiv hervorgehobenen Zeilen ist die Syntax in TypeScript identisch mit
          der ursprünglichen Notation der Typen in Flow. Dennoch müssen auch diese Elemente des abstrakten Syntaxbaums
          während der Transpilierung in ihr korrektes Gegenstück umgewandelt werden, da eine Kombination von Flow- und
          TypeScript-Knoten innerhalb des abstrakten Syntaxbaums gemäß der Spezifikation
          <a class="citation" href="#ref-BABEL:PARSER_SPEC">[66]</a> von Babel verboten ist. Diese Einschränkung wird
          zur Laufzeit durch Babel mit Hilfe der Bibliothek <span><code>@babel/types</code></span>
          <a class="citation" href="#ref-BABEL:TYPES">[67]</a> sichergestellt. Aufgrund der Verwendung von TypeScript
          und der gegebenen Typisierung von Babel werden Typfehler dieser Art aber ohnehin bereits vor Ausführung des
          Transpilers statisch erkannt.
        </p>
        <p>TODO: types-simple.tex</p>
        <pre><code>// @flow                             // TypeScript
type Alias = mixed;                  type Alias = unknown;</code></pre>
        <p>
          Nachfolgend soll das grundsätzliche Vorgehen bei der Implementierung der Typtransformationen anhand des
          Ablaufs einer solchen einfachen Übersetzung erläutert werden. Quelltext
          <a href="#code:example-simple" data-reference-type="ref" data-reference="code:example-simple"
            >[code:example-simple]</a
          >
          zeigt links das mit Flow typisierte Ursprungsprogramm und rechts den äquivalenten TypeScript-Code. In der
          zweiten Zeile wird dabei ein Typalias definiert, welcher auf den Typ <span><code>mixed</code></span> verweist.
          Wie Tabelle
          <a
            href="#tab:transformation-base-types-simple"
            data-reference-type="ref"
            data-reference="tab:transformation-base-types-simple"
            >[tab:transformation-base-types-simple]</a
          >
          angibt, ist der korrespondierende TypeScript-Typ <span><code>unknown</code></span
          >. Um die notwendigen Schritte einer entsprechenden Transformation zu erkennen, ist es hilfreich, die
          abstrakten Syntaxbäume des ursprünglichen und des angestrebten Quelltexts zu vergleichen. Die jeweiligen
          Syntaxbäume werden in Abbildung
          <a href="#ast:example-simple" data-reference-type="ref" data-reference="ast:example-simple"
            >[ast:example-simple]</a
          >
          für Flow (links) und TypeScript (rechts) dargestellt<a
            href="#fn22"
            class="footnote-ref"
            id="fnref22"
            role="doc-noteref"
            ><sup>22</sup></a
          >. In den Knoten des Baums steht dabei jeweils der Typ des eingelesenen Tokens, die Kanten repräsentieren
          dessen Attribute. Konkrete Werte wie beispielsweise der Name von Bezeichnern werden in Anführungszeichen
          abgedruckt.
        </p>
        <p>
          for tree = <span>l=1.6cm, s sep=0.5cm</span> [Program [TypeAlias, edge label=<span
            >node[edge]<span>body</span></span
          >
          [Identifier, edge label=<span>node[edge]<span>id</span></span> [„Alias“, edge label=<span
            >node[edge]<span>name</span></span
          >] ] [MixedTypeAnnotation, edge label=<span>node[edge]<span>right</span></span
          >] ] ]
        </p>
        <p>
          for tree = <span>l=1.6cm, s sep=1cm</span> [Program [TSTypeAliasDeclaration, edge label=<span
            >node[edge]<span>body</span></span
          >
          [Identifier, edge label=<span>node[edge]<span>id</span></span> [„Alias“, edge label=<span
            >node[edge]<span>name</span></span
          >] ] [TSUnknownKeyword, edge label=<span>node[edge]<span>typeAnnotation</span></span
          >] ] ]
        </p>
        <p>
          Die zwei Bäume sind sich sehr ähnlich: In der Wurzel der Datenstruktur befindet sich bei allen durch Babel
          eingelesenen Quelltexten der Knoten <span><code>Program</code></span
          >. Dessen Kindknoten repräsentiert die Deklaration des Typalias aus der zweiten Zeile des Beispiels. Der Typ
          dieses AST-Elements ist bei Flow <span><code>TypeAlias</code></span> und bei TypeScript
          <span><code>TSTypeAliasDeclaration</code></span
          >. Auf der linken Seite der Anweisung steht dabei der Bezeichner des Alias und auf der rechten Seite der
          zugewiesene Typ. Weil im ursprünglichen Code das Alias auf <span><code>mixed</code></span> (<span
            ><code>MixedTypeAnnotation</code></span
          >) verweist, muss dieser Knoten in TypeScript zu <span><code>unknown</code></span> (<span
            ><code>TSUnknownKeyword</code></span
          >) übersetzt werden, um einen äquivalenten Ausdruck zu erzeugen. In diesem konkreten Fall sind die zwei
          notwendigen Transformationschritte damit folgende:
        </p>
        <ul>
          <li>
            Übersetzung des <span><code>TypeAlias</code></span
            >-Knotens nach <span><code>TSTypeAliasDeclaration</code></span>
          </li>
          <li>
            Übersetzung des <span><code>MixedTypeAnnotation</code></span
            >-Knotens nach <span><code>TSUnknownKeyword</code></span>
          </li>
        </ul>
        <p>
          Der erste Schritt, also die Übersetzung des Typalias, wird durch eine Konverterfunktion realisiert, die
          innerhalb des Besuchers für <span><code>TypeAlias</code></span
          >-Knoten aufgerufen wird. Quelltext
          <a href="#code:convert-type-alias" data-reference-type="ref" data-reference="code:convert-type-alias"
            >[code:convert-type-alias]</a
          >
          zeigt deren vereinfachten Aufbau. Hierbei werden in Zeile 4 zunächst die Typparameter durch Aufruf einer
          weiteren Konvertierungsfunktion in das entsprechende TypeScript-Element transformiert. Daraufhin wird der
          zugewiesene Typ des Alias übersetzt (Zeile 5). Weil dabei ein <em>beliebiger</em> Flow-Typ möglich ist, muss
          dieser allgemeingültig umgewandelt werden können. Es wurde deshalb eine Funktion
          <span><code>convertFlowType</code></span> implementiert, die alle Flow-Typen universell auf ihr
          TypeScript-Gegenstück abbildet.
        </p>
        <pre><code>function convertTypeAlias(
  node: TypeAlias
): TSTypeAliasDeclaration | TSInterfaceDeclaration {
  const tsTypeParameters = convertTypeParameterDeclaration(node.typeParameters);
  const tsTypeAnnotation = convertFlowType(node.right);

  if (isInterfaceTypeAnnotation(node.right))
    return convertInterfaceTypeAlias(node);

  return tsTypeAliasDeclaration(node.id, tsTypeParameters, tsTypeAnnotation);
}</code></pre>
        <p>
          Babel stellt für sämtliche Knoten des abstrakten Syntaxbaums Methoden bereit, mittels derer diese erzeugt
          werden können <a class="citation" href="#ref-BABEL:TYPES">[67]</a>. Somit kann in Zeile 10 durch Aufruf der
          Bibliotheksfunktion <span><code>tsTypeAliasDeclaration</code></span> ein TypeScript-Typalias erstellt werden,
          indem der gleiche Bezeichner sowie die übersetzten Typparameter und der transformierte zugewiesene Typ
          angegeben werden. In Zeile 7 f. wird außerdem ein Spezialfall behandelt: Während Flow Typaliase für
          Schnittstellen (<em>Interfaces</em>) erlaubt, stellt dies in TypeScript unzulässige Syntax dar. Deshalb werden
          derartige Typaliase in einen regulären Schnittstellentyp umgeformt.
        </p>
        <p>
          Der schematische Aufbau der universellen Umwandlungsfunktion <span><code>convertFlowType</code></span> wird in
          Quelltext
          <a href="#code:convert-flow-type" data-reference-type="ref" data-reference="code:convert-flow-type"
            >[code:convert-flow-type]</a
          >
          gezeigt. In Zeile 10 wird hierbei der zweite Schritt der AST-Transformation, die Übersetzung des
          <span><code>mixed</code></span
          >-Schlüsselworts nach <span><code>unknown</code></span
          >, umgesetzt. Durch Aufruf der Bibliotheksfunktion <span><code>tsUnknownKeyword()</code></span> wird ein neuer
          AST-Knoten erzeugt, der das entsprechende Schlüsselwort in TypeScript repräsentiert. In Zeile 4 wird ein
          weiteres wichtiges Konzept innerhalb des Transpilers exemplarisch aufgezeigt: Für Knoten des Typs
          <span><code>ArrayTypeAnnotation</code></span> wird die Umwandlungsfunktion <em>rekursiv</em> aufgerufen, da
          auch hier beliebige Flow-Typen als Argument des Feldtyps angegeben werden können. Wie die Transformation des
          Typalias bereits zeigt, spielt die Umwandlungsmethode <span><code>convertFlowType</code></span> eine zentrale
          Rolle innerhalb des Transpilers, da sie in nahezu allen Konvertern aufgerufen wird. Zeile 7 verdeutlicht
          schließlich, dass nicht alle Knoten so einfach wie der Typ <span><code>mixed</code></span> aus dem Beispiel
          umgewandelt werden können, da der Aufbau vieler Typen komplexer ist. Die Transformation dieser Knoten wird
          separat durch jeweilige Konverterfunktionen durchgeführt. Im Folgenden wird die Übersetzung solcher
          komplizierteren Typen betrachtet.
        </p>
        <pre><code>function convertFlowType(node: FlowType): TSType {
  switch (node.type) {
    case &#39;ArrayTypeAnnotation&#39;:
      return tsArrayType(convertFlowType(node.elementType));
    // …
    case &#39;InterfaceTypeAnnotation&#39;:
      return convertInterfaceTypeAnnotation(node);
    // …
    case &#39;MixedTypeAnnotation&#39;:
      return tsUnknownKeyword();
  }
}</code></pre>
        <h5 id="komplexere-übersetzungen">Komplexere Übersetzungen</h5>
        <p>
          Die Übersetzung der zwölf komplexen Flow-Datentypen wird in Tabelle
          <a
            href="#tab:transformation-base-types-complex"
            data-reference-type="ref"
            data-reference="tab:transformation-base-types-complex"
            >[tab:transformation-base-types-complex]</a
          >
          exemplarisch gezeigt. Im Gegensatz zu den simplen Transformationen unterscheidet sich die Syntax des
          Ausgabequelltexts hier zum Teil deutlich und es müssen bei der Transpilierung vermehrt Spezial- und Grenzfälle
          beachtet werden, um korrekten TypeScript-Code zu erzeugen. Zum Beispiel erlaubt Flow den Typ einer Funktion,
          die eine Zeichenkette und eine Zahl als Argument entgegen nimmt, wie folgt zu deklarieren:
        </p>
        <pre data-numbers="none"><code>type FunctionType = (string, argName: number) =&gt; void;</code></pre>
        <p>
          Während die Benennung der formalen Parameter in Flow optional ist, ist diese in TypeScript verpflichtend.
          Deshalb müssen Parameter während der Übersetzung von Funktionstypen nach TypeScript gegebenenfalls automatisch
          benannt werden, da andernfalls fehlerhafte Syntax entstünde<a
            href="#fn23"
            class="footnote-ref"
            id="fnref23"
            role="doc-noteref"
            ><sup>23</sup></a
          >. Der in der Tabelle kursiv hervorgehobene Typ <em>Opaque type</em> wird in TypeScript nicht unterstützt
          <a class="citation" href="#ref-TS:GITHUB:NO_OPAQUE_TYPE">[81]</a> und wird deshalb, wie gezeigt, zu einem
          regulären Typalias umgeformt.
        </p>
        <p>TODO: types-complex.tex</p>
        <p>
          Anhand des Typs <em>Nullable</em> soll im Folgenden das Vorgehen bei der Transformation eines komplizierteren
          Knoten erläutert werden<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a
          >. Dieser Typ wird in der Flow-Dokumentation auch als „<em>Maybe type</em>“ bezeichnet und für die Typisierung
          optionaler, möglicherweise undefinierter Werte verwendet
          <a class="citation" href="#ref-FLOW:MAYBE_TYPES">[98]</a>. Konkret stellt der Typ die Vereinigung aus dem
          angegebenen Typ, <span><code>null</code></span> und <span><code>undefined</code></span> dar. In TypeScript
          existiert keine direkte Entsprechung, aber es kann trivial ein äquivalenter Vereinigungstyps angegeben werden.
          Quelltext
          <a href="#code:example-complex" data-reference-type="ref" data-reference="code:example-complex"
            >[code:example-complex]</a
          >
          zeigt die jeweilige Deklaration eines Typalias in Flow (links) und TypeScript (rechts), das auf diesen
          Datentyp verweist.
        </p>
        <pre><code>// @flow                              // TypeScript
type MaybeNumber = ?number;           type MaybeNumber = number | null | undefined;</code></pre>
        <p>
          Wie bei der vorherigen Betrachtung einer simplen Übersetzung (<span><code>MixedTypeAnnotation</code></span
          >) sollen auch hier zunächst die abstrakten Syntaxbäume der Ein- und Ausgabe für den Typ
          <em>Nullable</em> verglichen werden, um die Einzelschritte der Transpilierung aufzuzeigen (vgl. Abbildung
          <a href="#ast:example-complex" data-reference-type="ref" data-reference="ast:example-complex"
            >[ast:example-complex]</a
          >). Das Typalias ist dabei analog zum vorherigen Beispiel und dient lediglich der Herstellung korrekter
          Syntax. Entscheidend ist der zugewiesene Typ des Alias im rechten Teilbaum: Bei Flow liegt hier das Element
          <span><code>NullableTypeAnnotation</code></span> vor, das den Typ für Zahlen (<span
            ><code>NumberTypeAnnotation</code></span
          >) als Argument erhält. Auf Seite von TypeScript steht dagegen der Knoten des Vereinigungstyps (<span
            ><code>TSUnionType</code></span
          >). Diesem ist eine Menge von Typen zugeordnet, die den äquivalenten Ausdruck bilden, indem der Zahlentyp mit
          den Typen für <span><code>null</code></span> und <span><code>undefined</code></span> kombiniert wird.
        </p>
        <p>
          for tree = <span>l=1.6cm, s sep=0.5cm</span> [Program [TypeAlias, edge label=<span
            >node[edge]<span>body</span></span
          >
          [Identifier, edge label=<span>node[edge]<span>id</span></span> [„MaybeNumber“, edge label=<span
            >node[edge]<span>name</span></span
          >] ] [NullableTypeAnnotation, edge label=<span>node[edge]<span>right</span></span> [NumberTypeAnnotation, edge
          label=<span>node[edge]<span>typeAnnotation</span></span
          >] ] ] ]
        </p>
        <p>
          for tree = <span>l=1.6cm, s sep=1.25cm</span> [Program [TSTypeAliasDeclaration, edge label=<span
            >node[edge]<span>body</span></span
          >
          [Identifier, edge label=<span>node[edge]<span>id</span></span> [„MaybeNumber“, tier=last, edge label=<span
            >node[edge]<span>name</span></span
          >] ] [TSUnionType, edge label=<span>node[edge]<span>typeAnnotation</span></span> [TSNumberKeyword, tier=last,
          edge label=<span>node[edge]<span>types[]</span></span
          >, for tree=<span>align=center, minimum width=3cm, l=0, s sep=0, inner ysep=0</span>, [TSNullKeyword, no edge
          [TSUndefinedKeyword, no edge] ] ] ] ] ]
        </p>
        <p>
          Quelltext
          <a href="#code:convert-nullable-type" data-reference-type="ref" data-reference="code:convert-nullable-type"
            >[code:convert-nullable-type]</a
          >
          zeigt die entsprechende Implementierung. Zuerst wird in Zeile 2 das Argument des Typs
          <span><code>NullableTypeAnnotation</code></span> durch Aufruf der bereits gezeigten zentralen
          Umwandlungsfunktion von Flow in den korrekten TypeScript-Typ übersetzt. Im vorliegenden Fall wird Flows
          <span><code>NumberTypeAnnotation</code></span> in das Gegenstück
          <span><code>TSNumberKeyword</code></span> überführt. Anschließend wird eine Liste aufgebaut, die aus diesem
          Datentyp und den Typen für <span><code>null</code></span> und <span><code>undefined</code></span> besteht. Zu
          Beachten sind hierbei zwei Spezialfälle: Einerseits darf der Nullwert nicht doppelt in die Liste aufgenommen
          werden (Zeile 4 f.), damit kein redundanter Ausdruck entsteht, andererseits müssen Funktionstypen in dieser
          Situationen geklammert werden, um korrekte TypeScript-Syntax herzustellen (Zeile 6). Eine Doppelung träte dann
          auf, wenn in Flow der Typ <span><code>?null</code></span> verwendet wird. Zuletzt kann der
          TypeScript-Vereinigungstyp durch Aufruf der entsprechenden Bibliotheksfunktion von Babel mit der Typliste als
          Argument erzeugt und zurückgeliefert werden.
        </p>
        <pre><code>function convertNullableTypeAnnotation(node: NullableTypeAnnotation): TSUnionType {
  const tsType = convertFlowType(node.typeAnnotation);
  const types = [
    ...(isTSNullKeyword(tsType)
      ? []
      : [isTSFunctionType(tsType) ? tsParenthesizedType(tsType) : tsType]),
    tsNullKeyword(),
    tsUndefinedKeyword(),
  ];

  return tsUnionType(types);
}</code></pre>
        <h4 id="transpilierung-der-hilfstypen">Transpilierung der Hilfstypen</h4>
        <p>
          Auch die in Abschnitt
          <a href="#sec:flow:utility-types" data-reference-type="ref" data-reference="sec:flow:utility-types"
            >2.2.1.6</a
          >
          eingeführten Hilfstypen von Flow können größtenteils äquivalent nach TypeScript überführt werden. Tabelle
          <a
            href="#tab:transformation-utility-types"
            data-reference-type="ref"
            data-reference="tab:transformation-utility-types"
            >[tab:transformation-utility-types]</a
          >
          gibt einen Überblick über alle Übersetzungen. Für einige der Einträge gibt es in TypeScript bedeutungsgleiche
          Hilfstypen, andere können leicht durch Verwendung von Typoperatoren abgebildet werden.
        </p>
        <p>TODO: types-utility.tex</p>
        <p>
          Die Transformation der drei Abbildungstypen <em>Object map</em>, <em>Object map with key</em> und
          <em>Tuple map</em> wurde nicht umgesetzt, weil kein TypeScript-Ausdruck gefunden werden konnte, der diesen
          exakt entspricht. Deshalb werden diese Typen bei der Transpilierung mit <em>any</em> ersetzt. Da die
          JavaScript-Projekte von TeamShirts diese Hilfstypen jedoch ohnehin nicht verwenden, stellt dies kein Hindernis
          für die Migration im vorliegenden Fall dar. Die zwei Typen <em>Subtype</em> und <em>Supertype</em> wurden wie
          ausgeführt von Flow als veraltet (<em>deprecated</em>) markiert und werden deshalb ebenfalls nach
          <span><code>any</code></span> übersetzt. Auch der <em>Existential type</em> wurde als überholt gekennzeichnet,
          da er unsicher ist <a class="citation" href="#ref-FLOW:LINT_RULE_REFERENCE">[99]</a>. Weil TypeScript einen
          derartigen Typ nicht unterstützt, wird auch dieser durch <span><code>any</code></span> ersetzt. Sollten in der
          Eingabe einer dieser sechs nicht unterstützen Hilfstypen auftreten, so wird während der Verarbeitung durch das
          Babel-Plugin wie gefordert eine detaillierte Warnung ausgegeben mit der Aufforderung, den Ausgabequelltext an
          dieser Stelle manuell zu korrigieren<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"
            ><sup>25</sup></a
          >.
        </p>
        <p>
          Zu beachten ist darüber hinaus, dass die Typparameter der Hilfstypen (<span><code>F</code></span
          >, <span><code>T</code></span
          >, <span><code>O</code></span> usw.) für beliebige kompatible Flow-Typen stehen. Deshalb ruft die
          Implementierung auch hier intern die universelle Konvertierungsfunktion
          <span><code>convertFlowType()</code></span> auf, um alle Fälle korrekt zu übersetzen.
        </p>
        <h4 id="transpilierung-der-typdeklarationen">Transpilierung der Typdeklarationen</h4>
        <p>
          Da der Transpiler Anspruch auf Vollständigkeit erhebt, müssen auch Typdeklarationen transformiert werden.
          Tabelle
          <a
            href="#tab:transformation-declarations"
            data-reference-type="ref"
            data-reference="tab:transformation-declarations"
            >[tab:transformation-declarations]</a
          >
          zeigt exemplarisch die verschiedenen Deklarationen und deren Gegenstücke in TypeScript. Die Syntax ist hierbei
          ähnlich zu den simplen Basistypen oftmals identisch in Flow und TypeScript. Dennoch müssen die zugrunde
          liegenden Knoten des abstrakten Syntaxbaums übersetzt werden, da die entsprechenden Ausdrücke in TypeScript
          eigene Knotentypen besitzen. Interessant ist die Deklaration des Standardexports eines Moduls<a
            href="#fn26"
            class="footnote-ref"
            id="fnref26"
            role="doc-noteref"
            ><sup>26</sup></a
          >
          in der zweiten Zeile. Während Flow hier den Export von Funktionen unterstützt, kann dies nicht unmittelbar in
          TypeScript abgebildet werden. Deshalb muss die Deklaration umgeformt werden: Der Wert der ursprünglichen
          Deklaration wird dabei einer neu erstellten Variablen (<span><code>_default</code></span
          >) zugewiesen und kann anschließend als Argument des Exports verwendet werden, sodass ein äquivalenter
          Ausdruck entsteht.
        </p>
        <p>TODO: types-declaration.tex</p>
        <h3 id="sec:optimizations"><span class="chap-number">4.3.3</span>Weitere Optimierungen</h3>
        <p>
          Bei der Erprobung des Transpilers mit den zwei JavaScript-Projekten von TeamShirts wurde die Erfahrung
          gewonnen, dass neben der Transformation der Flow-Typen auch andere Änderungen des Quelltexts nötig sind, um
          eine Migration zu TypeScript erfolgreich durchzuführen. Zur Reduzierung händischer Nacharbeit wurde das Plugin
          um Funktionen erweitert, die diese zusätzlichen Schritte automatisieren. Diese werden nachfolgend ausgeführt.
        </p>
        <h4 id="sec:react-type-import-mapping">Übersetzung von React-Typimporten</h4>
        <p>
          Die von TeamShirts eingesetzte Bibliothek React stellt ähnlich wie Babel Typdeklarationen sowohl für Flow als
          auch für TypeScript bereit. Diese Typen können importiert und anschließend in den eigenen Typannotation
          verwendet werden. Leider wurden die korrespondierenden React-Typen in den Definitionen für Flow und TypeScript
          unterschiedlich benannt. Während einer dieser Typen in Flow beispielsweise
          <span><code>Node</code></span> heißt, ist dessen Bezeichnung in TypeScript <span><code>ReactNode</code></span
          >. Würden die Typimporte unverändert übernommen werden, so entstünden in der Ausgabe Typfehler, da der
          importierte Typ unter TypeScript nicht existiert.
        </p>
        <pre><code>// @flow                                     // TypeScript
import React, { type Node } from &#39;react&#39;;    import React, { ReactNode } from &#39;react&#39;;
type FunctionType = () =&gt; Node;              type FunctionType = () =&gt; ReactNode;</code></pre>
        <p>
          Quelltext
          <a href="#code:react-imports" data-reference-type="ref" data-reference="code:react-imports"
            >[code:react-imports]</a
          >
          veranschaulicht, wie die Transpilierung richtig durchgeführt werden sollte. Zum einen muss die Syntax des
          Typimports an sich transformiert werden, zum anderen sollten die Namen sämtlicher React-Typen korrekt auf ihr
          Gegenstück in TypeScript übersetzt werden. Dabei müssen auch alle Konstrukte, die diese importierten Typen
          verwenden, entsprechend angepasst werden. Da bekannt ist, welche Typen von React exportiert werden und wie
          deren Bezeichnung in TypeScript ist, konnte eine solche Transformation mittels einer statischen
          Abbildungstabelle implementiert werden.
        </p>
        <h4 id="sec:class-decorators">Konvertierung von Klassendekoratoren</h4>
        <p>
          In den Projekten von TeamShirts werden Klassendekoratoren verwendet, um React-Komponenten um verschiedene
          Funktionen zu erweitern. Derartige Dekoratoren sind eine vorgeschlagene Spracherweiterung von ECMAScript, die
          es ermöglichen, Klassen oder deren Attribute unabhängig von der zugrunde liegenden Implementierung zu
          modifizieren
          <a class="citation" href="#ref-ES_PROPOSAL:DECORATORS">[94]</a>. Dabei werden spezielle Annotationen (<span
            ><code>@decorator</code></span
          >) in den Quelltext unmittelbar vor der Deklaration einer Klasse eingefügt. Dekoratoren stellen Funktionen
          höherer Ordnung dar, die den Konstruktor der Klasse als Argument erhalten, diesen gegebenenfalls verändern und
          daraufhin eine Funktion zurückliefern, die den Konstruktor intern aufruft
          <a class="citation" href="#ref-ES_PROPOSAL:DECORATORS">[94]</a>. Auf diese Weise kann die Instanziierung aller
          Objekten dieser Klasse beeinflusst werden, indem beispielsweise weitere Methoden vor oder nach Aufruf des
          Konstruktors ausgeführt werden.
        </p>
        <p>
          Es wurde bei der praktischen Erprobung des Transpilers festgestellt, dass die Verwendung von Dekoratoren in
          TypeScript problematisch ist, da dies zu zahlreichen Typfehlern führt und eine korrekte Typisierung aufwändig
          ist. Deshalb wurde eine optionale Funktion in den Transpiler integriert, welche die Klassendekoratoren durch
          äquivalente, verschachtelte Funktionsaufrufe ersetzt. Es hat sich gezeigt, dass diese hinsichtlich der
          Typisierung weitaus weniger Schwierigkeiten verursachen. In Quelltext
          <a href="#code:class-decorators" data-reference-type="ref" data-reference="code:class-decorators"
            >[code:class-decorators]</a
          >
          wird eine derartige Transpilierung veranschaulicht. Die Transformation der Klassendekoratoren kann durch
          Setzen der Option „<code>replace-decorators</code>“<a
            href="#fn27"
            class="footnote-ref"
            id="fnref27"
            role="doc-noteref"
            ><sup>27</sup></a
          >
          des Kommandozeilenprogramms aktiviert werden.
        </p>
        <pre><code>// @flow                                        // TypeScript
@d1(arg)
@d2
class C {}                                      class C {}
export default C;                               export default d1(arg)(d2(C));</code></pre>
        <h2 id="sec:cli-program"><span class="chap-number">4.4</span>Erweiterung als Kommandozeilenprogramm</h2>
        <p>
          Zur Erfüllung der in Abschnitt
          <a
            href="#sec:requirement:batch-processing"
            data-reference-type="ref"
            data-reference="sec:requirement:batch-processing"
            >3.3.4</a
          >
          dargelegten Anforderung, dass der Transpiler in der Lage sein muss, gesamte Projektverzeichnisse zu
          verarbeiten (Stapelverarbeitung), ist die Erweiterung des Transcompilers um ein Kommandozeilenprogramm
          nützlich. Hierdurch können beliebige Dateien und Verzeichnisse eingelesen und deren Übersetzung durch
          verschiedene Optionen beeinflusst werden. Wie bereits in Abschnitt
          <a href="#sec:software-architecture" data-reference-type="ref" data-reference="sec:software-architecture"
            >4.1</a
          >
          umrissen, benutzt die Konsolenanwendung intern das Babel-Plugin, um die Transpilierung der Flow-Quelltexte
          nach TypeScript durchzuführen. Die Aufgaben des Programms sind damit das Einlesen der Eingabe, die Delegation
          dieser an das Babel-Plugin, die Formatierung des generierten TypeScript-Codes und schließlich die Ausgabe
          desselben.
        </p>
        <p>
          Die Anwendung wurde als ausführbares Node.js-Skript umgesetzt und <em>Reflow</em> genannt. Das Werkzeug kann
          durch das Paketsystem von Node.js installiert und anschließend wie folgt aufgerufen werden<a
            href="#fn28"
            class="footnote-ref"
            id="fnref28"
            role="doc-noteref"
            ><sup>28</sup></a
          >. Tabelle
          <a href="#tab:cli-options" data-reference-type="ref" data-reference="tab:cli-options">[tab:cli-options]</a>
          zeigt alle Optionen des Kommandozeilenprogramms und beschreibt deren Zweck.
        </p>
        <pre><code>reflow [OPTIONEN]… &lt;DATEIEN ODER VERZEICHNISSE…&gt;
Beispiel: reflow --dry-run --include-pattern &quot;**/*.js&quot; src/</code></pre>
        <p>TODO: cli.tex</p>
        <figure>
          <embed src="src/4_Umsetzung/fig/activity-diagram-cli.pdf" id="fig:activity-diagram-cli" style="width: 85%;" />
          <figcaption>
            Aktivitätsdiagramm des Kommandozeilenprogramms. Vgl. eingebettete Diagramme
            <a
              href="#fig:activity-diagram-plugin"
              data-reference-type="ref"
              data-reference="fig:activity-diagram-plugin"
              >4.2</a
            >
            „Eingabe transpilieren“ und
            <a
              href="#fig:activity-diagram-formatting"
              data-reference-type="ref"
              data-reference="fig:activity-diagram-formatting"
              >4.4</a
            >
            „Ausgabe formatieren“.
          </figcaption>
        </figure>
        <p>
          Abbildung
          <a href="#fig:activity-diagram-cli" data-reference-type="ref" data-reference="fig:activity-diagram-cli"
            >4.3</a
          >
          zeigt das Aktivitätsdiagramm des Kommandozeilenprogramms. Als Erstes werden dessen Argumente eingelesen und
          validiert. Dabei wird überprüft, ob alle Eingabeverzeichnisse bzw. -dateien existieren und ob der Dateityp
          korrekt ist. Erlaubt sind lediglich JavaScript- und JSX-Dateien. Sofern diese Validierung fehlschlägt, wird
          die Anwendung mit einer Fehlermeldung beendet. Andernfalls wird daraufhin eine Liste der zu übersetzenden
          Flow-Dateien erstellt. Falls Verzeichnisse als Argument angegeben worden sind, so werden alle Dateien
          innerhalb dieser, die dem Wildcard-Muster für Eingabedateien (Option „<code>include-pattern</code>“)
          entsprechen, der Liste hinzugefügt. Anschließend wird eine Schleife betreten, die alle auf diese Weise
          ermittelten Dateien nach und nach verarbeitet. Da invalide Wildcard-Muster durch Benutzereingabe möglich sind,
          wird erneut überprüft, ob die aktuelle Eingabedatei zulässig ist. Sollte dies nicht der Fall sein, so wird
          diese übersprungen. Ansonsten wird der Quelltext der Datei durch den Parser von Babel eingelesen und so die
          Datenstruktur des abstrakten Syntaxbaum des Programms aufgebaut. Daraufhin wird die Transpilierung der
          Flow-Typisierung durch das Babel-Plugin angestoßen. Auch hier kann es zu Laufzeitfehlern kommen, falls
          beispielsweise Syntaxfehler innerhalb des Eingabequelltexts vorliegen. In diesem Fall wird die aktuelle Datei
          ebenfalls übersprungen und eine Warnung ausgegeben.
        </p>
        <p>
          Nachdem die Transpilierung abgeschlossen ist, wird der generierte TypeScript-Code unabhängig von Babel
          formatiert. Dabei wird eine selbst implementierte Funktion ausgeführt, die eine möglichst originalgetreuen
          Formatierung der Ausgabe umsetzt. Sollten unerwartete Fehler auftreten wird auch hier die Datei gegebenenfalls
          übersprungen. Zuletzt kann der so erzeugte TypeScript-Quelltext ausgegeben werden. Dabei gibt es je nach
          Verwendung der Kommandozeilenoptionen drei Möglichkeiten: Wenn der Parameter „<code>dry-run</code>“ gesetzt
          ist, wird das Resultat auf die Standardausgabe geschrieben. Andernfalls werden neue TypeScript-Dateien im
          Verzeichnis der Eingabedateien erstellt und die Originaldateien anschließend gelöscht, sofern die Option zum
          Ersetzen dieser angegeben wurde.
        </p>
        <p>
          Da die Verwendung von JSX-Syntax in TypeScript die Dateierweiterung <span><code>.tsx</code></span> vorschreibt
          <a class="citation" href="#ref-TS:HANDBOOK:JSX">[100]</a>, muss sichergestellt werden, dass die Ausgabedateien
          die jeweils korrekte Endung erhalten. Weiterhin müssen globale Typdeklarationen in Dateien mit der Erweiterung
          <span><code>.d.ts</code></span> geschrieben werden. Zur Bestimmung des richtigen Ausgabedateityps wird deshalb
          während der Transpilierung innerhalb des Babel-Plugins überprüft, ob JSX-Syntax in der Eingabedatei verwendet
          wird bzw. ob Typdeklarationen vorliegen. Hierfür werden Besucherfunktionen für die jeweiligen speziellen
          AST-Knoten registriert, sodass eine Lookup-Tabelle aufgebaut werden kann, welche die Abbildung der
          Originaldateien auf den korrekten Ausgabetyp darstellt. Das Kommandozeilenprogramm fragt diese Information
          schließlich beim Schreiben der TypeScript-Dateien ab und reagiert entsprechend.
        </p>
        <h2 id="sec:formatting"><span class="chap-number">4.5</span>Formatierung des Ausgabequelltexts</h2>
        <p>
          Ein Aspekt, der sich während der Entwicklung des Transpilers als problematisch herausgestellt hat und deshalb
          einer gesonderten Betrachtung bedarf, ist die Formatierung des generierten Ausgabecodes. Weil Babel auf
          Grundlage eines <em>abstrakten</em> Syntaxbaums arbeitet, liegt nach der Transformation des Programms
          keinerlei Information mehr über die ursprüngliche Formatierung des Codes vor. Infolgedessen gehen die
          Einrückung und die Position der Leerzeichen in der Ausgabe verloren. Auch die Platzierung der Kommentare wird
          nach der Übersetzung nicht präzise beibehalten. Diese werden deshalb von der Übersetzung ausgeschlossen, weil
          sie ohnehin teilweise falsch übernommen werden.
        </p>
        <p>
          Versuche mit der Option „<code>retainLines</code>“
          <a class="citation" href="#ref-BABEL:GENERATOR">[96]</a> des Babel-Codegenerators, welche eine Beibehaltung
          der Zeilen in der Ausgabe bewirken soll, erzielten leider nicht das gewünschte Ergebnis. Auch nach Setzen
          dieser Eigenschaft unterscheidet sich das Format des generierten Quelltexts erheblich von der Eingabe. Da die
          möglichst originalgetreue Formatierung der Ausgabe aber eine der Anforderungen an den Transpiler ist, wurde
          eine entsprechende Funktion implementiert, um diese Vorgabe unabhängig von Babel zu erfüllen. Das Verfahren
          wird nach der Transpilierung aller Eingabedateien durch das Kommandozeilenprogramm angestoßen<a
            href="#fn29"
            class="footnote-ref"
            id="fnref29"
            role="doc-noteref"
            ><sup>29</sup></a
          >
          und soll im Folgenden erläutert werden.
        </p>
        <figure>
          <embed
            src="src/4_Umsetzung/fig/activity-diagram-formatting.pdf"
            id="fig:activity-diagram-formatting"
            style="width: 55%;"
          />
          <figcaption>
            Aktivitätsdiagramm der Formatierung des generierten Ausgabecodes auf Grundlage des Quelltext-Formatierers
            <em>Prettier</em> <a class="citation" href="#ref-SOFTWARE:PRETTIER">[101]</a>.
          </figcaption>
        </figure>
        <p>
          Der konzeptionellen Aufbau der Formatierungsfunktion wird in Abbildung
          <a
            href="#fig:activity-diagram-formatting"
            data-reference-type="ref"
            data-reference="fig:activity-diagram-formatting"
            >4.4</a
          >
          dargestellt. Die Idee ist simpel: Nachdem sowohl die Ein- als auch die Ausgabe in einen vergleichbaren,
          konsistenten Zustand überführt worden sind, können Leerzeilen und Kommentare aus dem ursprünglichen Quelltext
          Schritt für Schritt übertragen werden. Konsistent bedeutet, dass die Ausdrücke und Anweisungen in beiden
          Quelltexten die gleiche Zahl von Zeilen vereinnahmen, also dass diese gleich umgebrochen werden. Diese
          Voraussetzung muss insbesondere auch für alle Flow-Typen nach deren Übersetzung nach TypeScript gelten. Grund
          für die Herstellung dieser Eigenschaft ist, dass das weitere Verfahren zeilenbasiert arbeitet, um die
          Originalformatierung in die Ausgabe zu übernehmen.
        </p>
        <p>
          Zur Herstellung eines solchen Ausgangszustand wird <em>Prettier</em>
          <a class="citation" href="#ref-SOFTWARE:PRETTIER">[101]</a> eingesetzt. Prettier ist ein
          Quelltext-Formatierer, der einen einheitlichen Programmierstil für Sprachen wie JavaScript, TypeScript, HTML
          und weitere ermöglicht. Experimente haben gezeigt, dass die Ein- und Ausgabe bei der Anwendung von Prettier
          allerdings aufgrund unterschiedlicher Syntax von Flow und TypeScript nicht in allen Situationen
          übereinstimmend umgebrochen wird. Deshalb wurde das Werkzeug geringfügig modifiziert, um so eine größere
          Konsistenz der Ausgabe zu erzielen<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"
            ><sup>30</sup></a
          >. Bei Setzen einer neu hinzugefügten Option werden dabei die Attribute von Objekten und JSX-Ausdrücken stets
          umgebrochen, um deren zeilenweisen Vergleich zu ermöglichen. Prettier bricht diese standardmäßig erst dann um,
          wenn die eingestellte Druckweite überschritten wird.
        </p>
        <p>
          Im ersten Schritt der Formatierungsroutine wird diese angepasste Version von Prettier einerseits auf den
          Originalcode, andererseits auf den generierte TypeScript-Quelltext angewandt (vgl. Abbildung
          <a
            href="#fig:activity-diagram-formatting"
            data-reference-type="ref"
            data-reference="fig:activity-diagram-formatting"
            >4.4</a
          >). Im Anschluss kann sukzessive über alle Zeilen der Eingabe iteriert werden, um in jedem Schleifendurchlauf
          zu prüfen, ob eine Leerzeile vorliegt. Gegebenenfalls wird diese an die entsprechende Position in der Ausgabe
          kopiert. Gleichzeitig werden Block- und Zeilenkommentare im ursprünglichen Flow-Programm gesucht und an die
          gleiche Stelle in den TypeScript-Code eingefügt. Auf diese Weise werden nach und nach alle Leerzeilen und
          Kommentare übertragen, sodass die originalgetreue Formatierung hergestellt wird. Schließlich wird Prettier
          erneut auf die auf diese Weise modifizierte Ausgabe angewandt, um verbleibende Probleme wie beispielsweise
          doppelte Leerzeilen zu eliminieren. /
        </p>
      </section>
      <section>
        <h1 id="chap:evaluation"><span class="chap-number">5</span>Auswertung und Diskussion</h1>
        <p>
          Nachfolgend sollen nun die Ergebnisse der Migration der zwei Projekte <em>Components</em> und <em>Helios</em>,
          die mit Hilfe des umgesetzten Flow-Transpilers durchgeführt wurde, dargelegt werden. Dabei wird zum einen die
          Erfüllung der Zielvorgaben aus Abschnitt
          <a href="#sec:goals" data-reference-type="ref" data-reference="sec:goals">3.2</a>, zum anderen die Einhaltung
          der technischen Anforderungen an den Transcompiler aus Abschnitt
          <a href="#sec:requirements" data-reference-type="ref" data-reference="sec:requirements">3.3</a> beurteilt und
          kritisch diskutiert. Damit die erzielten Ergebnisse besser eingeordnet werden können, werden diese hierbei
          auch, wo möglich, mit den Ansätzen von <em>Kikura</em>
          <a class="citation" href="#ref-KIKURA:FLOW_TO_TS">[77]</a> und <em>Barabash</em>
          <a class="citation" href="#ref-BARABASH:FLOW_TO_TS">[79]</a> zur Transpilierung von Flow verglichen<a
            href="#fn31"
            class="footnote-ref"
            id="fnref31"
            role="doc-noteref"
            ><sup>31</sup></a
          >. Zunächst wird jedoch die Durchführung der Migration an sich beschrieben.
        </p>
        <h2 id="durchführung-der-migration"><span class="chap-number">5.1</span>Durchführung der Migration</h2>
        <p>
          Bereits während der Entwicklungsphase des Flow-Transpilers wurde dieser immer wieder mit dem Quelltext der
          vorliegenden Projekte von TeamShirts erprobt, um dessen Praxistauglichkeit anhand einer realen Codebasis zu
          überprüfen. Nachdem der vollständige Funktionsumfang des Transcompilers hergestellt war, wurde als erstes das
          Projekt Components, danach das Projekt Helios mit Hilfe des Übersetzers in TypeScript umgewandelt. Diese
          Reihenfolge wurde bewusst gewählt, da Components keine Abhängigkeit zu anderen Projekten von TeamShirts
          besitzt, aber Helios wiederum Teile von Components verwendet. Weil Components somit bei der Migration von
          Helios bereits in TypeScript vorlag, konnte die Typisierung dieser externen Module direkt in die
          Typüberprüfung von Helios miteinbezogen werden.
        </p>
        <p>
          Unmittelbar nach Ausführung des Transpilers wurden bei Components 543 und bei Helios 404 neue Typfehler durch
          den TypeScript-Compiler festgestellt. Diese mussten daraufhin manuell behoben werden, um die Typkorrektheit
          wiederherzustellen. Die Berichtigung der Typisierung vereinnahmte bei Components sieben und bei Helios acht
          Personentage. Aufgrund der prinzipiellen Unterschiede der Typsysteme von Flow und Typescript, die im
          Grundlagenteil bereits dargelegt wurden, war das Auftreten neuer Fehler zu erwarten. Wie beschrieben ist
          beispielsweise die Typinferenz und die Berechnung der Typkompatibilität (nominal versus strukturell) in
          TypeScript anders umgesetzt als bei Flow.
        </p>
        <h2 id="bewertung-der-ergebnisse-hinsichtlich-der-zielvorgabe">
          <span class="chap-number">5.2</span>Bewertung der Ergebnisse hinsichtlich der Zielvorgabe
        </h2>
        <p>
          Nachdem der Wechsel zu TypeScript vollzogen war, konnten verschiedene Auswertungen durchgeführt werden, um die
          Ergebnisse bezüglich der Zielsetzung zu bewerten. Im Folgenden sollen die in Kapitel
          <a href="#chap:analysis" data-reference-type="ref" data-reference="chap:analysis">3</a> dargelegten Vorgaben
          hinsichtlich ihrer Erfüllung untersucht werden.
        </p>
        <h3 id="goal:new-type-errors">
          <span class="chap-number">5.2.1</span>Erkennung weiterer Typ- und Programmfehler
        </h3>
        <h4 id="neu-aufgetretene-typfehler">Neu aufgetretene Typfehler</h4>
        <p>
          Das primäre Ziel der Migration zu TypeScript war es, weitere Typ- und Programmfehler im bestehenden und
          zukünftigen Quelltext der Projekte von TeamShirts aufzudecken. Nach der Übersetzung der Flow-Typisierung nach
          TypeScript wurden sowohl in Components als auch in Helios zahlreiche neue Typfehler festgestellt. Wie bereits
          ausgeführt bietet der TypeScript-Compiler die Option „<code>strict</code>“, um die Strenge der
          Typüberprüfungen deutlich zu verschärfen, indem beispielsweise die implizite Zuweisung des dynamischen Typs
          <span><code>any</code></span> verboten wird <a class="citation" href="#ref-TSC:OPTIONS">[45]</a>. Tabelle
          <a href="#tab:type-errors" data-reference-type="ref" data-reference="tab:type-errors">[tab:type-errors]</a>
          gibt einen Überblick über die Anzahl und die Art der zwölf häufigsten strikten und nicht-strikten Typfehler,
          die unmittelbar nach der Transpilierung der zwei Projekte erkannt wurden. Insgesamt wurden bei Components 608
          bzw. 543 und bei Helios 697 bzw. 404 strikte bzw. nicht-strikte Typverletzungen offengelegt. Im Folgenden soll
          näher beleuchtet werden, welche Arten von neuen Typfehlern überwiegend aufgedeckt wurden, um aufzuzeigen für
          welche Klasse von Fehlern Flow und TypeScript zu unterschiedlichen Ergebnissen kommen.
        </p>
        <p>TODO: results-type-errors</p>
        <p>
          Bei beiden Projekten treten am häufigsten Typfehler auf, die sich darauf beziehen, dass Typen einander nicht
          zuweisbar sind oder dass Typen ein referenziertes Attribut nicht beinhalten (TS2322, TS2345 bzw. TS2339). Die
          Gründe für diese Fehler sind vielfältig: Wie dargelegt unterscheiden sich Flow und TypeScript in einigen
          Aspekten wie der Typinferenz und der Betrachtung von Subtypen grundlegend, sodass hierdurch neue
          Typverletzungen entstehen können. Darüber hinaus wurden nach Ausführung des Transpilers externe
          Typdefinitionen für die eingesetzten Bibliotheken hinzugefügt, um deren korrekte Verwendung zu überprüfen.
          Weil die bestehende Typisierung von Ausdrücken nicht überall mit diesen Typdeklarationen übereinstimmt, bilden
          sich auch so neue Typfehler. Bei Helios tritt die Typverletzung TS2307, also dass ein Modul nicht gefunden
          werden kann, am öftesten auf. Dieser Fehler resultiert daraus, dass in diesem Projekt neben regulären
          TypeScript-Modulen auch andere Dateitypen wie beispielsweise SVG-Dateien importiert werden, was bei TypeScript
          normalerweise nicht möglich ist. Um eine derartige Verarbeitung weiterer Dateitypen zu realisieren, wird
          spezielle Software wie <em>Webpack</em> <a class="citation" href="#ref-WEBPACK">[102]</a> eingesetzt, die eine
          solche Modulstruktur zu statischen Ausgabedateien transformiert. Durch Anlegen einer globalen Typdeklaration
          für „Module“ derartiger Dateitypen kann diese Klasse von Typfehlern aber leicht behoben werden (vgl. Quelltext
          <a href="#code:fix-webpack-imports" data-reference-type="ref" data-reference="code:fix-webpack-imports"
            >[code:fix-webpack-imports]</a
          >). Ein weiterer häufiger Fehler ist, dass der Import von Typen aus Bibliotheken fehlschlägt, wenn sich zum
          Beispiel deren Name in TypeScript geändert hat (TS2305). Außerdem entstehen Typfehler, wenn in Flow globale
          Typen der Standardbibliothek eingesetzt werden, da diese in TypeScript vor deren Verwendung erst explizit
          importiert werden müssen (TS2304). Idealerweise sollte der Import dieser zuvor globalen Typen durch den
          Transpiler, ähnlich zu der in Abschnitt
          <a
            href="#sec:react-type-import-mapping"
            data-reference-type="ref"
            data-reference="sec:react-type-import-mapping"
            >4.3.3.1</a
          >
          beschriebenen Übersetzung der React-Typimporte, automatisch durchgeführt werden, um den Aufwand manueller
          Korrekturen nach der Transpilierung zu reduzieren. Eine weitere Art von Fehler, die vor allem bei Components
          vermehrt auftritt, betrifft die inkorrekte Typisierung von React-Komponenten (TS2605).
        </p>
        <pre><code>declare module &#39;*.svg&#39; {
  export default SVGElement;
}</code></pre>
        <h4 id="neu-erkannte-programmfehler">Neu erkannte Programmfehler</h4>
        <p>
          Ein Aspekt der Zielsetzung war auch fehlerhaftes Programmverhalten aufzudecken. Während der manuellen Behebung
          der neu aufgetreten Typverletzungen wurde deshalb untersucht, ob manche der Typfehler tatsächlich semantische
          Probleme innerhalb des Quelltexts repräsentieren. In der Tat konnten einige Programmfehler durch TypeScript
          ermittelt werden. Anhand von drei Beispielen soll im Folgenden dargelegt werden, welche Art von
          Programmfehlern dabei festgestellt wurden. Obwohl keiner der Fälle kritische Laufzeitfehler verursacht, ist es
          dennoch erstrebenswert, diese zu korrigieren, um die Codequalität insgesamt zu steigern.
        </p>
        <h5 id="zusätzliche-objektattribute-bei-funktionsargumenten">
          Zusätzliche Objektattribute bei Funktionsargumenten
        </h5>
        <p>
          Ein Beispiel für derartige Programmfehler ist der inkorrekte Aufruf von Funktionen, die ein Objekt mit
          verschiedenen Attributen als Argument erwarten. Weil Flow es standardmäßig erlaubt, dass bei Objektliteralen
          Attribute angegeben werden, die nicht durch den zugrunde liegende Objekttyp spezifiziert sind
          <a class="citation" href="#ref-FLOW:WIDTH_SUBTYPING">[103]</a>, ist der Fehler bislang unerkannt geblieben.
          TypeScript behandelt Objekttypen dagegen immer exakt, sodass zusätzliche Attribute eine Typverletzung
          darstellen und der fehlerhafte Funktionsaufruf damit aufgedeckt wird.
        </p>
        <h5 id="fehlerhafte-verwendung-von-react-komponenten">Fehlerhafte Verwendung von React-Komponenten</h5>
        <p>
          React-Komponenten werden ähnlich wie HTML-Elemente eingesetzt und sind in der Regel durch JSX-Syntax
          aufgebaut. Mittels selbstdefinierter Attribute können dabei verschiedene Eigenschaften der Komponente
          festgelegt werden. In einigen Fällen wurde von TypeScript erkannt, dass bei Komponenten Attribute angegeben
          wurden, die nicht länger bestehen. Weil React-Komponenten intern durch Objekte implementiert werden, die deren
          Struktur und Attribute beschreiben <a class="citation" href="#ref-REACT:REACT_ELEMENTS">[104]</a>, kann die
          gleiche Argumentation wie zuvor als Grund für die unterschiedliche Ergebnisse bei Flow und TypeScript
          herangezogenen werden: Da TypeScript im Gegensatz zu Flow alle Objekte stets exakt betrachtet, stellen
          zusätzliche angegebene Attribute bei Komponenten eine Typverletzung dar.
        </p>
        <h5 id="falscher-argumenttyp-bei-funktionsaufrufen">Falscher Argumenttyp bei Funktionsaufrufen</h5>
        <p>
          Zuletzt wurde festgestellt, dass der Typ mancher Funktionsargumente nicht mit dem erwarteten Typ
          übereinstimmt. Weil die Argumente im aufgetretenen Fall unmittelbar vor Weitergabe an die Funktion durch eine
          weitere Bibliotheksfunktion umgeformt werden und für diese zweite Funktion in Flow keine Typisierung vorliegt,
          wurde der Rückgabetyp hier implizit zu <span><code>any</code></span> umgeformt. Weil
          <span><code>any</code></span> jedem Typ zuweisbar ist, wurden die Rückgabewerte der Bibliotheksfunktion als
          Argument der ersten Funktion akzeptiert, obwohl die Typen in Wahrheit inkompatibel sind. Der Aufruf schlägt
          zur Laufzeit nur deshalb nicht fehl, weil der Typ des Rückgabewert mittels der dynamischen Typumwandlung von
          JavaScript implizit angepasst wird. In TypeScript wird dieser Typfehler statisch erkannt, da für die
          beteiligte Bibliothek eine externe Typdefinition hinzugefügt wurde, sodass die Inkompatibilität der Typen
          aufgedeckt wird.
        </p>
        <h4 id="fazit">Fazit</h4>
        <p>
          Es gilt hervorzuheben, dass die Typfehler nach der Migration größtenteils keine Programmfehler darstellen,
          sondern entweder auf die grundlegenden Unterschiede von Flow und TypeScript oder auf Unzulänglichkeiten der
          vorherigen Typisierung durch Flow zurückzuführen sind. Auch die Integration externer Typdefinitionen für die
          eingesetzten Bibliotheken steigerte zwar die Abdeckung der Projekte durch das Typsystem, aber gleichzeitig
          wurden hierdurch zum Teil neue Typfehler eingeführt. Dass mit dem Wechsel zu TypeScript eine hohe Zahl zuvor
          unerkannter kritischer Laufzeitfehler in den Projekten gefunden wird, war aufgrund der kontinuierlichen
          maschinellen und menschlichen Softwaretests unwahrscheinlich, da angenommen werden kann, dass fatale Fehler im
          Allgemeinen ohnehin bereits im Vorfeld entdeckt worden wären. Wie dargelegt konnten durch den Wechsel zu
          TypeScript aber dennoch einerseits einige tatsächliche unkritische Programmfehler aufgedeckt, andererseits
          allgemeine Schwächen der bisherigen Typisierung offengelegt werden. Deshalb kann die Zielsetzung insgesamt als
          erfüllt betrachtet werden.
        </p>
        <h3 id="unterstützung-externer-bibliotheken-1">
          <span class="chap-number">5.2.2</span>Unterstützung externer Bibliotheken
        </h3>
        <p>
          Die Migration zu TypeScript wurde weiterhin angestrebt, weil vermutet wird, dass hier Typdeklarationen für
          eine insgesamt größere Zahl von JavaScript-Bibliotheken vorliegen und diese aktueller sind als bei Flow. Im
          Folgenden soll beleuchtet werden, ob dies tatsächlich zutrifft. Wie ausgeführt stellen einige Projekte selbst
          Definitionsdateien mit der Typisierung bereit, bei anderen kann auf separat gepflegte Typisierungen
          zurückgegriffen werden.
        </p>
        <p>
          Für Flow und TypeScript existiert jeweils ein Projekt mit dem Ziel, Typdeklarationen für die gängigsten
          JavaScript-Bibliotheken bereitzustellen. Während seit 2012 für TypeScript das Projekt
          <em>DefinitelyTyped</em> <a class="citation" href="#ref-DEFINITELY_TYPED">[105]</a> besteht, ist 2017 für Flow
          ein vergleichbarer Ansatz namens <em>flow-typed</em>
          <a class="citation" href="#ref-FLOW_TYPED">[106]</a> entstanden. Im Allgemeinen kann angenommen werden, dass
          Bibliotheken, die ihre eigenen Typdeklarationen mitliefern, aktueller und korrekter sind, weil im Zuge der
          Veröffentlichung neuer Versionen in der Regel auch die Typisierung durch den Autor entsprechend aktualisiert
          wird<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a
          >. Bei der nachträglichen Erstellung von Typdeklarationen durch die Entwicklergemeinschaft besteht die Gefahr,
          dass die Typisierung das Verhalten der Bibliothek nicht richtig abbildet oder dass diese veralten. Deshalb
          sind Typdefinitionen, die von den Projekten selbst verwaltet werden, generell zu bevorzugen. Zunächst sollen
          DefinitelyTyped und flow-typed in Tabelle
          <a href="#tab:libdefs" data-reference-type="ref" data-reference="tab:libdefs">[tab:libdefs]</a> mittels
          verschiedener Kennzahlen allgemein verglichen werden, um die Verfügbarkeit von gemeinschaftlich gepflegten
          Typdeklarationen zu untersuchen. Wie die Zahl der Git-Commits und der Beitragenden im Jahresmittel belegen,
          weist DefinitelyTyped eine deutlich größere Aktivität als flow-typed auf. Insgesamt werden bei TypeScript in
          etwa zehn mal mehr Bibliotheken unterstützt als bei Flow, was trotz des Umstands, dass DefinitelyTyped fünf
          Jahre älter ist, einen beachtlichen Faktor darstellt.
        </p>
        <p>TODO: libdefs</p>
        <p>
          Nachfolgend wird nun die Unterstützung externer Bibliotheken anhand der 15 am häufigsten eingesetzten Pakete
          innerhalb der zwei Projekte von TeamShirts in Tabelle
          <a href="#tab:used-libraries" data-reference-type="ref" data-reference="tab:used-libraries"
            >[tab:used-libraries]</a
          >
          konkret betrachtet. Die Bibliotheken, die am öftesten verwendet werden, wurden durch statische Analyse des
          Quelltexts ermittelt, indem gezählt wurde, wie oft diese jeweils importiert werden. Für diese Auswahl wurde
          anschließend untersucht, ob einerseits für Flow und TypeScript generell Typdeklarationen bestehen,
          andererseits ob diese als Bestandteil der Bibliothek oder separat erstellt vorliegen. Weiterhin wurde
          beleuchtet, ob die Typdefinitionen der aktuellen Version des Pakets entsprechen oder veraltet sind. Dabei wird
          nur die Haupt- und Nebenversionsnummer<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"
            ><sup>33</sup></a
          >
          der Pakete betrachtet, weil die Revisionsnummer nur der Behebung von Programmfehlern dient und per Definition
          die Schnittstellen nicht verändern darf. Bei flow-typed wird die Kompatibilität der Typdefinitionen allerdings
          nur für die Hauptversion angegeben, sodass unklar ist, inwieweit die Deklarationen tatsächlich alle Funktionen
          der aktuellen Nebenversion abbilden. DefinitelyTyped differenziert hier stärker und gibt jeweils für alle
          Pakete exakte Versionsnummern an, wodurch die Aktualität besser eingeschätzt werden kann.
        </p>
        <p>TODO: results-libraries</p>
        <p>
          Während bei Flow für vier der 15 Bibliotheken keine Typdefinition vorliegt, existiert bei TypeScript lediglich
          in einem Fall keine Typisierung. Der Großteil der Deklarationen entstammt jeweils den Projekten flow-typed
          bzw. DefinitelyTyped. Nur in einem bzw. drei Fällen bei Flow bzw. TypeScript sind die Typdefinitionen direkt
          in die Pakete integriert. Für den Großteil der Bibliotheken sind die Typisierungen sowohl bei Flow als auch
          bei TypeScript aktuell. Nur bei TypeScript besteht in zwei bzw. drei Fällen eine Abweichung von der Haupt-
          bzw. Nebenversion. Aus den dargelegten Gründen kann nicht überprüft werden, ob auch bei Flow veraltete
          Typdefinitionen hinsichtlich der Nebenversion vorliegen, weil diese durch flow-typed nicht angegeben wird. Da
          bei TypeScript für die gegebenen Projekte von TeamShirts eine größere Zahl von Bibliotheken durch
          Typdeklarationen abgebildet werden und diese in höherem Maße in die Pakete integriert sind, kann die
          Zielsetzung, externe Bibliotheken besser zu unterstützen, insgesamt als erreicht betrachtet werden. Kritisch
          anzumerken ist aber, dass bei TypeScript für fünf Bibliotheken keine vollständig aktuelle Version vorliegt.
          Jedoch ist dies auch bei Flow nicht gesichert.
        </p>
        <h3 id="performance-der-typüberprüfungen-1">
          <span class="chap-number">5.2.3</span>Performance der Typüberprüfungen
        </h3>
        <h4 id="messung-der-laufzeit-der-typüberprüfungen">Messung der Laufzeit der Typüberprüfungen</h4>
        <p>
          Eine weitere Zielsetzung des Wechsels zu TypeScript war es, die Performance der Typüberprüfungen zu
          verbessern, das heißt deren Laufzeit zu verringern. Nachdem die Migration der zwei Projekte abgeschlossen war,
          konnten die Laufzeiten der vollständigen Typüberprüfung durch Flow bzw. TypeScript ermittelt werden. Auch die
          Messung der Zeitspanne von inkrementellen Überprüfungen durch den Flow- bzw. TypeScript-Sprachserver wurde
          durch Auswertung der Logdateien in Betracht gezogen. Jedoch ist dieser Ansatz nur möglich, wenn ein Editor
          ausgeführt wird, der den jeweiligen Server startet und daraufhin Anfragen bezüglich der Typisierung an diesen
          stellt. Weil die Ergebnisse somit stark von der Implementierung des Editors abhängen, besteht die Gefahr, dass
          diese verfälscht werden und wenig aussagekräftig sind. Deshalb werden inkrementelle Typüberprüfungen
          nachfolgend nicht betrachtet.
        </p>
        <p>
          Zur Bestimmung der Laufzeit der vollständigen Berechnung wurden in beiden Projekten für Flow und TypeScript
          jeweils 100 Proben (<em>Samples</em>) mit Hilfe des GNU-Programms <em>time</em>
          <a class="citation" href="#ref-GNU_TIME">[108]</a> gemessen und die zehn kleinsten und größten Werte daraufhin
          verworfen, um den Einfluss von „Ausreißern“ zu minimieren. Aus den verbleibenden 80 Werten wurde anschließend
          der Mittelwert gebildet und die Standardabweichung berechnet. Dabei wurde in allen Messungen die zum damaligen
          Zeitpunkt aktuelle Version 3.5 von TypeScript und die von TeamShirts eingesetzte Version 0.96 von Flow
          verwendet. Um auch den Einfluss von unterschiedlich leistungsfähiger Hardware miteinzubeziehen, wurden die
          Messreihen auf vier verschiedenen Systemen durchgeführt:
        </p>
        <ol>
          <li>
            AMD Phenom II X6 1055T Prozessor mit 2,9 GHz<a
              href="#fn34"
              class="footnote-ref"
              id="fnref34"
              role="doc-noteref"
              ><sup>34</sup></a
            >
            und 6 Rechenkernen (2010)<br />
            16 GB Arbeitsspeicher, Solid State Drive, Arch Linux
          </li>
          <li>
            Intel Core i5-4258U Prozessor mit 2,4 GHz und 4 Rechenkernen (2013)<br />
            8 GB Arbeitsspeicher, Solid State Drive, Arch Linux
          </li>
          <li>
            Intel Core i5-4210M Prozessor mit 2,6 GHz und 4 Rechenkernen (2014)<br />
            16 GB Arbeitsspeicher, Solid State Drive, Arch Linux
          </li>
          <li>
            Intel Core i7-6700 Prozessor mit 3,4 GHz und 8 Rechenkernen (2015)<br />
            32 GB Arbeitsspeicher, Solid State Drive, Debian Linux
          </li>
        </ol>
        <p>
          Die durch diese Methodik ermittelten Messwerte, deren Standardabweichung und die relative Veränderung der
          Laufzeiten werden in Tabelle
          <a href="#tab:performance-complete" data-reference-type="ref" data-reference="tab:performance-complete"
            >[tab:performance-complete]</a
          >
          für beide Projekte gezeigt: Offensichtlich beschleunigen modernere, performante Prozessoren mit höherer
          Taktfrequenz und größeren Caches generell die Typüberprüfung durch Flow bzw. TypeScript. Die These, dass
          TypeScript schneller als Flow sei, lässt sich aber nur anhand des Projekts Helios für die Systeme B, C und D
          belegen (vgl. negative Werte für relative Veränderung der Laufzeit). Bei Components ist TypeScript dagegen
          stets deutlich langsamer als Flow.
        </p>
        <p>TODO: results-performance</p>
        <p>
          Wie im Grundlagenteil bereits ausgeführt, wird die Berechnung der Typkorrektheit durch Flow stark
          parallelisiert, um deren Laufzeit zu verringern. TypeScript bietet keine Unterstützung für eine nebenläufige
          Typüberprüfung durch mehrere Threads <a class="citation" href="#ref-TS:NO_MULTICORE">[109]</a>, sodass die
          Performance hier vorrangig von der Leistungsfähigkeit der einzelnen Prozessorkerne abzuhängen scheint. Diese
          These wird durch die gemessenen Daten unterstützt, denn je performanter die Rechenkerne sind, desto kleiner
          wird die Differenz zwischen den Laufzeiten von Flow und TypeScript bei Components bzw. desto größer wird diese
          bei Helios. Für System D scheint jedoch die Parallelisierung von Flow aufgrund der hohen Zahl von acht
          Prozessorkernen den größeren Einfluss zu haben, als die Leistungsfähigkeit der einzelnen Kerne. Weil die
          Systeme B und C jeweils nur über vier Rechenkerne verfügen, ist der Effekt der Nebenläufigkeit hier kleiner.
          Als einen möglichen Grund, warum Components im Vergleich zu Helios durch Flow insgesamt schneller überprüft
          werden kann, kann angeführt werden, dass dieses Projekt aus einer Vielzahl unabhängiger Komponenten besteht
          deren Verarbeitung somit gut durch Flow parallelisiert werden kann. In Helios besteht eine größere
          Abhängigkeit der Module untereinander.
        </p>
        <h4 id="einfluss-von-parallelisierung-auf-die-laufzeiten">Einfluss von Parallelisierung auf die Laufzeiten</h4>
        <p>
          Der Einfluss der Parallelisierung auf die Laufzeit der Berechnungen soll im Folgenden näher beleuchtet werden.
          Hierfür wurde eine weitere Testreihe durchgeführt, in der die Zahl der einsetzbaren Rechenkerne für die
          Berechnung durch das Linux-Programm <em>taskset</em>
          <a class="citation" href="#ref-TASKSET">[110]</a> eingeschränkt wird. Dabei wird Flow bzw. TypeScript durch
          den Scheduler des Betriebssystems zunächst lediglich ein Rechenkern, dann sukzessiv immer ein weiterer
          zugeordnet. Abbildung
          <a href="#fig:plot-cores" data-reference-type="ref" data-reference="fig:plot-cores">[fig:plot-cores]</a> auf
          Seite  zeigt jeweils ein Diagramm für Components und Helios, welches die Beeinflussung des Laufzeitverhaltens
          durch diese Einschränkung grafisch darstellt. Die exakten Messwerte, deren Standardabweichung und die relative
          Veränderung werden darüber hinaus in Tabelle
          <a href="#tab:performance-cores" data-reference-type="ref" data-reference="tab:performance-cores"
            >[tab:performance-cores]</a
          >
          aufgeführt.
        </p>
        <p>TODO: results-performance-cores</p>
        <p>TODO: Plots</p>
        <p>
          Sowohl bei Flow als auch bei TypeScript wird die Laufzeit der Berechnung bereits bei Verwendung von zwei
          Rechenkernen im Vergleich zu einem einzigen Kern deutlich verringert. Obwohl TypeScript eine parallelisierte
          Kompilierung grundsätzlich nicht unterstützt, wird auch dieser Prozess beschleunigt, weil der
          TypeScript-Compiler durch Node.js ausgeführt wird und diese Umgebung standardmäßig mehrere Threads startet, um
          beispielsweise teure Ein- und Ausgabeoperationen auf weitere Prozessorkerne auszulagern
          <a class="citation" href="#ref-NODE:THREADS">[111]</a>. Für mehr als drei Kerne bleibt die Laufzeit von
          TypeScript daraufhin in beiden Projekten aber in etwa konstant. Wie die Messwerte und Diagramme zeigen,
          verringert sich die Laufzeit von Flow dagegen mit wachsender Zahl zur Verfügung stehender Rechenkerne aufgrund
          der Unterstützung von Multithreading stetig. Ab etwa fünf Kernen sind die Zugewinne allerdings nur noch
          gering, was auf den zunehmend größeren Overhead durch die notwendige Synchronisierung der Threads
          zurückgeführt werden könnte. Bei maximal möglicher Parallelisierung durch acht Kerne erreicht Flow bei Helios
          nahezu die Laufzeit von TypeScript.
        </p>
        <h4 id="fazit-1">Fazit</h4>
        <p>
          Die angestrebte Verbesserung der Performance durch die Migration zu TypeScript kann somit im vorliegenden Fall
          nur als teilweise erreicht betrachtet werden, da nur in drei Fällen bei Helios tatsächlich geringere
          Laufzeiten für eine vollständige Typüberprüfung gemessen wurden. Die stark parallelisierte Architektur von
          Flow scheint der von TypeScript bezüglich der Geschwindigkeit in den meisten Fällen überlegen. Es wird aber
          vermutet, dass die Performance von TypeScript gesteigert werden könnte, wenn auch hier die Berechnung der
          Typkorrektheit nebenläufig wäre. Laut Aussage eines Entwicklers von TypeScript im März 2019 wird die Umsetzung
          von Multithreading im TypeScript-Compiler bereits in Betracht gezogen
          <a class="citation" href="#ref-TS:MULTICORE">[112]</a>.
        </p>
        <h3 id="zukunftssicherheit-und-transparenz-der-technologie">
          <span class="chap-number">5.2.4</span>Zukunftssicherheit und Transparenz der Technologie
        </h3>
        <p>
          Das letzte Ziel der Migration zu TypeScript war schließlich die Zukunftssicherheit zu steigern, da angenommen
          wird, dass die Entwicklung von TypeScript transparenter abläuft als bei Flow. Hierzu wurden in Abschnitt
          <a href="#sec:goal:transparency" data-reference-type="ref" data-reference="sec:goal:transparency">3.2.4</a>
          verschiedene Fragestellungen aufgeworfen, die im Folgenden beantwortet werden sollen. Der erste Aspekt
          betrifft die Verfügbarkeit eines öffentlich einsehbaren Projektplans (<em>Roadmap</em>) in welchem
          strategische Entscheidungen kommuniziert werden, sodass die langfristige Weiterentwicklung der Technologie
          besser eingeschätzt werden kann. Für Flow existiert derzeit keine solche Roadmap: Eine entsprechende Anfrage
          im November 2017 auf GitHub blieb durch das Entwicklerteam von Flow unbeantwortet
          <a class="citation" href="#ref-FLOW:GITHUB:ROADMAP">[113]</a>. Ein Mitarbeiter von Facebook bestätigte aber im
          Januar 2019, dass beabsichtigt werde zukünftig einen Projektplan für Flow zu veröffentlichen
          <a class="citation" href="#ref-FLOW:GITHUB:ROADMAP_FUTURE">[114]</a>. Die Entwicklung von TypeScript ist an
          dieser Stelle deutlich transparenter: So werden auf GitHub einerseits perspektivische Ziele der
          Programmiersprache kommuniziert, andererseits konkrete Halbjahrespläne ausführlich dargelegt
          <a class="citation" href="#ref-TS:ROADMAP">[115]</a>. Benutzer von TypeScript können damit sehr gut
          beurteilen, welche Funktionen in Zukunft zu erwarten sind und wie diese priorisiert werden.
        </p>
        <p>
          Sowohl Flow als auch TypeScript werden quelloffen auf der Plattform GitHub entwickelt, sodass Benutzer die
          Möglichkeit haben, Probleme (<em>Issues</em>) zu melden und sich in die Weiterentwicklung der Systeme
          einzubringen. Um zu untersuchen, wie schnell derartige Tickets bearbeitet werden, wurden für Flow und
          TypeScript entsprechende Daten durch die Programmierschnittstelle<a
            href="#fn35"
            class="footnote-ref"
            id="fnref35"
            role="doc-noteref"
            ><sup>35</sup></a
          >
          von GitHub <a class="citation" href="#ref-GITHUB:API">[116]</a> erhoben. Anhand von 3.800 bzw. 20.000
          Einträgen von Flow und TypeScript wurde ermittelt, wie viel Zeit im Median zwischen der Erstellung und der
          Behebung eines Problemberichts vergeht: Hierbei ergibt sich für Flow ein Wert von 11,58 und für TypeScript ein
          Wert von 6,61 Tagen. Zwar muss das Schließen eines Tickets nicht in jedem Fall bedeuten, dass tatsächlich ein
          Programmfehler vorlag und dieser korrigiert wurde, dennoch kann bei TypeScript somit insgesamt eine schnellere
          Bearbeitung von gemeldeten Problemen festgestellt werden.
        </p>
        <p>
          Die letzte Fragestellung aus Abschnitt
          <a href="#sec:goal:transparency" data-reference-type="ref" data-reference="sec:goal:transparency">3.2.4</a>
          betrifft die Zukunftssicherheit von Flow bzw. TypeScript, also ob die langfristige Unterstützung der Systeme
          durch die Autoren Facebook bzw. Microsoft gewährleistet ist. Weil keine Roadmap für Flow vorliegt und bekannt
          wurde, dass selbst interne Projekte bei Facebook wie zum Beispiel <em>Jest</em>
          <a class="citation" href="#ref-SOFTWARE:JEST">[92]</a> zu TypeScript migrieren
          <a class="citation" href="#ref-JEST_TS">[117]</a>, bestand bei einigen Entwicklern Verunsicherung darüber, ob
          Facebook die Fortentwicklung des Systems weiterhin fokussiert. Diese Zweifel wurden jedoch von einem der
          Autoren von Flow, Avik Chaudhuri, im bereits erwähnten Artikel “”
          <a class="citation" href="#ref-FLOW:UPDATE_2019">[80]</a> ausgeräumt. Er betont, dass Facebook intern nach wie
          vor primär Flow einsetze und die Zukunft des Systems gesichert sei. Im Fall von TypeScript besteht wie
          ausgeführt eine öffentlich einsehbarer Projektplan, sodass von einer fortwährenden Unterstützung durch
          Microsoft ausgegangen werden kann.
        </p>
        <p>
          Zusammenfassend kann gesagt werden, dass die Migration zu TypeScript tatsächlich Vorteile bezüglich der
          Zukunftssicherheit und Transparenz bietet. Im Vergleich zu Flow besteht hier eine deutlich höhere
          Planungssicherheit bezüglich der Weiterentwicklung des Typsystems, weil eine Roadmap öffentlich zugänglich
          ist. Auch Fehlerberichte auf GitHub werden bei TypeScript insgesamt schneller bearbeitet. Die langfristige
          Unterstützung der Systeme durch die ursprünglichen Autoren ist in beiden Fällen anzunehmen.
        </p>
        <h2 id="erfüllung-der-technischen-anforderungen">
          <span class="chap-number">5.3</span>Erfüllung der technischen Anforderungen
        </h2>
        <p>
          Nachdem die Erfüllung der Zielvorgaben durch den Wechsel zu TypeScript geprüft wurden, soll im Folgenden auch
          die Einhaltung der technischen Anforderungen an den Flow-Transpiler untersucht werden.
        </p>
        <h3 id="sec:interpretation:equivalent-translation">
          <span class="chap-number">5.3.1</span>Äquivalente und vollständige Übersetzung der Flow-Typen
        </h3>
        <h4 id="äquivalenz-der-übersetzungen">Äquivalenz der Übersetzungen</h4>
        <p>
          Als erste und wichtigste technische Anforderung an den Transpiler wurde die äquivalente und vollständige
          Übersetzung der gesamten Flow-Syntax nach TypeScript definiert. Die bedeutungsgleichen TypeScript-Ausdrücke
          der verschiedenen Flow-Typen konnten dabei mehrheitlich einfach gefunden werden, weil TypeScript einen sehr
          ähnlichen Funktionsumfang wie Flow besitzt und sich oftmals nur die Schlüsselwörter unterscheiden<a
            href="#fn36"
            class="footnote-ref"
            id="fnref36"
            role="doc-noteref"
            ><sup>36</sup></a
          >. Kompliziertere, nicht offensichtliche Transformationen wurden experimentell bestimmt.
        </p>
        <pre><code>Transpiling example.js...

  1 | // @flow
&gt; 2 | const existentialType: * = String(2 * 3);
    |                       ^
  Warning: Flow&#39;s Existential Type (*) is not expressible in TypeScript.
           It will be replaced with &#39;any&#39;.
           See https://github.com/Microsoft/TypeScript/issues/14466.</code></pre>
        <p>
          Für einige, wenige Typen existiert keine absolut bedeutungsgleiche Übersetzung, da TypeScript manche der
          Funktionen von Flow nicht unterstützt. Infolgedessen kommt es hier bei der Transpilierung zwingend zu einem
          Verlust von Typinformation, was in neuen Typfehlern resultieren kann. Die inkorrekte Transformation derartiger
          Typen wird gemäß Anforderung
          <a
            href="#sec:requirement:completeness"
            data-reference-type="ref"
            data-reference="sec:requirement:completeness"
            >3.3.1</a
          >
          akzeptiert, jedoch muss der Benutzer bei Auftreten eines solchen Falls gewarnt werden. Quelltext
          <a href="#code:transpiler-warnings" data-reference-type="ref" data-reference="code:transpiler-warnings"
            >[code:transpiler-warnings]</a
          >
          zeigt wie eine solche Warnung aufgebaut ist. Dabei wird einerseits die genaue Position des verursachenden
          Flow-Typs im Quelltext angegeben, andererseits wird der Benutzer über die Hintergründe der Warnung durch einen
          Link informiert. Nachfolgend wird dargelegt, welche der Funktionen von Flow nicht absolut korrekt übersetzt
          werden können und wie dies jeweils innerhalb des Transpilers gehandhabt wird.
        </p>
        <ul>
          <li>
            In TypeScript existiert kein Typ, der Flows <em>Existential type</em> entspricht
            <a class="citation" href="#ref-TS:GITHUB:NO_EXISTENTIAL_TYPE">[118]</a>. Wie Quelltext
            <a href="#code:transpiler-warnings" data-reference-type="ref" data-reference="code:transpiler-warnings"
              >[code:transpiler-warnings]</a
            >
            bereits andeutet, wird dieser Typs deswegen durch den Typ <em>any</em> ersetzt. Weil <em>any</em> Supertyp
            jeden Typs ist, geht damit Typinformation verloren, sofern Flow zuvor einen konkreteren Typ inferieren
            konnte. Jedoch gibt die Dokumentation von Flow an, dass dies oftmals nicht funktioniert und der
            <em>Existential type</em> deshalb in diesen Fällen ohnehin äquivalent zu <em>any</em> ist
            <a class="citation" href="#ref-FLOW:LINT_RULE_REFERENCE">[99]</a>.
          </li>
          <li>
            Durch eckige Klammern kann in Objekttypen ein Index, also die Abbildung eines Typs von Namen auf Werte eines
            anderen Typs, angegeben werden<a href="#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"
              ><sup>37</sup></a
            >. Flow unterstützt hierbei jeden beliebigen Typ für die Attributnamen, TypeScript hingegen nur
            <span><code>string</code></span> und <span><code>number</code></span>
            <a class="citation" href="#ref-TS:HANDBOOK:INTERFACES">[119]</a>. Infolgedessen entfernt der Transpiler
            Index-Signaturen, die von diesen zugelassenen Typen abweichen, und fügt stattdessen jeweils eine Signatur
            für <span><code>string</code></span> und <span><code>number</code></span> ein, um die größtmögliche Menge
            von Schlüsseltypen zu erlauben.
          </li>
          <li>
            Auch opake Typen werden durch TypeScript nicht unterstützt
            <a class="citation" href="#ref-TS:GITHUB:NO_OPAQUE_TYPE">[81]</a>. Deshalb wird dieser Typ bei der
            Übersetzung durch ein Typalias ersetzt, das auf den gleichen Typ verweist.
          </li>
          <li>
            Flow ermöglicht es, den Rückgabewert von Konstruktorfunktionen explizit anzugeben. Dies ist in TypeScript
            bewusst verboten, weil es im Allgemeinen als schlechter Programmierstil gilt, wenn ein Konstruktor etwas
            anderes als eine Klasseninstanz zurückliefert
            <a class="citation" href="#ref-TS:GITHUB:CONSTRUCTOR_RETURN_TYPE">[120]</a>. Ein solcher Rückgabewert wird
            deswegen durch den Transpiler entfernt, damit keine fehlerhafte TypeScript-Syntax entsteht.
          </li>
          <li>
            Ein letzter Aspekt von Flow, der in TypeScript in einigen Fällen nicht abbildbar ist, ist die Varianz von
            Typen. Weil die Syntax von TypeScript nur Kovarianz (Schlüsselwort <span><code>readonly</code></span
            >) unterstützt, werden die Varianz-Signaturen von Flow für alle anderen Fälle verworfen. Dies beinhaltet
            neben Objektattributen beispielsweise auch Typparameter, die in Flow entsprechend annotiert werden können.
          </li>
        </ul>
        <p>
          Neben diesen Flow-Funktionen, die prinzipiell nicht bedeutungsgleich übersetzt werden können, konnte darüber
          hinaus für die drei Hilfstypen <em>Object map</em>, <em>Object map with key</em> und <em>Tuple map</em>, wie
          ausgeführt, kein TypeScript-Ausdruck gefunden werden, der diesen entspricht. Deshalb ist die äquivalente
          Transformation der Typisierung auch in diesen drei Fällen nicht gegeben, weil diese Typen durch
          <em>any</em> ersetzt werden. Jedoch kann angenommen werden, dass diese Hilfstypen in der Regel nur einen
          kleinen Teil der Typisierung ausmachen, sodass der Verlust von Typinformation insgesamt gering ist. Abgesehen
          von den beschriebenen Ausnahmen wurde die Äquivalenz der Übersetzungen damit erreicht.
        </p>
        <h4 id="vollständigkeit-der-transformationen">Vollständigkeit der Transformationen</h4>
        <p>
          Wie bereits in Abschnitt
          <a
            href="#sec:requirement:completeness"
            data-reference-type="ref"
            data-reference="sec:requirement:completeness"
            >3.3.1</a
          >
          dargelegt ist der vollständige Funktionsumfang der Implementierung durch die Spezifikation des Parsers
          <a class="citation" href="#ref-BABEL:PARSER_SPEC">[66]</a> von Babel präzise definiert, weil das Dokument
          genau festlegt, welche Knoten des abstrakten Syntaxbaums Flow-Syntax darstellen. Sofern sämtliche dieser
          Elemente korrekt in ihr TypeScript-Gegenstück transformiert werden, ist die Vollständigkeit erzielt. Dies
          setzt vorraus, dass der abstrakte Syntaxbaum von Babel tatsächlich jegliche Flow-Syntax abbildet. Es konnte
          kein Beleg dafür gefunden werden, dass diese Annahme falsch ist.
        </p>
        <p>
          Ein weiterer Aspekt, der zur Erzielung einer vollständigen Umsetzung beiträgt, ist die Typisierung von Babel,
          da diese zum Beispiel den Vereinigungstyp <span><code>Flow</code></span> bereitstellt, der alle Knotentypen
          von Flow umfasst <a class="citation" href="#ref-BABEL:TYPES">[67]</a>. Somit kann durch eine geeignete
          Typisierung statisch überprüft werden, ob das Programm alle Elemente eines solchen Vereinigungstyps
          verarbeitet. Auch hier muss die Vorraussetzung gelten, dass die Typisierung von Babel bezüglich Flow korrekt
          ist. Der umgesetzte Transpiler verwendet diesen Ansatz beispielsweise innerhalb der zentralen
          Umwandlungsfunktion für beliebige Flow-Typen (<span><code>convertFlowType</code></span
          ><a href="#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a
          >), sodass statisch garantiert werden kann, dass dabei ausnahmslos alle Elemente des Vereinigungstyps
          <span><code>FlowType</code></span> transformiert werden.
        </p>
        <p>
          Die Erzielung der Korrektheit und Vollständigkeit der Transformationen wird durch den in Abschnitt
          <a href="#sec:tdd" data-reference-type="ref" data-reference="sec:tdd">4.2.1</a> dargelegten Ansatz der
          testgetriebenen Entwicklung gewährleistet. In der Dokumentation von Flow
          <a class="citation" href="#ref-FLOW:TYPE_ANNOTATIONS">[38]</a> wird die Syntax aller Sprachkonstrukte
          beschrieben, sodass bekannt ist, welche Typen prinzipiell möglich sind. Durch Anlegen von Fixture-Dateien kann
          damit die korrekte Übersetzung sämtlicher Flow-Funktionen umfangreich getestet werden. Wie ausgeführt sind
          insgesamt 1022 Testfälle entstanden, um alle Basis- und Hilfstypen sowie Typdeklarationen zu überprüfen. Durch
          eine hohe Testabdeckung von 93% wird darüber hinaus sichergestellt, dass die verschiedenen
          Programmverzweigungen des Transpilers tatsächlich die angestrebte Funktionalität umsetzen. Die Vollständigkeit
          der Programmtransformation wurde somit erreicht.
        </p>
        <h4 id="vergleich-mit-ansätzen-von-kikura-und-barabash">Vergleich mit Ansätzen von Kikura und Barabash</h4>
        <p>
          Die zwei betrachteten Aspekte der Äquivalenz und Vollständigkeit der Transformationen sollen auch für die
          Ansätze von Kikura und Barabash beleuchtet werden, um das erzielte Ergebnis einzuordnen. Dabei wird
          untersucht, ob diese Plugins bei Anwendung auf die angelegten Fixture-Tests zur Erprobung der korrekten
          Übersetzung der Flow-Typisierung zu den gleichen Ergebnissen kommen. Tabelle
          <a href="#tab:correctness-comparison" data-reference-type="ref" data-reference="tab:correctness-comparison"
            >[tab:correctness-comparison]</a
          >
          zeigt, bei welchen Testfälle hierbei eindeutig eine fehlerhafte Transformation vorgenommen wird. Darunter wird
          einerseits die semantisch inkorrekte Übersetzung eines Typs, andererseits unzulässige TypeScript-Syntax in der
          Ausgabe verstanden. Eine solche invalide Syntax entsteht beispielsweise dann, wenn Spezialfälle nicht richtig
          behandelt werden. Weil sich die Tabelle am Aufbau der Fixture-Tests orientiert, werden nicht alle einzelnen
          Typen wie in Kapitel
          <a href="#chap:basics" data-reference-type="ref" data-reference="chap:basics">2</a> separat, sondern
          gruppiert, aufgelistet. Die Kategorie „<em>Primitives</em>“ enthält dabei zum Beispiel die Tests für alle
          primitiven Flow-Typen wie <em>Number type</em>, <em>String literal type</em> et cetera.
        </p>
        <p>TODO: results-correctness-comparison</p>
        <p>
          Die Übersetzung der Flow-Typen durch Kikura ist in 98,1% der Fälle korrekt. Jedoch können dabei nur 17 der 31
          Testfälle überhaupt betrachtet werden, weil die Transpilierung der verbleibenden 14 Eingabedateien gänzlich
          fehlschlägt, da hier jeweils Laufzeitfehler auftreten (Symbol ). Somit ist nicht nachvollziehbar, ob eventuell
          weitere Fehler vorliegen. Auch bei Barabash stürzt das Programm bei drei der Fixture-Dateien ab, sodass diese
          Tests nicht bewertet werden können. In 89,0% der anderen Fälle wird die Transformation hier aber korrekt
          umgesetzt. Die Gründe, warum die Übersetzungen bei Kikura und Barabash in einigen Fällen falsch sind, sind
          vielfältig. Im Folgenden werden einige der Ursachen aufgelistet:
        </p>
        <ul>
          <li>
            Wie ausgeführt dürfen Konstruktoren in TypeScript keine Rückgabewerte deklarieren. Sofern diese, wie hier
            bei Barabash, nicht entfernt werden, entsteht ein Syntaxfehler.
          </li>
          <li>
            Flow erlaubt es, Funktionsparameter, die mit einem Standardwert
            <a class="citation" href="#ref-MDN:DEFAULT_PARAMS">[121]</a> initialisiert werden, als optional zu
            markieren<a href="#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a
            >. Derartige Parameter dürfen in TypeScript nicht optional sein, sodass die Notation durch den Transpiler
            entsprechend angepasst werden muss.
          </li>
          <li>
            Bei Barabash wird der <em>Nullable type</em> (<em>Maybe type</em>) falsch übersetzt. Statt der Vereinigung
            aus dem angegeben Typ, <span><code>null</code></span> und <span><code>undefined</code></span> wird hier der
            Typ lediglich mit <span><code>null</code></span> kombiniert.
          </li>
          <li>
            Kikura wandelt opake Typen wie die vorliegende Umsetzung in reguläre Typaliase um. Jedoch werden dabei
            bestehende Typparameter verworfen.
          </li>
          <li>
            Schließlich werden bei beiden Ansätzen einige der Hilfstypen überhaupt nicht transformiert und einfach in
            die Ausgabe übernommen. Weil diese Typen in TypeScript undefiniert sind, entsteht auch so ein Fehler.
          </li>
        </ul>
        <p>
          Insgesamt treten bei Kikura zwar weniger fehlerhafte Transformationen als bei Barabash auf, aber das Plugin
          stürzt auch bei fast der Hälfte der Eingabedateien ab, was darauf hindeutet, dass noch viele Spezialfälle
          außer Acht gelassen wurden. Der Ansatz von Barabash ist hier bedeutend stabiler, jedoch wurden in Summe mehr
          Fehler aufgedeckt. Da hier allerdings auch deutlich mehr Testfälle untersucht werden konnten (161 bei Kikura
          versus 466 bei Barabash), ist dies zu erwarten. Zusammenfassend lässt sich sagen, dass beide Ansätze offenbar
          viele Grenzfälle der Übersetzung derzeit noch nicht korrekt behandeln, sodass verschiedene semantische und
          syntaktische Probleme in der Ausgabe entstehen. Die vorliegende Implementierung transformiert dagegen alle
          Testfälle richtig.
        </p>
        <h4 id="fazit-2">Fazit</h4>
        <p>
          Durch die Fixture-Tests konnten sowohl die Korrektheit, als auch die Vollständigkeit der Übersetzung der
          Flow-Typen nach TypeScript überprüft werden. Jedoch setzt dies voraus, dass die Testfälle tatsächlich einen
          Großteil der möglichen Typisierung durch Flow abbilden. Obwohl die Tests mit großer Sorgfalt angelegt wurden,
          kann nicht ausgeschlossen werden, dass gewisse Fälle nicht bedacht wurden. In Anbetracht dessen, dass die
          Testfälle aber bei den zum Vergleich herangezogenen Ansätzen von Kikura und Barabash noch viele Schwachstellen
          offengelegt haben, kann angenommen werden, dass diese zumindest den wesentlichen Teil der Szenarien abdecken.
          Auch die erfolgreiche praktische Anwendung des umgesetzten Transpilers auf die Projekte von TeamShirts deutet
          stark darauf hin, dass sowohl die Semantik als auch die Syntax der Flow-Typen korrekt nach TypeScript
          überführt wird. Die Äquivalenz der Transformationen ist dabei wie beschrieben nur in einzelnen Fälle nicht
          gegeben.
        </p>
        <h3 id="semantisch-äquivalente-transpilierung-des-quelltexts">
          <span class="chap-number">5.3.2</span>Semantisch äquivalente Transpilierung des Quelltexts
        </h3>
        <p>
          Eine weitere wichtige Anforderung an den Transpiler ist, dass die Semantik des ursprünglichen
          JavaScript-Programms durch die Übersetzung nicht verändert werden darf, damit keine neuen Programmfehler in
          den Quelltext eingeschleust werden. Die korrekte Übersetzung der Semantik der Flow-Typen wurde bereits im
          vorherigen Abschnitt behandelt. Hierbei ist anzumerken, dass die statische Typisierung aber ohnehin keinen
          Einfluss auf die Semantik des Programms zur <em>Laufzeit</em> hat, weil die Typen vor der Auslieferung
          vollständig entfernt werden. Dies setzt vorraus, dass die Programm-Transformation tatsächlich nur die
          Typisierung adressiert und keine unbeabsichtigte Nebenwirkung, wie zum Beispiel das Einfügen neuer Anweisungen
          in das Programm, hat. Ein weiterer Aspekt des umgesetzten Transcompilers, der zu abweichender Semantik führen
          könnte, sind die in Abschnitt
          <a href="#sec:optimizations" data-reference-type="ref" data-reference="sec:optimizations">4.3.3</a>
          beschriebenen optionalen Optimierungen der Ausgabe. Durch die Option „<code>replace-decorators</code>“ werden
          beispielsweise Dekoratoren in bedeutungsgleiche verschachtelte Funktionsaufrufe umgewandelt. Die Einhaltung
          dieser Einschränkungen wurde wie ausgeführt durch die Fixture-Tests überprüft.
        </p>
        <p>
          Ein formaler Beweis der semantischen Äquivalenz ist aufgrund des Umfangs der zwei migrierten Projekte nicht
          durchführbar. Jedoch kann durch Betrachtung der bestehenden Modultests die Beibehaltung der Programmwirkung
          nach der Übersetzung zumindest approximativ verifiziert werden. Kritisch anzumerken ist, dass dieser Ansatz
          nur bei einer entsprechend hohen Testabdeckung aussagekräftig ist. Während diese bei Components bei 90,5%
          liegt, wird bei Helios nur ein Anteil von 18,0% erreicht. Nachdem alle nicht-strikten Typfehler in beiden
          Projekten korrigiert worden sind, wurden die Modultests beider Projekte ausgeführt. Keiner der 373 Tests von
          Components und 326 Tests von Helios schlug dabei fehl, sodass die semantisch korrekten Überführung des
          ursprünglichen Quelltexts nach TypeScript zumindest für das Projekt Components wahrscheinlich ist. Bei der
          praktischen Erprobung der zwei Projekte wurde allerdings in vier Fällen ein fehlerhaftes Verhalten der
          Webanwendung festgestellt. Jedoch konnte jedes dieser Probleme auf eine fehlerhafte händische Korrektur neuer
          Typfehler zurückgeführt werden. Es wird somit angenommen, dass der Transpiler die Semantik durch die
          Übersetzung tatsächlich beibehält und nur wo nötig, zum Beispiel bei nicht unterstützten Flow-Typen,
          modifiziert.
        </p>
        <h3 id="unterstützung-aktueller-und-vorläufiger-javascript--sowie-jsx-syntax">
          <span class="chap-number">5.3.3</span>Unterstützung aktueller und vorläufiger JavaScript- sowie JSX-Syntax
        </h3>
        <p>
          Die Anforderung aktuelle und vorläufige JavaScript- sowie JSX-Syntax zu unterstützen war eines der
          grundlegenden Kriterien, anhand derer in Abschnitt
          <a href="#sec:js-transpilers" data-reference-type="ref" data-reference="sec:js-transpilers">2.3.2</a>
          verschiedene Parser, Codegeneratoren und Transpiler bezüglich ihrer Eignung als Basis für die Umsetzung des
          Flow-Transpilers verglichen wurden. Wie dort bereits ausgeführt ist Babel nach Kenntnisstand des Autors das
          einzige Werkzeug, das sowohl jegliche aktuelle als auch vorläufige JavaScript-Syntax einlesen und verarbeiten
          kann. Deshalb wurde der umgesetzte Transpiler auf Basis von Babel implementiert, um diese Anforderung zu
          erfüllen. Wie die erfolgreich durchgeführte Transpilierung der zwei Projekte von TeamShirts beweist, ist die
          Verarbeitung derartiger Syntax tatsächlich möglich.
        </p>
        <p>
          Auch hier sollen die Ansätz von Kikura und Barabash bezüglich dieser Anforderung untersucht werden, um die
          Ergebnisse zu vergleichen. Beide Projekte wurden wie die vorliegende Implementierung als Babel-Plugin
          umgesetzt, sodass aktuelle ECMAScript-Syntax vollständig unterstützt wird. Darüber hinaus ermöglichen beide
          Projekten die Verarbeitung von JSX-Syntax und der vorläufigen Erweiterungen
          <em>Class field declarations for JavaScript</em>
          <a class="citation" href="#ref-ES_PROPOSAL:CLASS_FIELDS">[83]</a> und <em>Dynamic imports</em>
          <a class="citation" href="#ref-ES_PROPOSAL:DYNAMIC_IMPORTS">[95]</a>. Klassendekoratoren werden jedoch von
          keinem der Ansätzen unterstützt, weshalb Dateien, die derartige Syntax verwenden, nicht transpiliert werden
          können. Darüber hinaus wurde festgestellt, dass bestimmte korrekte Flow-Syntax in Objekttypen bei Barabash zu
          Laufzeitfehlern führt, weil offenbar in diesen Fällen Knoten des abstrakten Syntaxbaums fehlerhaft
          transformiert werden<a href="#fn40" class="footnote-ref" id="fnref40" role="doc-noteref"><sup>40</sup></a
          >. Auch bei Kikura treten bei Verwendung mancher Flow-Notationen wie zum Beispiel bei der expliziten
          Typumwandlung vereinzelt Syntaxfehler auf. Die vollständige Verarbeitung der Codebasis der zwei Projekte von
          TeamShirts wäre somit mit den Ansätzen von Kikura und Barabash nicht möglich.
        </p>
        <h3 id="verarbeitung-gesamter-projektverzeichnisse">
          <span class="chap-number">5.3.4</span>Verarbeitung gesamter Projektverzeichnisse
        </h3>
        <p>
          Wie in Abschnitt
          <a href="#sec:cli-program" data-reference-type="ref" data-reference="sec:cli-program">4.4</a> bereits
          ausführlich dargelegt wurde der Transpiler um ein Kommandozeilenprogramm erweitert, um die Anforderung der
          Verarbeitung gesamter Verzeichnisse zu realisieren. Die Anwendung erwartet dabei eine oder mehrere Dateien
          bzw. Verzeichnisse als Argument und setzt daraufhin die Übersetzung dieser Eingaben mit Hilfe des
          Babel-Plugins um. Durch die interne Verwendung der Bibliothek <em>Glob</em>
          <a class="citation" href="#ref-NPM:GLOB">[122]</a> können hierbei beliebig komplexe Wildcard-Muster (<em
            >glob patterns</em
          >) verarbeitet werden, um bestimmte Datei- oder Verzeichnistypen ein- und auszuschließen. Die Glob-Notation
          ähnelt regulären Ausdrücken in einigen Aspekten konzeptionell, sodass auch die Angabe komplizierterer Muster
          wie beispielsweise die Negation von Ausdrücken oder die Angabe einer Gruppe von alternativen Werten möglich
          ist <a class="citation" href="#ref-MAN:GLOB">[123]</a>. Die in Abschnitt
          <a
            href="#sec:requirement:batch-processing"
            data-reference-type="ref"
            data-reference="sec:requirement:batch-processing"
            >3.3.4</a
          >
          definierten Anforderungen, dass einerseits Verzeichnisse rekursiv verarbeitet werden, andererseits die Menge
          der zu übersetzenden Dateien flexibel eingegrenzt werden können muss, wurden somit erfüllt.
        </p>
        <p>
          Von den zwei zum Vergleich betrachteten Ansätzen, ermöglicht lediglich der Flow-Transpiler von Barabash die
          Übersetzung ganzer Projektverzeichnisse durch ein integriertes Kommandozeilenprogramm
          <a class="citation" href="#ref-BARABASH:FLOW_TO_TS">[79]</a>. Das Babel-Plugin von Kikura bietet eine solche
          Funktionalität nicht.
        </p>
        <h3 id="sec:results-formatting">
          <span class="chap-number">5.3.5</span>Beibehaltung der Quelltextformatierung
        </h3>
        <h4 id="ergebnisse">Ergebnisse</h4>
        <p>
          Die letzte technische Anforderung an den Transpiler ist die möglichst originalgetreue Formatierung der
          Ausgabe. Weil diese bei Verwendung des Babel-Codegenerators aus den dargelegten Gründen nicht ohne Weiteres
          umsetzbar ist, wurde eine Formatierungsroutine auf Basis des Werkzeugs Prettier
          <a class="citation" href="#ref-SOFTWARE:PRETTIER">[101]</a> implementiert. Mittels händischer Überprüfung des
          erzeugten TypeScript-Codes der zwei Projekte von TeamShirts, wurden inkorrekt formatierte Dateien ermittelt.
          Hierunter werden Dateien verstanden, in denen Ausdrücke, mit Ausnahme von Objektliteralen, anders als im
          ursprünglichen Quelltext umgebrochen oder Leerzeilen und Kommentare falsch platziert werden. Sobald eines
          dieser Kriterien vorliegt, wird die Formatierung als fehlerhaft betrachtet.
        </p>
        <p>
          Tabelle
          <a href="#tab:results-formatting" data-reference-type="ref" data-reference="tab:results-formatting"
            >[tab:results-formatting]</a
          >
          zeigt die Ergebnisse dieser manuellen Überprüfung. Dabei werden die erreichten Werte der vorliegende
          Implementierung dem Ansatz von Barabash
          <a class="citation" href="#ref-BARABASH:FLOW_TO_TS">[79]</a> gegenüber gestellt, um die Zahlen besser
          einordnen zu können. Das Babel-Plugin von Kikura
          <a class="citation" href="#ref-KIKURA:FLOW_TO_TS">[77]</a> bietet keine Möglichkeit, die Ausgabe zu
          formatieren und wird daher nicht in den Vergleich miteinbezogen. Wie die Tabelle zeigt, schlägt das Verfahren
          sowohl in der vorliegenden Umsetzung als auch bei Barabash in einigen Fällen fehl. Jedoch erzielt die in
          dieser Arbeit implementierte Formatierungsroutine insgesamt bessere Ergebnisse: Während hier in Summe 32
          Dateien (4,7%) fehlerhaft formatiert werden, liegt der Anteil bei Barabash bei 48 Dateien (7,0%).
        </p>
        <p>TODO: results-formatting</p>
        <h4 id="fehleranalyse">Fehleranalyse</h4>
        <p>
          Zur Feststellung der Ursachen der fehlerhaften Formatierung durch den in dieser Arbeit umgesetzten Transpiler,
          wurde die Verarbeitung der inkorrekt ausgegebenen Dateien untersucht. Weil das Verfahren zeilenbasiert
          arbeitet, ist die Konsistenz der Umbrüche für das Gelingen der Formatierung entscheidend, da es andernfalls zu
          einem Versatz der betrachteten Eingabe- und Ausgabgezeilen kommt. Die Betrachtung der Originaldateien, welche
          fehlerhaft formatiert wurden, hat gezeigt, dass dies in Folge von bestimmter, eher selten vorkommender
          Quelltextformatierung auftritt. Nachfolgend soll das Problem anhand eines Beispiel für einen solchen Fall
          veranschaulicht werden:
        </p>
        <pre><code>if (
  a &amp;&amp;
  b &amp;&amp;    // Kommentar, der Zweck von &#39;b&#39; beschreibt
  c === 0 // Kommentar, der Zweck von &#39;c&#39; beschreibt
) {
  // ...
}</code></pre>
        <p>
          Der boolesche Ausdruck, der als Argument der bedingten Anweisung in Zeile 1 dient, wird mehrmals umgebrochen,
          damit der Zweck der einzelnen Elemente durch einen Zeilenkommentar erläutert werden kann. Der umgesetzte
          Flow-Transpiler ignoriert Kommentare der Eingabe bei Generierung der TypeScript-Ausgabe generell, weil Babel
          diese wie ausgeführt ohnehin zum Teil falsch platziert. Erst durch die Formatierungsroutine werden die
          Kommentare im Nachgang wieder eingefügt, um deren korrekte Positionierung zu erzielen. Diese schlägt für das
          Beispiel fehl, weil der boolesche Ausdruck in der erzeugten Ausgabe aufgrund der entfernten Kommentare nicht
          länger umgebrochen wird (vgl. Quelltext
          <a href="#code:wrong-formatting:ts" data-reference-type="ref" data-reference="code:wrong-formatting:ts"
            >[code:wrong-formatting:ts]</a
          >). Da der Zeilenumbruch in der Ein- und Ausgabe in diesem Fall somit inkonsistent ist, scheitert die
          Übertragung der Formatierung beim Vergleich dieser und aller nachfolgenden Zeilen.
        </p>
        <pre><code>if (foo &amp;&amp; bar &amp;&amp; baz === 0) {
  // ...
}</code></pre>
        <p>
          Wie die weitere Fehleranalyse gezeigt hat, ergibt sich bei der Auflistung der formalen Parameter von
          Funktionen die gleiche Problematik, wenn diese analog zum Beispiel umgebrochen werden. Zur Lösung dieser
          fehlerhaften Fälle sollte die angepasste Version von Prettier so erweitert werden, dass auch das Argument
          bedingter Anweisungen und die Auflistung von Parametern stets umgebrochen werden.
        </p>
        <h4 id="fazit-3">Fazit</h4>
        <p>
          Zwar konnte die originalgetreue Formatierung nicht vollständig umgesetzt werden, weil nicht alle
          Ausgabedateien korrekt formatiert werden, dennoch wurde der Programmierstil in 95,3% der Fälle akkurat
          beibehalten. Da die manuelle Korrektur der insgesamt 32 fehlerhaften Dateien mit geringem Zeitaufwand von
          wenigen Stunden durchführbar ist, kann die geforderte Funktion damit als größtenteils erfüllt betrachtet
          werden.
        </p>
      </section>
      <section>
        <h1 id="chap:conclusion"><span class="chap-number">6</span>Schlussbetrachtung</h1>
        <h2 id="zusammenfassung-der-ergebnisse"><span class="chap-number">6.1</span>Zusammenfassung der Ergebnisse</h2>
        <p>
          In der vorliegenden Masterarbeit wurde die Fragestellung behandelt, wie das statische Typsystem Flow
          <a class="citation" href="#ref-FLOW:PAPER">[1]</a> nach TypeScript
          <a class="citation" href="#ref-TYPESCRIPT:SPEC">[2]</a> übersetzt werden kann, um eine derartige Migration von
          JavaScript-Quelltexten zu automatisieren. Hierfür wurde ein Transpiler auf Grundlage von Babel entwickelt, mit
          dessen Hilfe zwei Projekte des Unternehmens Spreadshirt erfolgreich nach TypeScript übertragen wurden.
        </p>
        <p>
          Zu Beginn wurden verschiedene technische Anforderungen an den Transpiler erarbeitet, die dessen
          Funktionsumfang festlegen: Dieser soll in der Lage sein, jegliche Flow-Syntax korrekt in äquivalente
          TypeScript-Ausdrücke zu übersetzen. Die Äquivalenz der Übersetzungen wurde größtenteils umgesetzt, jedoch
          existieren, wie beschrieben, einerseits Typen, die grundsätzlich nicht bedeutungsgleich nach TypeScript
          überführt werden können, andererseits konnte für drei Hilfstypen von Flow kein äquivalenter
          TypeScript-Ausdruck gefunden werden. Die Erzielung sowohl der Vollständigkeit als auch der Korrektheit der
          Transformationen wurde durch Fixture-Tests überprüft. Weiterhin wurde vorgegeben, dass die Ausführung des
          Transpilers die Semantik des Eingabeprogramms nicht verändern darf, damit keine neuen Programmfehler in die
          Ausgabe eingeführt werden. Mit Hilfe der bestehenden Modultests der zwei Projekte wurde näherungsweise
          gezeigt, dass der Transcompiler die Semantik des Programms tatsächlich nur wo nötig verändert. Auf Grundlage
          der Rahmenbedingungen innerhalb des Unternehmens wurde außerdem spezifiziert, dass der Transpiler aktuelle
          JavaScript-Syntax gemäß des ECMAScript-Standards 2019
          <a class="citation" href="#ref-ECMASCRIPT:2019">[17]</a>, bestimmte vorläufige Spracherweiterungen wie zum
          Beispiel Klassendekoratoren und JSX-Syntax unterstützen muss. Durch den Einsatz von Babel und verschiedenen
          vorgegebenen Plugins wurde diese Anforderung vollständig erreicht. Zuletzt muss der Transpiler zum einen
          gesamte Projektverzeichnisse verarbeiten können, zum anderen eine originalgetreue Formatierung der Ausgabe
          ermöglichen. Beide Vorgaben wurden durch die Umsetzung eines Kommandozeilenprogramms, das die geforderte
          Funktionen implementiert, erfüllt. Allerdings konnte gezeigt werden, dass die Formatierung bei den zwei
          migrierten Projekten nur für 95,3% der Dateien präzise beibehalten wurde.
        </p>
        <p>
          Mit dem Wechsel des statischen Typsystems wurden verschiedene Ziele verfolgt, die in Absprache mit dem
          Unternehmen definiert wurden: So sollten Typ- und Programmfehler im bestehenden Programmcode aufgedeckt und
          deren Erkennung in Zukunft vereinfacht werden. Nach der Migration wurden in beiden Projekten zahlreiche
          Typverletzungen durch TypeScript erkannt. Der Großteil dieser neu aufgetretenen Fehler kann auf die
          ausgeführten grundlegenden Unterschiede von Flow und TypeScript, die Integration externer Typdeklarationen für
          Bibliotheken und auf Unzulänglichkeiten der vorherigen Flow-Typisierung zurückgeführt werden. Durch einen
          kleinen Teil der Typverletzungen wurden aber tatsächlich bisher unerkannte unkritische Programmfehler
          offengelegt. Weiterhin wurde durch die Migration angestrebt, die Unterstützung für externe
          Softwarebibliotheken durch das Typsystem zu verbessern. Diese Zielsetzung wurde erreicht: Wie gezeigt bestehen
          bei TypeScript Typdefinitionen für etwa zehn mal mehr Bibliotheken als bei Flow. Jedoch konnten bei der
          konkreten Betrachtung einer Auswahl der meistverwendesten Pakete in den zwei Projekten von Spreadshirt nur
          geringfügige Vorteile bei TypeScript hinsichlicht der Aktualität und der Qualität der Typdeklarationen
          festgestellt werden. Das dritte Ziel, die Steigerung der Performance der Typüberprüfungen, wurde nur teilweise
          erreicht. Nur in Einzelfällen konnte im Projekt Helios bei TypeScript eine geringere Laufzeit der
          vollständigen Berechnungen der Typkorrektheit gegenüber Flow gemessen werden. Aufgrund von technischen
          Einschränkungen, welche die Messung verfälscht hätten, konnte die Dauer von inkrementellen Typüberprüfungen in
          dieser Arbeit nicht untersucht werden. Grundsätzlich scheint die stark parallelisierte Architektur von Flow
          der von TypeScript bezüglich der Performance überlegen. Zuletzt wurden durch den Wechsel zu TypeScript
          Vorteile hinsichtlich der Zukunftssicherheit der Technologie erwartet. In der Tat wird TypeScript im Vergleich
          zu Flow offener entwickelt, gemeldete Programmfehler werden im Allgemeinen schneller bearbeitet und die
          Kommunikation ist weitaus transparenter. Da bei TypeScript regelmäßig detaillierte Projektpläne veröffentlicht
          werden, besteht hier eine insgesamt größere Zukunftssicherheit bezüglich der Weiterentwicklung des Systems.
        </p>
        <p>
          Zur Einordnung der Ergebnisse wurden die Ansätze von Kikura
          <a class="citation" href="#ref-KIKURA:FLOW_TO_TS">[77]</a> und Barabash
          <a class="citation" href="#ref-BARABASH:FLOW_TO_TS">[79]</a> zur Transpilierung von Flow nach TypeScript
          herangezogen. Dabei konnte nachgewiesen werden, dass bei Kikura und Barabash 54,8% bzw. 9,7% der
          Fixture-Dateien zur Erprobung der korrekten Übersetzung aufgrund von Laufzeitfehlern überhaupt nicht
          verarbeitet werden können und in 1,9% bzw. 11,0% der anderen Testfälle nicht äquivalente Transformationen
          auftreten. Weiterhin wurde aufgezeigt, dass beide Ansätze auch bei bestimmter valider Flow-Syntax infolge von
          Programmfehlern abstürzen. Barabash ermöglicht wie der umgesetzte Transpiler die Verarbeitung ganzer
          Projektverzeichnisse. Allerdings wurden hier schlechtere Ergebnisse hinsichtlich der Formatierung der Ausgabe
          festgestellt (4,7% bzw. 7,0% Fehlerrate).
        </p>
        <p>
          Zusammenfassend kann die Migration zu TypeScript bei Spreadshirt als erfolgreich betrachtet werden: Wie
          ausgeführt wurden einerseits die gesetzten Ziele größtenteils erreicht, andererseits die technischen
          Anforderungen an den Transpiler mehrheitlich erfüllt. Durch den Übersetzer konnte der Arbeitsaufwand und die
          Fehleranfälligkeit des Wechsels des Typsystems deutlich reduziert werden. Die auf diese Weise migrierten
          Projekte Components und Helios wurden inzwischen in einer neuen Version ausgeliefert und sind produktiv im
          Einsatz. Auch das Entwicklerteam von TeamShirts ist laut eigener Aussage sehr zufrieden mit dem vollzogenen
          Wechsel zu TypeScript.
        </p>
        <h2 id="mögliche-erweiterungen-des-projekts">
          <span class="chap-number">6.2</span>Mögliche Erweiterungen des Projekts
        </h2>
        <p>
          Zuletzt soll auf zwei Aspekte dieser Arbeit eingegangen werden, die zukünftig optimiert werden könnten: So
          treten bei der originalgetreuen Formatierung der Ausgabe durch den Transpiler wie gezeigt teilweise noch
          Fehler auf. Das implementierte zeilenbasierte Verfahren funktioniert zwar in den allermeisten Fällen akkurat,
          ist aber nicht besonders robust. Sobald eine Abweichung beim Vergleich der Ein- und Ausgabe auftritt, ist eine
          korrekte Behandlung der verbleibenden Datei unmöglich<a
            href="#fn41"
            class="footnote-ref"
            id="fnref41"
            role="doc-noteref"
            ><sup>41</sup></a
          >. Ein aussichtsreicher Ansatz wäre, die gesamte Quelltexttransformation durch einen konkreten statt
          abstrakten Syntaxbaum umzusetzen, damit die Information über die Formatierung des ursprünglichen Quelltexts
          präzise beibehalten wird. Bereits während der Entwicklung des Transpilers wurde dieser Ansatz in Betracht
          gezogen und nach geeigneten Bibliotheken gesucht. Dabei wurde das Projekt <em>CST</em> (<em
            >Concrete Syntax Tree</em
          >) <a class="citation" href="#ref-SOFTWARE:CST">[124]</a> gefunden, welches das Einlesen konkreter Syntaxbäume
          für JavaScript ermöglicht. Allerdings werden hierbei weder Flow, noch TypeScript unterstützt, sodass die
          angestrebte Verwendung so nicht möglich ist. Falls das Projekt aber entsprechend erweitert werden würde,
          könnte die Programmtransformation in Zukunft auf diese Weise durchgeführt werden.
        </p>
        <p>
          Aufgrund des begrenzten zeitlichen Rahmens dieser Masterarbeit konnten in den zwei migrierten Projekten von
          TeamShirts nur die nicht-strikte Überprüfung von Typfehlern durch TypeScript realisiert werden. Zur weiteren
          Steigerung der statischen Typsicherheit sollte deshalb zukünftig in beiden Projekten strikte Überprüfungen
          aktiviert und die resultierenden Typfehler daraufhin korrigiert werden.
        </p>
      </section>
      <hr />
      <section>
        <h2>Quellenverzeichnis</h2>
        <ol id="refs" class="references" role="doc-bibliography">
          <li id="ref-FLOW:PAPER">
            A. Chaudhuri, P. Vekris, S. Goldman, M. Roch, und G. Levi, „Fast and Precise Type Checking for JavaScript“,
            <em>Proc. ACM Program. Lang.</em>, Bd. 1, Nr. 48, S. 48:1–48:30, Okt. 2017, doi:
            <a href="https://doi.org/10.1145/3133872">10.1145/3133872</a>.
          </li>
          <li id="ref-TYPESCRIPT:SPEC">
            <em>TypeScript – Language Specification</em>, 1.8 Aufl. Microsoft Corporation, 2016.
          </li>
          <li id="ref-BABEL">
            S. McKenzie und others, „Babel - The compiler for next generation JavaScript“. 2018, Zugegriffen: März 22,
            2019. [Online]. Verfügbar unter: <a href="https://babeljs.io/">https://babeljs.io/</a>.
          </li>
          <li id="ref-SEVERANCE:2012">
            C. Severance, „JavaScript: Designing a Language in 10 Days“, <em>Computer</em>, Bd. 45, S. 7–8, Feb. 2012,
            doi: <a href="https://doi.org/10.1109/MC.2012.57">10.1109/MC.2012.57</a>.
          </li>
          <li id="ref-PAULSON:2007">
            L. D. Paulson, „Developers shift to dynamic programming languages“, <em>Computer</em>, Bd. 40, Nr. 2, S.
            12–15, Feb. 2007, doi: <a href="https://doi.org/10.1109/MC.2007.53">10.1109/MC.2007.53</a>.
          </li>
          <li id="ref-CROCKFORD:JS_POPULAR">
            D. Crockford, „The World’s Most Misunderstood Programming Language Has Become the World’s Most Popular
            Programming Language“, März 2008.
            <a href="http://crockford.com/javascript/popular.html">http://crockford.com/javascript/popular.html</a>
            (zugegriffen Juli 22, 2019).
          </li>
          <li id="ref-STACKOVERFLOW:SURVEY">
            S. E. Inc, „Stack Overflow Annual Developer Survey“, 2019.
            <a href="https://insights.stackoverflow.com/survey/2019">https://insights.stackoverflow.com/survey/2019</a>
            (zugegriffen Juni 03, 2019).
          </li>
          <li id="ref-TAIVALSAARI:2017">
            A. Taivalsaari und T. Mikkonen, „The Web as a Software Platform: Ten Years Later“, in
            <em
              >Proceedings of the 13th International Conference on Web Information Systems and Technologies - Volume 1:
              WEBIST,</em
            >
            2017, S. 41–50, doi: <a href="https://doi.org/10.5220/0006234800410050">10.5220/0006234800410050</a>.
          </li>
          <li id="ref-CASTELEYN:2014">
            S. Casteleyn, I. Garrig’os, und J.-N. Maz’on, „Ten years of rich internet applications: A systematic mapping
            study, and beyond“, <em>ACM Transactions on the Web (TWEB)</em>, Bd. 8, Nr. 3, S. 18, 2014.
          </li>
          <li id="ref-OREILLY:JS_HOW_DID_WE_GET_THERE">
            S. Champeon, „JavaScript: How Did We Get Here?“, Juni 2001.
            <a
              href="https://web.archive.org/web/20160719020828/http://archive.oreilly.com/pub/a/javascript/2001/04/06/js_history.html"
              >https://web.archive.org/web/20160719020828/http://archive.oreilly.com/pub/a/javascript/2001/04/06/js_history.html</a
            >
            (zugegriffen März 25, 2019).
          </li>
          <li id="ref-CROCKFORD:JS_MISUNDERSTOOD">
            D. Crockford, „JavaScript: The World’s Most Misunderstood Programming Language“, 2001.
            <a href="https://crockford.com/javascript/javascript.html"
              >https://crockford.com/javascript/javascript.html</a
            >
            (zugegriffen Juli 16, 2019).
          </li>
          <li id="ref-ECMASCRIPT:1997">
            <em>ECMAScript: A general purpose, cross-platform programming language</em>, 1st Aufl. Geneva: Ecma
            International, 1997.
          </li>
          <li id="ref-NIKHIL:2014">
            N. Swamy <em>u. a.</em>, „Gradual typing embedded securely in JavaScript“, in <em>ACM SIGPLAN Notices</em>,
            2014, Bd. 49, S. 425–437.
          </li>
          <li id="ref-PRADEL:2015">
            M. Pradel und K. Sen, „The Good, the Bad, and the Ugly: An Empirical Study of Implicit Type Conversions in
            JavaScript“, in <em>ECOOP</em>, 2015.
          </li>
          <li id="ref-WALDMANN:PPS">
            J. Waldmann, „Prinzipien von Programmiersprachen – Vorlesung Wintersemester 2007 – 2018“. Hochschule für
            Technik, Wirtschaft und Kultur Leipzig, Jan. 2019, Zugegriffen: Juli 31, 2019. [Online]. Verfügbar unter:
            <a href="https://www.imn.htwk-leipzig.de/~waldmann/edu/ws18/pps/folien/skript.pdf"
              >https://www.imn.htwk-leipzig.de/~waldmann/edu/ws18/pps/folien/skript.pdf</a
            >.
          </li>
          <li id="ref-CARDELLI:TYPE_SYSTEMS">
            L. Cardelli, „Type systems“, <em>ACM Computing Surveys</em>, Bd. 28, Nr. 1, S. 263–264, 1996.
          </li>
          <li id="ref-ECMASCRIPT:2019">
            <em>ECMAScript 2019 Language Specification</em>, 10th Aufl. Geneva: Ecma International, 2019.
          </li>
          <li id="ref-RICHARDS:2010">
            G. Richards, S. Lebresne, B. Burg, und J. Vitek, „An Analysis of the Dynamic Behavior of JavaScript
            Programs“, in
            <em>Proceedings of the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation</em>,
            2010, S. 1–12, doi: <a href="https://doi.org/10.1145/1806596.1806598">10.1145/1806596.1806598</a>.
          </li>
          <li id="ref-ANDERSON:2005">
            C. Anderson und P. Giannini, „Type checking for JavaScript“,
            <em>Electronic Notes in Theoretical Computer Science</em>, Bd. 138, Nr. 2, S. 37–58, 2005.
          </li>
          <li id="ref-BIERMAN:2014">
            G. Bierman, M. Abadi, und M. Torgersen, „Understanding TypeScript“, in
            <em
              >Proceedings of the 28th European Conference on ECOOP 2014 — Object-Oriented Programming - Volume 8586</em
            >, 2014, S. 257–281, doi:
            <a href="https://doi.org/10.1007/978-3-662-44202-9_11">10.1007/978-3-662-44202-9_11</a>.
          </li>
          <li id="ref-SMITH:TYPE_SYSTEMS">
            C. Smith, „What To Know Before Debating Type Systems“, 2008.
            <a href="https://cdsmith.wordpress.com/2011/01/09/an-old-article-i-wrote/"
              >https://cdsmith.wordpress.com/2011/01/09/an-old-article-i-wrote/</a
            >
            (zugegriffen Okt. 02, 2019).
          </li>
          <li id="ref-MITCHELL:CONCEPTS">
            J. C. Mitchell und K. Apt, <em>Concepts in programming languages</em>. Cambridge University Press, 2003.
          </li>
          <li id="ref-EVGENIY:2016">
            E. Ilyushin und D. Namiot, „On source-to-source compilers“,
            <em>International Journal of Open Information Technologies</em>, Bd. 4, S. 48–51, Apr. 2016.
          </li>
          <li id="ref-WRIGHT:1994">
            A. K. Wright und M. Felleisen, „A Syntactic Approach to Type Soundness“,
            <em>Information and Computation</em>, Bd. 115, Nr. 1, S. 38–94, 1994, doi:
            <a href="https://doi.org/https://doi.org/10.1006/inco.1994.1093">https://doi.org/10.1006/inco.1994.1093</a>.
          </li>
          <li id="ref-DART:TYPE_SYSTEM">
            S. Zakhou, „The Dart type system“, Sep. 2019.
            <a href="https://dart.dev/guides/language/sound-dart">https://dart.dev/guides/language/sound-dart</a>
            (zugegriffen Okt. 16, 2019).
          </li>
          <li id="ref-FLOW:TYPES_AND_EXPRESSIONS">
            Facebook Inc., „Types &amp; Expressions“, 2019.
            <a href="https://flow.org/en/docs/lang/types-and-expressions/"
              >https://flow.org/en/docs/lang/types-and-expressions/</a
            >
            (zugegriffen Okt. 16, 2019).
          </li>
          <li id="ref-ISO:C99">
            ISO, „ISO C Standard 1999“, Technischer Bericht, 1999. Zugegriffen: Okt. 02, 2019. [Online]. Verfügbar
            unter:
            <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"
              >http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf</a
            >.
          </li>
          <li id="ref-AMADIO:1993">
            R. M. Amadio und L. Cardelli, „Subtyping Recursive Types“, <em>ACM Trans. Program. Lang. Syst.</em>, Bd. 15,
            Nr. 4, S. 575–631, Sep. 1993, doi:
            <a href="https://doi.org/10.1145/155183.155231">10.1145/155183.155231</a>.
          </li>
          <li id="ref-VARIANCE">
            S. Boyer, „What are covariance and contravariance?“, Juli 2017.
            <a href="https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance"
              >https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance</a
            >
            (zugegriffen Okt. 25, 2019).
          </li>
          <li id="ref-FLOW:VARIANCE">
            Facebook Inc., „Type Variance“, 2019.
            <a href="https://flow.org/en/docs/lang/variance/">https://flow.org/en/docs/lang/variance/</a> (zugegriffen
            Okt. 25, 2019).
          </li>
          <li id="ref-MALAYERI:2008">
            D. Malayeri und J. Aldrich, „Integrating Nominal and Structural Subtyping“, in
            <em>ECOOP 2008 – Object-Oriented Programming</em>, 2008, S. 260–284.
          </li>
          <li id="ref-FLOW:INSTALLATION">
            Facebook Inc., „Installation“, 2019.
            <a href="https://flow.org/en/docs/install/">https://flow.org/en/docs/install/</a> (zugegriffen Okt. 16,
            2019).
          </li>
          <li id="ref-LICENSE:MIT">
            „MIT License“. Massachusetts Institute of Technology, 2019, Zugegriffen: Juli 01, 2019. [Online]. Verfügbar
            unter: <a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>.
          </li>
          <li id="ref-FLOW:GITHUB">
            Facebook Inc., „Flow“. 2019, Zugegriffen: Okt. 21, 2019. [Online]. Verfügbar unter:
            <a href="https://github.com/facebook/flow">https://github.com/facebook/flow</a>.
          </li>
          <li id="ref-FLOW:TYPE_SYSTEM">
            Facebook Inc., „Type System“, 2019.
            <a href="https://flow.org/en/docs/lang/">https://flow.org/en/docs/lang/</a> (zugegriffen Okt. 16, 2019).
          </li>
          <li id="ref-WINTER:2013">
            K. Winter, C. Zhang, I. J. Hayes, N. Keynes, C. Cifuentes, und L. Li, „Path-sensitive data flow analysis
            simplified“, in <em>International Conference on Formal Engineering Methods</em>, 2013, S. 415–430.
          </li>
          <li id="ref-FLOW:NOMINAL_TYPES">
            Facebook Inc., „Nominal &amp; Structural Typing“, 2019.
            <a href="https://flow.org/en/docs/lang/nominal-structural/"
              >https://flow.org/en/docs/lang/nominal-structural/</a
            >
            (zugegriffen Okt. 17, 2019).
          </li>
          <li id="ref-FLOW:TYPE_ANNOTATIONS">
            Facebook Inc., „Type Annotation“, 2019.
            <a href="https://flow.org/en/docs/types/">https://flow.org/en/docs/types/</a> (zugegriffen Juli 15, 2019).
          </li>
          <li id="ref-FLOW:UTILITY_TYPES">
            Facebook Inc., „Utility Types“, 2019.
            <a href="https://flow.org/en/docs/types/utilities/">https://flow.org/en/docs/types/utilities/</a>
            (zugegriffen Juli 15, 2019).
          </li>
          <li id="ref-FLOW:LIBRARY_DEFINITIONS">
            Facebook Inc., „Creating Library Definitions“, 2019.
            <a href="https://flow.org/en/docs/libdefs/creation/">https://flow.org/en/docs/libdefs/creation/</a>
            (zugegriffen Okt. 18, 2019).
          </li>
          <li id="ref-LICENSE:APACHE20">
            „Apache License, Version 2.0“. The Apache Software Foundation, Jan. 2004, Zugegriffen: Okt. 21, 2019.
            [Online]. Verfügbar unter:
            <a href="https://www.apache.org/licenses/LICENSE-2.0">https://www.apache.org/licenses/LICENSE-2.0</a>.
          </li>
          <li id="ref-TYPESCRIPT:GITHUB">
            M. Corporation, „TypeScript“. 2019, Zugegriffen: Okt. 21, 2019. [Online]. Verfügbar unter:
            <a href="https://github.com/microsoft/TypeScript/">https://github.com/microsoft/TypeScript/</a>.
          </li>
          <li id="ref-GITHUB:HEJLSBERG">
            A. Heljsberg, „aheljsberg (Anders Heljsberg“, 2019.
            <a href="https://github.com/ahejlsberg">https://github.com/ahejlsberg</a> (zugegriffen Okt. 21, 2019).
          </li>
          <li id="ref-TYPESCRIPT:BABEL">
            D. Rosenwasser, „TypeScript and Babel 7“, Aug. 27, 2018.
            <a href="https://devblogs.microsoft.com/typescript/typescript-and-babel-7/"
              >https://devblogs.microsoft.com/typescript/typescript-and-babel-7/</a
            >
            (zugegriffen Okt. 21, 2019).
          </li>
          <li id="ref-TSC:OPTIONS">
            M. Corporation, „Compiler Options“, 2019.
            <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html"
              >https://www.typescriptlang.org/docs/handbook/compiler-options.html</a
            >
            (zugegriffen Okt. 23, 2019).
          </li>
          <li id="ref-TYPESCRIPT:DESIGN_GOALS">
            M. Corporation, „TypeScript Design Goals“, Sep. 2014.
            <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals"
              >https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals</a
            >
            (zugegriffen Okt. 21, 2019).
          </li>
          <li id="ref-SIEK:2007">
            J. Siek und W. Taha, „Gradual Typing for Objects“, Aug. 2007, S. 2–27, doi:
            <a href="https://doi.org/10.1007/978-3-540-73589-2_2">10.1007/978-3-540-73589-2_2</a>.
          </li>
          <li id="ref-TYPESCRIPT:ARCHITECTURE">
            Microsoft Corporation, „Architectural Overview“, Feb. 2017.
            <a href="https://github.com/microsoft/TypeScript/wiki/Architectural-Overview"
              >https://github.com/microsoft/TypeScript/wiki/Architectural-Overview</a
            >
            (zugegriffen Okt. 21, 2019).
          </li>
          <li id="ref-TYPESCRIPT:TSSERVER">
            Microsoft Corporation, „Standalone Server (tsserver)“, Okt. 2019.
            <a href="https://github.com/microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29"
              >https://github.com/microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29</a
            >
            (zugegriffen Okt. 22, 2019).
          </li>
          <li id="ref-FLOW:GENERICS">
            Facebook Inc., „Generic Types“, 2019.
            <a href="https://flow.org/en/docs/types/generics/">https://flow.org/en/docs/types/generics/</a>
            (zugegriffen Okt. 21, 2019).
          </li>
          <li id="ref-AHO:COMPILERS">
            A. V. Aho, M. S. Lam, R. Sethi, und J. D. Ullman,
            <em>Compilers: Principles, Techniques, and Tools</em>, 2nd Aufl. Boston, MA, USA: Addison-Wesley Longman
            Publishing Co., Inc., 2006.
          </li>
          <li id="ref-APPEL:2003">
            A. W. Appel und J. Palsberg, <em>Modern Compiler Implementation in Java</em>, 2nd Aufl. New York, NY, USA:
            Cambridge University Press, 2003.
          </li>
          <li id="ref-TORCZON:2007">
            L. Torczon und K. Cooper, <em>Engineering A Compiler</em>, 2nd Aufl. San Francisco, CA, USA: Morgan Kaufmann
            Publishers Inc., 2011.
          </li>
          <li id="ref-SCHOEPP:COMPILER">
            U. Schöpp, „Praktikum Compilerbau – Wintersemester 2014/15“. Ludwig-Maximilians-Universität München,
            Institut für Informatik, Jan. 2019, Zugegriffen: Okt. 07, 2019. [Online]. Verfügbar unter:
            <a href="https://www.tcs.ifi.lmu.de/lehre/ws-2014-15/compilerbau/material/folien"
              >https://www.tcs.ifi.lmu.de/lehre/ws-2014-15/compilerbau/material/folien</a
            >.
          </li>
          <li id="ref-FOWLER:TRANSPARENT">
            M. Fowler, „Transparent Compilation“, Feb. 2013.
            <a href="https://martinfowler.com/bliki/TransparentCompilation.html"
              >https://martinfowler.com/bliki/TransparentCompilation.html</a
            >
            (zugegriffen Okt. 21, 2019).
          </li>
          <li id="ref-TC39_COMMITTEE">
            Ecma International, „TC39 - ECMAScript“, 2019.
            <a href="https://www.ecma-international.org/memento/tc39.htm"
              >https://www.ecma-international.org/memento/tc39.htm</a
            >
            (zugegriffen Aug. 02, 2019).
          </li>
          <li id="ref-TC39_PROCESS">
            Ecma International, „The TC39 Process“, 2019.
            <a href="https://tc39.es/process-document/">https://tc39.es/process-document/</a> (zugegriffen Aug. 02,
            2019).
          </li>
          <li id="ref-SOFTWARE:JSX">
            Facebook Inc., „Introducing JSX“. 2019, Zugegriffen: Aug. 02, 2019. [Online]. Verfügbar unter:
            <a href="https://reactjs.org/docs/introducing-jsx.html">https://reactjs.org/docs/introducing-jsx.html</a>.
          </li>
          <li id="ref-ESTREE_SPEC">D. Herman <em>u. a.</em>, <em>The ESTree Spec</em>. 2019.</li>
          <li id="ref-BABEL:PARSER">
            Babel, „@babel/parser“. 2019, Zugegriffen: Aug. 05, 2019. [Online]. Verfügbar unter:
            <a href="https://babeljs.io/docs/en/babel-parser">https://babeljs.io/docs/en/babel-parser</a>.
          </li>
          <li id="ref-RECAST">
            B. Newman, „recast - JavaScript syntax tree transformer, nondestructive pretty-printer, and automatic source
            map generator“. 2012, Zugegriffen: Okt. 11, 2019. [Online]. Verfügbar unter:
            <a href="https://github.com/benjamn/recast">https://github.com/benjamn/recast</a>.
          </li>
          <li id="ref-BABEL:HANDBOOK">
            J. Kyle, S. McKenzie, H. Zhu, und others, <em>Babel Handbook</em>. Babel, 2017.
          </li>
          <li id="ref-BABEL:DOCS"><em>What is Babel?</em> Babel, 2019.</li>
          <li id="ref-GAMMA:1994">
            E. Gamma, R. Helm, R. Johnson, und J. M. Vlissides,
            <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, 1. Aufl. Addison-Wesley
            Professional, 1994.
          </li>
          <li id="ref-FREEMAN:2004">
            E. Freeman, E. Freeman, B. Bates, und K. Sierra, <em>Head First Design Patterns</em>, 2nd Aufl. O’Reilly
            &amp; Associates, Inc., 2004.
          </li>
          <li id="ref-BABEL:PARSER_SPEC">S. McKenzie, <em>@babel/parser (Babylon) AST node types</em>. Babel, 2019.</li>
          <li id="ref-BABEL:TYPES">
            Babel, „@babel/types“. 2019, Zugegriffen: Aug. 07, 2019. [Online]. Verfügbar unter:
            <a href="https://babeljs.io/docs/en/babel-types">https://babeljs.io/docs/en/babel-types</a>.
          </li>
          <li id="ref-BABEL:STATE_OF_BABEL">
            H. Zhu, „The State of Babel“, Dez. 2016.
            <a href="https://babeljs.io/blog/2016/12/07/the-state-of-babel"
              >https://babeljs.io/blog/2016/12/07/the-state-of-babel</a
            >
            (zugegriffen Juli 22, 2019).
          </li>
          <li id="ref-SPREADSHIRT:ABOUT">
            sprd.net AG, „Unternehmen“, 2019.
            <a href="https://www.spreadshirt.de/unternehmen-C2410">https://www.spreadshirt.de/unternehmen-C2410</a>
            (zugegriffen Aug. 16, 2019).
          </li>
          <li id="ref-TEAMSHIRTS:ABOUT">
            sprd.net AG, „Über uns“, 2019.
            <a href="https://www.teamshirts.de/ueber-uns">https://www.teamshirts.de/ueber-uns</a> (zugegriffen Okt. 06,
            2019).
          </li>
          <li id="ref-SOFTWARE:REACT">
            Facebook Inc., „React - A JavaScript library for building user interfaces“. 2019, Zugegriffen: März 22,
            2019. [Online]. Verfügbar unter: <a href="https://reactjs.org">https://reactjs.org</a>.
          </li>
          <li id="ref-MDN:WEBCOMPONENTS">
            M. W. Docs, „Web Components“, 2019.
            <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components"
              >https://developer.mozilla.org/en-US/docs/Web/Web_Components</a
            >
            (zugegriffen Aug. 16, 2019).
          </li>
          <li id="ref-REACT:WEBCOMPONENTS">
            Facebook Inc., „Web Components“, 2019.
            <a href="https://reactjs.org/docs/web-components.html">https://reactjs.org/docs/web-components.html</a>
            (zugegriffen Aug. 16, 2019).
          </li>
          <li id="ref-ACM:REACT">
            C. Staff, „React: Facebook’s functional turn on writing Javascript“,
            <em>Communications of the ACM</em>, Bd. 59, Nr. 12, S. 56–62, 2016.
          </li>
          <li id="ref-GOOGLE:RENDERING_ON_THE_WEB">
            J. Miller und A. Osmani, „Rendering on the Web“, Feb. 2019.
            <a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web"
              >https://developers.google.com/web/updates/2019/02/rendering-on-the-web</a
            >
            (zugegriffen Aug. 27, 2019).
          </li>
          <li id="ref-CHERNY:FLOW_TO_TS">
            B. Cherny, „Flow-to-TypeScript“. 2019, Zugegriffen: Aug. 27, 2019. [Online]. Verfügbar unter:
            <a href="https://github.com/bcherny/flow-to-typescript">https://github.com/bcherny/flow-to-typescript</a>.
          </li>
          <li id="ref-KIKURA:FLOW_TO_TS">
            Y. Kikura, „babel-plugin-flow-to-typescript“. 2019, Zugegriffen: Aug. 27, 2019. [Online]. Verfügbar unter:
            <a href="https://github.com/Kiikurage/babel-plugin-flow-to-typescript"
              >https://github.com/Kiikurage/babel-plugin-flow-to-typescript</a
            >.
          </li>
          <li id="ref-KHAN_ACADEMY">
            K. Academy, „About | Khan Academy“, 2019.
            <a href="https://www.khanacademy.org/about">https://www.khanacademy.org/about</a> (zugegriffen Sep. 27,
            2019).
          </li>
          <li id="ref-BARABASH:FLOW_TO_TS">
            K. Barabash, „flow-to-ts“. 2019, Zugegriffen: Aug. 27, 2019. [Online]. Verfügbar unter:
            <a href="https://github.com/Khan/flow-to-ts">https://github.com/Khan/flow-to-ts</a>.
          </li>
          <li id="ref-FLOW:UPDATE_2019">
            A. Chaudhuri, „What the Flow team has been up to“, Jan. 28, 2019.
            <a href="https://medium.com/flow-type/what-the-flow-team-has-been-up-to-54239c62004f"
              >https://medium.com/flow-type/what-the-flow-team-has-been-up-to-54239c62004f</a
            >
            (zugegriffen Nov. 04, 2019).
          </li>
          <li id="ref-TS:GITHUB:NO_OPAQUE_TYPE">
            „Support some non-structural (nominal) type matching“, Juli 2014.
            <a href="https://github.com/Microsoft/TypeScript/issues/202"
              >https://github.com/Microsoft/TypeScript/issues/202</a
            >
            (zugegriffen Okt. 25, 2019).
          </li>
          <li id="ref-ECMASCRIPT:2017">
            <em>ECMAScript 2017 Language Specification</em>, 8th Aufl. Geneva: Ecma International, 2017.
          </li>
          <li id="ref-ES_PROPOSAL:CLASS_FIELDS">
            D. Ehrenberg und J. Morrison, „Class field declarations for JavaScript“. Ecma International, Technical
            Committee 39, 2019, Zugegriffen: Aug. 02, 2019. [Online]. Verfügbar unter:
            <a href="https://github.com/tc39/proposal-class-fields">https://github.com/tc39/proposal-class-fields</a>.
          </li>
          <li id="ref-REACT:HANDLING_EVENTS">
            Facebook Inc., „Handling Events“, 2019.
            <a href="https://reactjs.org/docs/handling-events.html">https://reactjs.org/docs/handling-events.html</a>
            (zugegriffen Sep. 29, 2019).
          </li>
          <li id="ref-KERNIGHAN:1982">
            B. W. Kernighan und P. J. Plauger, <em>The Elements of Programming Style</em>, 2nd Aufl. New York, NY, USA:
            McGraw-Hill, Inc., 1982.
          </li>
          <li id="ref-ESLINT">
            N. C. Zakas, „ESLint - Pluggable JavaScript linter“. 2019, Zugegriffen: Okt. 06, 2019. [Online]. Verfügbar
            unter: <a href="https://eslint.org">https://eslint.org</a>.
          </li>
          <li id="ref-DOR:SOFTWARE_TEST">
            D. Nir, S. Tyszberowicz, und A. Yehudai, „Locating Regression Bugs“, in
            <em>Hardware and Software: Verification and Testing</em>, 2008, S. 218–234.
          </li>
          <li id="ref-JEFFRIES:EXTREME_PROGRAMMING">
            R. Jeffries, „What is Extreme Programming?“, März 2011.
            <a href="https://ronjeffries.com/xprog/what-is-extreme-programming/"
              >https://ronjeffries.com/xprog/what-is-extreme-programming/</a
            >
            (zugegriffen Juli 15, 2019).
          </li>
          <li id="ref-BECK:EXTREME_PROGRAMMING">
            K. Beck, <em>Extreme Programming Explained: Embrace Change</em>. Reading, Mass. [u.a.]: Addison-Wesley,
            2000.
          </li>
          <li id="ref-BECK:TDD">
            K. Beck, <em>Test-driven development: by example</em>. Addison-Wesley Professional, 2003.
          </li>
          <li id="ref-OLAN:2003">
            M. Olan, „Unit testing: test early, test often“, <em>Journal of Computing Sciences in Colleges</em>, Bd. 19,
            Nr. 2, S. 319–328, 2003.
          </li>
          <li id="ref-SOFTWARE:JEST">
            Facebook Inc., „Jest - Delightful JavaScript Testing“. 2019, Zugegriffen: Juli 30, 2019. [Online]. Verfügbar
            unter: <a href="https://jestjs.io/">https://jestjs.io/</a>.
          </li>
          <li id="ref-OMG:UML">
            OGM, <em>OMG Unified Modeling Language (OMG UML)</em>, 2.5 Aufl. Object Management Group, 2017.
          </li>
          <li id="ref-ES_PROPOSAL:DECORATORS">
            D. Ehrenberg, „JavaScript Decorators“. Ecma International, Technical Committee 39, 2019, Zugegriffen: Aug.
            02, 2019. [Online]. Verfügbar unter:
            <a href="https://github.com/tc39/proposal-decorators">https://github.com/tc39/proposal-decorators</a>.
          </li>
          <li id="ref-ES_PROPOSAL:DYNAMIC_IMPORTS">
            D. Denicola, „import()“. Ecma International, Technical Committee 39, 2019, Zugegriffen: Aug. 02, 2019.
            [Online]. Verfügbar unter:
            <a href="https://github.com/tc39/proposal-dynamic-import">https://github.com/tc39/proposal-dynamic-import</a
            >.
          </li>
          <li id="ref-BABEL:GENERATOR">
            Babel, „@babel/generator“. 2019, Zugegriffen: Aug. 02, 2019. [Online]. Verfügbar unter:
            <a href="https://babeljs.io/docs/en/babel-generator">https://babeljs.io/docs/en/babel-generator</a>.
          </li>
          <li id="ref-REFLOW_GITHUB">
            J. Gruber, „Reflow: Babel plugin to transpile a Flow typed codebase to TypeScript“. 2019, Zugegriffen: Juli
            31, 2019. [Online]. Verfügbar unter:
            <a href="https://github.com/grubersjoe/reflow">https://github.com/grubersjoe/reflow</a>.
          </li>
          <li id="ref-FLOW:MAYBE_TYPES">
            Facebook Inc., „Maybe Types“, 2019.
            <a href="https://flow.org/en/docs/types/maybe/">https://flow.org/en/docs/types/maybe/</a> (zugegriffen Okt.
            25, 2019).
          </li>
          <li id="ref-FLOW:LINT_RULE_REFERENCE">
            Facebook Inc., „Lint Rule Reference“, 2018.
            <a href="https://flow.org/en/docs/linting/rule-reference/#toc-deprecated-type"
              >https://flow.org/en/docs/linting/rule-reference/#toc-deprecated-type</a
            >
            (zugegriffen Aug. 11, 2019).
          </li>
          <li id="ref-TS:HANDBOOK:JSX"><em>JSX · TypeScript</em>. Microsoft Corporation, 2019.</li>
          <li id="ref-SOFTWARE:PRETTIER">
            L. Duailibe, „Prettier · Opinionated Code Formatter“. 2019, Zugegriffen: Aug. 02, 2019. [Online]. Verfügbar
            unter: <a href="https://prettier.io/">https://prettier.io/</a>.
          </li>
          <li id="ref-WEBPACK">
            T. Koppers, „webpack“. 2019, Zugegriffen: Nov. 07, 2019. [Online]. Verfügbar unter:
            <a href="https://webpack.js.org/">https://webpack.js.org/</a>.
          </li>
          <li id="ref-FLOW:WIDTH_SUBTYPING">
            Facebook Inc., „Width Subtyping“, 2019.
            <a href="https://flow.org/en/docs/lang/width-subtyping/">https://flow.org/en/docs/lang/width-subtyping/</a>
            (zugegriffen Okt. 18, 2019).
          </li>
          <li id="ref-REACT:REACT_ELEMENTS">
            D. Abramov, „React Components, Elements, and Instances“, Dez. 18, 2015.
            <a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html"
              >https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html</a
            >
            (zugegriffen Nov. 07, 2019).
          </li>
          <li id="ref-DEFINITELY_TYPED">
            „DefinitelyTyped - The repository for high quality TypeScript type definitions“. 2019, Zugegriffen: Nov. 03,
            2019. [Online]. Verfügbar unter:
            <a href="https://github.com/DefinitelyTyped/DefinitelyTyped"
              >https://github.com/DefinitelyTyped/DefinitelyTyped</a
            >.
          </li>
          <li id="ref-FLOW_TYPED">
            „flow-typed/flow-typed: A central repository for Flow library definitions“. 2019, Zugegriffen: Nov. 03,
            2019. [Online]. Verfügbar unter:
            <a href="https://github.com/flow-typed/flow-typed">https://github.com/flow-typed/flow-typed</a>.
          </li>
          <li id="ref-SEMANTIC_VERSIONING"><em>Semantic Versioning 2.0.0</em>. Preston-Werner, Tom, 2013.</li>
          <li id="ref-GNU_TIME">
            D. Keppel, D. MacKenzie, und A. Gordon, „GNU Time“. 2019, Zugegriffen: Okt. 27, 2019. [Online]. Verfügbar
            unter: <a href="https://www.gnu.org/software/time/">https://www.gnu.org/software/time/</a>.
          </li>
          <li id="ref-TS:NO_MULTICORE">
            „Multicore compilation on roadmap?“, Dez. 2016.
            <a href="https://github.com/Microsoft/TypeScript/issues/12987"
              >https://github.com/Microsoft/TypeScript/issues/12987</a
            >
            (zugegriffen Okt. 28, 2019).
          </li>
          <li id="ref-TASKSET">
            R. M. Love, „taskset - set or retrieve a process’s CPU affinity“. 2019, Zugegriffen: Okt. 28, 2019.
            [Online]. Verfügbar unter:
            <a href="http://man7.org/linux/man-pages/man1/taskset.1.html"
              >http://man7.org/linux/man-pages/man1/taskset.1.html</a
            >.
          </li>
          <li id="ref-NODE:THREADS">
            J. Davis, „Don’t Block the Event Loop (or the Worker Pool)“, Okt. 2019.
            <a href="https://nodejs.org/ru/docs/guides/dont-block-the-event-loop/"
              >https://nodejs.org/ru/docs/guides/dont-block-the-event-loop/</a
            >
            (zugegriffen Okt. 29, 2019).
          </li>
          <li id="ref-TS:MULTICORE">
            „Support multi-threaded compilation for –build“, März 2019.
            <a href="https://github.com/microsoft/TypeScript/issues/30235"
              >https://github.com/microsoft/TypeScript/issues/30235</a
            >
            (zugegriffen Okt. 29, 2019).
          </li>
          <li id="ref-FLOW:GITHUB:ROADMAP">
            „Roadmap/Path to V1?“, Sep. 2017.
            <a href="https://github.com/microsoft/TypeScript/issues/11588"
              >https://github.com/microsoft/TypeScript/issues/11588</a
            >
            (zugegriffen Nov. 05, 2019).
          </li>
          <li id="ref-FLOW:GITHUB:ROADMAP_FUTURE">
            „Facebook’s own Flow adoption?“, Jan. 2017.
            <a href="https://github.com/facebook/flow/issues/7365">https://github.com/facebook/flow/issues/7365</a>
            (zugegriffen Nov. 05, 2019).
          </li>
          <li id="ref-TS:ROADMAP">
            „Roadmap“, Nov. 2019.
            <a href="https://github.com/microsoft/TypeScript/wiki/Roadmap"
              >https://github.com/microsoft/TypeScript/wiki/Roadmap</a
            >
            (zugegriffen Nov. 05, 2019).
          </li>
          <li id="ref-GITHUB:API">
            M. Corporation, „GitHub API v3 | GitHub Developer Guide“, 2019.
            <a href="https://developer.github.com/v3/">https://developer.github.com/v3/</a> (zugegriffen Nov. 05, 2019).
          </li>
          <li id="ref-JEST_TS">
            „[RFC] Migrate Jest to TypeScript“, Sep. 2017.
            <a href="https://github.com/facebook/jest/pull/7554">https://github.com/facebook/jest/pull/7554</a>
            (zugegriffen Nov. 05, 2019).
          </li>
          <li id="ref-TS:GITHUB:NO_EXISTENTIAL_TYPE">
            „Existential type?“, März 2017.
            <a href="https://github.com/Microsoft/TypeScript/issues/14466"
              >https://github.com/Microsoft/TypeScript/issues/14466</a
            >
            (zugegriffen Juli 15, 2019).
          </li>
          <li id="ref-TS:HANDBOOK:INTERFACES"><em>Interfaces · TypeScript</em>. Microsoft Corporation, 2019.</li>
          <li id="ref-TS:GITHUB:CONSTRUCTOR_RETURN_TYPE">
            „TS1093: Can’t specify return types on constructors“, Okt. 2016.
            <a href="https://github.com/microsoft/TypeScript/issues/11588"
              >https://github.com/microsoft/TypeScript/issues/11588</a
            >
            (zugegriffen Okt. 25, 2019).
          </li>
          <li id="ref-MDN:DEFAULT_PARAMS">
            M. W. Docs, „Default parameters“, 2019.
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters"
              >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters</a
            >
            (zugegriffen Okt. 31, 2019).
          </li>
          <li id="ref-NPM:GLOB">
            I. Z. Schlueter, „Glob“. 2019, Zugegriffen: Okt. 22, 2019. [Online]. Verfügbar unter:
            <a href="https://www.npmjs.com/package/glob">https://www.npmjs.com/package/glob</a>.
          </li>
          <li id="ref-MAN:GLOB"><em>GLOB(3) – Linux Programmer’s Manual</em>. The Linux man-pages project, 2019.</li>
          <li id="ref-SOFTWARE:CST">
            H. Zhu und O. Gaidarenko, „JavaScript Concrete Syntax Tree“. 2019, Zugegriffen: Nov. 11, 2019. [Online].
            Verfügbar unter: <a href="https://github.com/cst/cst">https://github.com/cst/cst</a>.
          </li>
        </ol>
      </section>
      <section class="footnotes" role="doc-endnotes">
        <h2>Fußnoten</h2>
        <ol>
          <li id="fn1" role="doc-endnote">
            <p>
              „ECMAScript“ ist der Name der formalen Spezifikation von JavaScript und geht auf die Normungsorganisation
              <em>Ecma International</em> zurück. <em>Netscape Communications</em> beauftragte diese im November 1996
              mit der Erstellung des Standards, welcher im Jahr darauf unter der Bezeichnung „ECMA-262“ veröffentlicht
              wurde <a class="citation" href="#ref-ECMASCRIPT:1997">[12]</a>.<a
                href="#fnref1"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn2" role="doc-endnote">
            <p>Engl. <em>soundness</em>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p>
          </li>
          <li id="fn3" role="doc-endnote">
            <p>
              Zum Beispiel in Java durch das Schlüsselwort „<code>extends</code>“.<a
                href="#fnref3"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn4" role="doc-endnote">
            <p>
              Siehe Tabelle
              <a href="#tab:flow-base-types" data-reference-type="ref" data-reference="tab:flow-base-types"
                >[tab:flow-base-types]</a
              >.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn5" role="doc-endnote">
            <p>
              Es ist kritisch anzumerken, dass das Nichtauffinden eines Werts im eigentliche Sinne keine Ausnahme
              (<em>Exception</em>) darstellt und hier nur zur Verbesserung der Ausdruckskraft des Beispiels dient.<a
                href="#fnref5"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn6" role="doc-endnote">
            <p>
              Seit 2018 kann auch Babel <a class="citation" href="#ref-BABEL">[3]</a> benutzt werden, um
              TypeScript-Programme in JavaScript zu überführen
              <a class="citation" href="#ref-TYPESCRIPT:BABEL">[44]</a>.<a
                href="#fnref6"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn7" role="doc-endnote">
            <p>
              Siehe Abschnitt
              <a href="#sec:transpiler-concepts" data-reference-type="ref" data-reference="sec:transpiler-concepts"
                >2.3.1</a
              >.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn8" role="doc-endnote">
            <p>
              Siehe Abschnitt
              <a href="#sec:flow-transpilation" data-reference-type="ref" data-reference="sec:flow-transpilation"
                >4.3.2</a
              >.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn9" role="doc-endnote">
            <p>
              Engl. <em>intermediate representation</em> (IR).<a
                href="#fnref9"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn10" role="doc-endnote">
            <p>
              Dies setzt die Benutzung eines Transpilers wie Babel
              <a class="citation" href="#ref-BABEL">[3]</a> voraus, der solche experimentelle Syntax vor der
              Auslieferung durch entsprechende Plugins in standardkonformes JavaScript transformiert.<a
                href="#fnref10"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn11" role="doc-endnote">
            <p>
              Das Besucher-Entwurfsmustern (engl. <em>visitor pattern</em>) gehört zu den 23 Entwurfsmustern, die im
              Standardwerk „” der “<em>Gang of Four</em>“ (E. Gamma, R. Helm, R. Johnson und J. Vlissides) beschrieben
              werden <a class="citation" href="#ref-GAMMA:1994">[64, S. 306]</a>.<a
                href="#fnref11"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn12" role="doc-endnote">
            <p>
              React-Komponenten sind nicht mit <em>Webkomponenten</em>
              <a class="citation" href="#ref-MDN:WEBCOMPONENTS">[72]</a> zu verwechseln. Diese verfolgen ein ähnliches,
              aber nicht identisches Konzept. React interagiert beispielsweise im Gegensatz zu Webkomponenten direkt mit
              dem <em>Document Object Model</em> (DOM) des HTML-Dokuments
              <a class="citation" href="#ref-REACT:WEBCOMPONENTS">[73]</a> statt mit dem sogenannten
              <em>Shadow DOM</em>.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn13" role="doc-endnote">
            <p>
              Engl. „<em>time to interactive</em>“ (TTI).<a href="#fnref13" class="footnote-back" role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn14" role="doc-endnote">
            <p>
              Vgl. Abschnitt
              <a href="#sec:type-declarations" data-reference-type="ref" data-reference="sec:type-declarations"
                >2.2.1.7</a
              >.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn15" role="doc-endnote">
            <p>
              <em>Facebook Inc.</em> (Flow) <a class="citation" href="#ref-FLOW:PAPER">[1]</a> bzw.
              <em>Microsoft Corporation</em> (TypeScript) <a class="citation" href="#ref-TYPESCRIPT:SPEC">[2]</a>.<a
                href="#fnref15"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn16" role="doc-endnote">
            <p>
              Siehe Tabelle
              <a href="#tab:cli-options" data-reference-type="ref" data-reference="tab:cli-options">[tab:cli-options]</a
              >.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn17" role="doc-endnote">
            <p>
              Vgl. Abschnitt
              <a href="#sec:babel-plugins" data-reference-type="ref" data-reference="sec:babel-plugins">2.3.3.2</a>.<a
                href="#fnref17"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn18" role="doc-endnote">
            <p>
              Vgl. Abschnitt
              <a
                href="#sec:requirement:completeness"
                data-reference-type="ref"
                data-reference="sec:requirement:completeness"
                >3.3.1</a
              >.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn19" role="doc-endnote">
            <p>
              Engl. <em>test-driven development</em> (TDD).<a href="#fnref19" class="footnote-back" role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn20" role="doc-endnote">
            <p>
              Anmerkung: Diese hohe Zahl ist darin begründet, dass größtenteils Fixture-Tests umgesetzt wurden und jeder
              Vergleich einer nicht-leeren Zeile hierbei als ein Test betrachtet wird.<a
                href="#fnref20"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn21" role="doc-endnote">
            <p>
              Vgl. Anforderung
              <a href="#sec:requirement:syntax" data-reference-type="ref" data-reference="sec:requirement:syntax"
                >3.3.3</a
              >.<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn22" role="doc-endnote">
            <p>
              Anmerkung: Zur Vereinfachung der Nachvollziehbarkeit wurde der Syntaxbaum auf seine wesentlichen Teile
              reduziert. Tatsächlich besitzen alle Knoten weitere Attribute, die hier jedoch irrelevant sind.<a
                href="#fnref22"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn23" role="doc-endnote">
            <p>
              Vgl. Zeile 2 in Tabelle
              <a
                href="#tab:transformation-base-types-complex"
                data-reference-type="ref"
                data-reference="tab:transformation-base-types-complex"
                >[tab:transformation-base-types-complex]</a
              >.<a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn24" role="doc-endnote">
            <p>
              Anmerkung: Es wurde ein verhältnismäßig unkompliziertes Beispiel ausgewählt, weil die Ausführung anderer
              deutlich komplexerer Fälle nicht in prägnanter Form erfolgen kann.<a
                href="#fnref24"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn25" role="doc-endnote">
            <p>
              Vgl. Anforderung
              <a
                href="#sec:requirement:completeness"
                data-reference-type="ref"
                data-reference="sec:requirement:completeness"
                >3.3.1</a
              >.<a href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn26" role="doc-endnote">
            <p>
              Siehe <a class="citation" href="#ref-ECMASCRIPT:2019">[17, S. 377]</a>.<a
                href="#fnref26"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn27" role="doc-endnote">
            <p>
              Vgl. Tabelle
              <a href="#tab:cli-options" data-reference-type="ref" data-reference="tab:cli-options">[tab:cli-options]</a
              >.<a href="#fnref27" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn28" role="doc-endnote">
            <p>
              Siehe <a class="citation" href="#ref-REFLOW_GITHUB">[97]</a> für detaillierte Installations-Anweisungen.<a
                href="#fnref28"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn29" role="doc-endnote">
            <p>
              Vgl. Abb.
              <a href="#fig:architecture-overview" data-reference-type="ref" data-reference="fig:architecture-overview"
                >4.1</a
              >.<a href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn30" role="doc-endnote">
            <p>
              Siehe Anhang
              <a href="#appendix:prettier" data-reference-type="ref" data-reference="appendix:prettier">7.2</a>.<a
                href="#fnref30"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn31" role="doc-endnote">
            <p>
              Vgl. Abschnitt
              <a
                href="#sec:evaluation-other-transpilers"
                data-reference-type="ref"
                data-reference="sec:evaluation-other-transpilers"
                >3.1.2</a
              >.<a href="#fnref31" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn32" role="doc-endnote">
            <p>
              Im Falle von TypeScript können die Definitionsdateien beispielsweise auch durch den TypeScript-Compiler
              automatisch erzeugt werden <a class="citation" href="#ref-TSC:OPTIONS">[45]</a>.<a
                href="#fnref32"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn33" role="doc-endnote">
            <p>
              Vgl. <em>Semantic Versioning</em> <a class="citation" href="#ref-SEMANTIC_VERSIONING">[107]</a>.<a
                href="#fnref33"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn34" role="doc-endnote">
            <p>
              Es wird jeweils der Grundtakt des Prozessors und nicht der maximal mögliche Wert durch dynamische
              Übertaktung angegeben.<a href="#fnref34" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn35" role="doc-endnote">
            <p>
              Application Programming Interface (API).<a href="#fnref35" class="footnote-back" role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
          <li id="fn36" role="doc-endnote">
            <p>
              Vgl. Übersetzungstabellen in Abschnitt
              <a href="#sec:flow-transpilation" data-reference-type="ref" data-reference="sec:flow-transpilation"
                >4.3.2</a
              >.<a href="#fnref36" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn37" role="doc-endnote">
            <p>
              Vgl. Tabelle
              <a href="#tab:flow-base-types" data-reference-type="ref" data-reference="tab:flow-base-types"
                >[tab:flow-base-types]</a
              >.<a href="#fnref37" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn38" role="doc-endnote">
            <p>
              Vgl. Quelltext
              <a href="#code:convert-flow-type" data-reference-type="ref" data-reference="code:convert-flow-type"
                >[code:convert-flow-type]</a
              >.<a href="#fnref38" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn39" role="doc-endnote">
            <p>
              Zum Beispiel: <span><code>function f(optional?: number = 10) {}</code></span
              >.<a href="#fnref39" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn40" role="doc-endnote">
            <p>
              Vgl. Tabelle
              <a
                href="#tab:correctness-comparison"
                data-reference-type="ref"
                data-reference="tab:correctness-comparison"
                >[tab:correctness-comparison]</a
              ><a href="#fnref40" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn41" role="doc-endnote">
            <p>
              Vgl. Abschnitt
              <a href="#sec:results-formatting" data-reference-type="ref" data-reference="sec:results-formatting"
                >5.3.5</a
              >.<a href="#fnref41" class="footnote-back" role="doc-backlink">↩︎</a>
            </p>
          </li>
          <li id="fn42" role="doc-endnote">
            <p>
              Vgl. Abschnitt
              <a href="#sec:formatting" data-reference-type="ref" data-reference="sec:formatting">4.5</a>.<a
                href="#fnref42"
                class="footnote-back"
                role="doc-backlink"
                >↩︎</a
              >
            </p>
          </li>
        </ol>
      </section>
    </main>
  </body>
</html>
