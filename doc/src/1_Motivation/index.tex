\chapter{Motivation}
\label{chap:motiviation}

\section{Historische Entwicklung und das Typsystem JavaScripts}

Als JavaScript\footnote{Anfangs unter dem Namen \textit{Mocha} entwickelt.} 1995 von Brendan Eich innerhalb von lediglich zehn Tagen als Bestandteils des Webbrowsers \enquote{Netscape Communicator} entworfen wurde~\autocite{severance:2012:js10days}, war nicht abzusehen, welch enorme Bedeutung die Sprache über 20 Jahre später inne haben wird: Heute wird JavaScript oft als die am weitesten verbreitete Programmiersprache der Welt betrachtet. Dies belegt beispielsweise die alljährliche Umfrage \enquote{Stack Overflow Developer Survey} der Programmierer-Plattform \enquote{Stack Overflow}, welche die Ergebnisse der weltweiten Befragung von circa 90.000 Software"=Entwicklern auswertet~\autocite{stackoverflow:survey:2019}. Bereits das siebte Jahr in Folge führt JavaScript dort die Rangliste der populärsten Programmiersprachen an. Der seit vielen Jahren anhaltende Trend dass zunehmend mehr Software als Webanwendung statt konventioneller Desktop-Anwendung konzipiert wird, hat stark zum Bedeutungszuwachs JavaScripts beigetragen~\autocite{taivalsaari:2017,casteleyn:2014:ria}. Neue Konzepte wie \enquote{Asynchronous JavaScript and XML} (AJAX)~\autocite{GARRET:AJAX} haben Teile der ehemals serverseitigen Anwendungslogik in den Client und damit in die Domäne von JavaScript verlagert. Mit Aufkommen der Laufzeitumgebung \enquote{Node.js}~\autocite{NODEJS} im Jahr 2009 hat sich die Sprache darüber hinaus von der Lingua Franca des Webbrowsers zu einer Alternative zu klassischen serverseitigen Programmiersprachen wie Java oder C\# entwickelt~\autocite{TILKOV:NODEJS}.

% - anfangs keine Vererbung etc.
% - global überall global
% - Subtiles Verhalten (level of wtf is high)
% - vergibt viel zu viel (keine exceptions)


Die heutige große Beliebtheit der Sprache steht in starkem Kontrast zu ihren Anfängen: Aus verschiedenen Gründen wurde JavaScript von professionellen Software"=Entwicklern zu Beginn als eine mangelhaft entworfene Programmiersprache betrachtet~\autocite{CROCKFORD:JS_POPULAR}. JavaScript galt als eine Sprache, die \enquote{nur von Amateuren}~\autocite{CROCKFORD:JS_MISUNDERSTOOD} genutzt wurde und besaß eine zweifelhafte Reputation~\autocite{THIEMANN:2005,THOMAS:2007}. Die uneinheitliche und teilweise fehlerbehaftete Implementierung in den frühen Webbrowsern und der Mangel an Entwicklungswerkzeugen wie Debuggern erschwerte die Programmierung von JavaScript-Anwendung enorm~\autocite{OREILLY:JS_HOW_DID_WE_GET_THERE}. Darüber hinaus behinderte die anfängliche Unbeständigkeit der Sprache und \enquote{schlechte Qualität}~\autocite{CROCKFORD:JS_MISUNDERSTOOD} der ersten ECMAScript-Spezifikationen\footnote{Im November 1996 beauftragte Netscape die Normungsorganisation \textit{Ecma International} eine formale Spezifikation von JavaScript zu erstellen. Diese wurde 1997 als \enquote{ECMA-262}~\autocite{ECMASCRIPT:1997} veröffentlicht.} eine breite Akzeptanz der Sprache in der Entwickler-Szene.

Auch das dynamische Typsystem von JavaScript ist umstritten, da es teilweise zu unerwarteten Ergebnissen führt und inkonsistent ist~\autocite{PRADEL:2015,RICHARDS:2010}. Jedem Wert eines JavaScript-Programms wird zur Laufzeit einer der folgenden sieben Typen zugeordnet, der festlegt wie der Wert interpretiert wird~\footcite[Abschn.~6.1]{ECMASCRIPT:2019}. Alle Datentypen außer \enquote{Object} sind hierbei primitiv, d.~h. atomar~\footcite[Abschn. 4.3.2]{ECMASCRIPT:2019}.

\begin{enumerate}
  \item \texttt{Undefined}: Undefinierte Werte
  \item \texttt{Null}: Nullwert
  \item \texttt{Boolean}: Boolesche Ausdrücke (\texttt{true} und \texttt{false})
  \item \texttt{String}: Zeichenketten
  \item \texttt{Symbol}: Eindeutige Bezeichner
  \item \texttt{Number}: Gleitkommazahlen
  \item \texttt{Object}: Alles Weitere (Funktionen, Objekte, Felder, usw.)
\end{enumerate}

% TODO \textit{Browser wars} -- Netscape Communicator vs Internet Explorer -- JavaScript vs. JScript

Tabelle~\ref{tab:js-type-coercion} veranschaulicht einige der überraschenden Effekte der impliziten Typumwandlung von JavaScript, indem verschiedene Ausdrücke mit ihren jeweiligen Gegenstücken in Python~\autocite{PYTHON3} und Ruby~\autocite{RUBY} verglichen werden. Sowohl Python, als auch Ruby sind dynamisch typisierte Skriptsprachen, die beide wie JavaScript in den Neunzigerjahren entstanden sind (1991 bzw. 1995).\\
In den ersten fünf Zeilen werden Feld- und Objektliterale durch den Konkatenationsoperator \enquote{\texttt{+}} verknüpft. Dieser Operator kann in JavaScript sowohl für die Addition, als auch die Verknüpfung \emph{beliebiger} anderer Typen verwendet werden. Während die Konkatenation von Zeichenketten und die Addition von Zahlen zweckmäßig ist, ist sie für die anderen Datentypen unsinnig, aber durch das dynamische Typsystem möglich. Die Argumente des Operators werden je nach Datentyp und ihrer Reihenfolge entsprechend den Regeln der Spezifikation~\footcite[Abschn.~12.8.3]{ECMASCRIPT:2019} zuerst implizit umgewandelt und daraufhin durch Addition oder String-Verkettung verknüpft. In Python und Ruby führt die Verwendung des Operators auf diese Weise zu einem Typfehler (Zeile 1-3).
In Zeile vier und fünf werden jeweils zwei Feldliterale konkateniert. In diesem Fall reihen viele dynamische Programmiersprachen wie auch Python und Ruby die Werte des ersten Felds an die des zweiten an. JavaScript hingegen konvertiert die Felder zu ihrer Repräsentation als Zeichenkette und konkateniert dieses daraufhin, anstatt die Werte des Feldes zu kombinieren.
Problematisch ist weiterhin das Verhalten des Vergleichsoperators \enquote{\texttt{==}}~\footnote{Vgl. \enquote{Abstract Equality Comparison}~\autocite[Abschn. 7.2.14]{ECMASCRIPT:2019}.}. Auch hier werden die Typen der Operator-Argumente automatisch entsprechend des Algorithmus der Spezifikation umgewandelt, um die Gleichheit der zugehörigen Werte zu überprüfen. Da die Regeln der Typumwandlung kompliziert und unintuitiv sind, verhält sich der Operator in vielen Fällen anders, als es Programmierer erwarten~\autocite{PRADEL:2015}. Deshalb wurde wurde mit der dritten Version der ECMAScript-Spezifikation~\autocite{ECMASCRIPT:1999} 1999 ein strikter Vergleichsoperator \enquote{\texttt{===}} eingeführt, welcher sowohl die Typ- als auch die Wertgleichheit überprüft~\footnote{Vgl. \enquote{Strict Equality Comparison}~\autocite[Abschn. 7.2.15]{ECMASCRIPT:2019}.}.
Das letzte Beispiel für die Inkonsistenz des Typsystems ist schließlich der \enquote{\texttt{typeof}}-Operator. Obwohl \enquote{\texttt{typeof undefined}} den Wert \enquote{\texttt{undefined}} zurückliefert, wird im Fall von \enquote{\texttt{null}} der mehrdeutige Wert \enquote{\texttt{object}} ausgegeben. Der Typ des entsprechenden Ausdrucks in Python und Ruby ist jeweils eindeutig.

\begin{table}[tb]
  \footnotesize
  \begin{tabularx}{\textwidth}{@{}p{5.5cm}XX@{}}
    \midrule
    \textbf{JavaScript} & \textbf{Python} & \textbf{Ruby} \\
    \midrule
    \texttt{\{\} + []}~~\Rightarrow~~\texttt{0} & \texttt{\{\} + []}~~\Rightarrow~~\texttt{TypeError} & \texttt{\{\} + []}~~\Rightarrow~~\texttt{TypeError} \\
    \texttt{[] + \{\}}~~\Rightarrow~~\texttt{'[object Object]'} & \texttt{[] + \{\}}~~\Rightarrow~~\texttt{TypeError} & \texttt{[] + \{\}}~~\Rightarrow~~\texttt{TypeError} \\
    \texttt{\{\} + \{\}}~~\Rightarrow\newline\-\hspace{0.5cm}\texttt{'[object Object][object Object]'} & \texttt{\{\} + []}~~\Rightarrow~~\texttt{TypeError} & \texttt{\{\} + []}~~\Rightarrow~~\texttt{TypeError} \\
    \texttt{[] + []}~~\Rightarrow~~\texttt{''} & \texttt{[] + []}~~\Rightarrow~~\texttt{[]} & \texttt{[] + []}~~\Rightarrow~~\texttt{[]} \\
    \texttt{[1, 3] + [5]}~~\Rightarrow~~\texttt{'1,35'} & \texttt{[1, 3] + [5]}~~\Rightarrow~~\texttt{[1, 3, 5]} & \texttt{[1, 3] + [5]}~~\Rightarrow~~\texttt{[1, 3, 5]} \\
    \texttt{[] == 0}~~\Rightarrow~~\texttt{true} & \texttt{[] == 0}~~\Rightarrow~~\texttt{false} & \texttt{[] == 0}~~\Rightarrow~~\texttt{false} \\
    \texttt{0 == '0'}~~\Rightarrow~~\texttt{true} & \texttt{0 == '0'}~~\Rightarrow~~\texttt{false} & \texttt{0 == '0'}~~\Rightarrow~~\texttt{false} \\
    \texttt{false == 'false'}~~\Rightarrow~~\texttt{false} & \texttt{false == 'false'}~~\Rightarrow~~\texttt{false} & \texttt{false == 'false'}~~\Rightarrow~~\texttt{false} \\
    \texttt{0 === '0'}~~\Rightarrow~~\texttt{false} & \texttt{0 == '0'}~~\Rightarrow~~\texttt{false} & \texttt{0 == '0'}~~\Rightarrow~~\texttt{false} \\
    \texttt{typeof null}~~\Rightarrow~~\texttt{'object'} & \texttt{type(None)}~~\Rightarrow~~\texttt{NoneType} & \texttt{nil.class}~~\Rightarrow~~\texttt{NilClass} \\
    \midrule
  \end{tabularx}
  \caption[Dynamische Typumwandlung verschiedener JavaScript-Ausdrücke]{Demonstration der dynamischen Typumwandlung verschiedener Ausdrücke in JavaScript im Vergleich zu Python und Ruby. (Node 12.6, Python 3.7, Ruby 2.6.)}
  \label{tab:js-type-coercion}
\end{table}

Natürlich stellen die ausgewählten Beispiele keine sinnvollen Programme dar, dennoch demonstrieren sie einige der fundamentalen Probleme des Typsystems von JavaScript. Die Abwärtskompatibilität der Programmiersprache ist aufgrund ihrer sehr weiten Verbreitung von immenser Wichtigkeit. Eine nachträgliche tiefgreifende Anpassung des Sprachkerns und des Typsystems ist äußerst schwierig, da viele bestehende JavaScript"=Programmen hierdurch unbrauchbar würden. Brendan Eich bezeichnete seinen 1995 in kurzer Zeit entwickelten JavaScript-Prototyp 2008 rückblickend als \enquote{fait accompli}~\autocite{EICH:POPULARITY}, also als eine \enquote{vollendete Tatsache}. Viele der anfänglichen Unzulänglichkeiten der Sprache wurde durch Erweiterungen der Spezifikation allmählich behoben. Dennoch bleibt die dynamische Ausprägung des Typsystems ein Hindernis für die Entwicklung umfangreicher, sicherer und gut wartbarer JavaScript-Anwendungen. Verschiedene Ansätze sind innerhalb der letzten Jahre entstanden, um JavaScript um statische Typsysteme zu erweitern und dieses Hindernis zu überwinden.

\section{Sinn und Nutzen statischer Typsysteme}

% TODO
Unbeabsichtigte, implizite Typumwandlungen zur Laufzeit eines Programms und falsche Annahmen über vorliegende Datenstrukturen sind häufige Ursache von Bugs. Eine explizite, statische Typisierung, wie sie beispielsweise in C++ oder Haskell vorliegt ist erstrebenswert, da sie viele Vorteile für den Software-Entwicklungsprozess und die Ausführungsgeschwindigkeit von Programmen bietet.
% Während in dynamischen Systemen Typen bei Bedarf automatisch ineinander umgewandelt werden, geschieht dies bei statischen Systemen je nach Striktheit entweder nur durch explizite Aufruf expliziter Sprachkonstrukte (\textit{\textit{type casts}}) oder nur, wenn die beteiligten Typen einander zugewiesen werden können.
Logik- und Flüchtigkeitsfehler im Quelltext können oftmals bereits vor Ausführung des Programms erkannt und behoben werden. Software"=Entwickler gewinnen Sicherheit und Zuversicht, dass Änderungen in umfangreichen Projekten keine unerwünschte Nebenwirkung verursachen, wodurch sich die Wartbarkeit der Software erhöht. Darüber hinaus zwingt die Deklaration expliziter Typen den Entwickler dazu die \emph{Intension} seines Programms klar zu formulieren, wodurch sich die Ausdruckskraft und Lesbarkeit des Codes verbessert. Durch eine vernünftige Typisierung wird der Quelltext weiterhin bereits grundlegend an Ort und Stelle dokumentiert (\enquote{\textit{inline documentation}}).


Überleitung: genau deswegen brauchen wir statische Typsysteme. Da hätten wir zwei...

\section{Zielsetzung und Aufbau der Arbeit}

% TODO
%  Erkennung neuer Bugs und Typfehler
%  Unterstützung externer Bibliotheken und Frameworks
%  Stabilität und Geschwindigkeit des Typsystems
%  Zukunftssicherheit und Transparenz der Technologie

Die vorliegende Masterarbeit beschäftigt sich mit Transpilierung statischer Typsysteme für JavaScript. Dabei werden zwei derzeit populäre Systeme betrachtet: einerseits Flow und andererseits TypeScript. Ziel der Arbeit ist die Entwicklung eines Transpilers, der den gesamten Quelltext eines JavaScript-Projekts von Flow in äquivalentes TypeScript übersetzt. Eine derartige Migration wird innerhalb des Unternehmens \textit{TeamShirts} angestrebt, da vermutet wird, dass TypeScript Flow hinsichtlich der Erkennung von Typfehlern, Performance und Unterstützung externer Software-Bibliotheken überlegen ist. Die Verifizierung dieser Hypothesen auf Grundlage empirischer Daten und der gesammelten Erfahrung während der Migration der Projekte ist Gegenstand der anschließenden Untersuchung.

Der strukturelle Aufbau der Arbeit ist wie folgt: Zunächst werden die benötigten Grundlagen hinsichtlich statischer Typsysteme für JavaScript und der Transpilierung von Quelltexten geschaffen. Anschließend wird die Ausgangslage der JavaScript-Projekte innerhalb des Unternehmens \textit{TeamShirts} analysiert und die Ziele der Migration sowie die Anforderungen an den geplanten Flow-Transpiler ausgeführt. Daraufhin werden Architektur und Details der Implementierung des Transpilers ausführlich betrachtet. Kapitel~\ref{chap:execution} beschreibt dann die Durchführung der Migration der realen JavaScript-Projekte mittels des Transpilers und legt die aufgetretenen Schwierigkeiten und gewonnen Erfahrungen darf. Die Ergebnisse der Migration werden im Anschluss ausgewertet und kritisch diskutiert. Weiterhin wird die Umsetzung vergleichbaren Transpilern gegenüber gestellt und hinsichtlich der Zielvorgabe bewertet. Schließlich wird ein Fazit der gesamten Arbeit gezogen und ein Ausblick über mögliche Erweiterungen gegeben.
