\chapter{Motivation}
\label{chap:motiviation}

\section{Historische Entwicklung}

Als JavaScript 1995 von Brendan Eich innerhalb von lediglich zehn Tagen als Bestandteils des Webbrowsers \enquote{Netscape Communicator} entworfen wurde~\autocite{severance:2012:js10days}, war nicht abzusehen, welch enorme Bedeutung die Sprache über 20 Jahre später inne haben wird: Heute wird JavaScript oft als die am weitesten verbreitete Programmiersprache der Welt betrachtet. Dies belegt beispielsweise die alljährliche Umfrage \enquote{Stack Overflow Developer Survey} der Programmierer-Plattform \enquote{Stack Overflow}, welche die Ergebnisse der weltweiten Befragung von circa 90.000 Software"=Entwicklern auswertet~\autocite{STACKOVERFLOW:SURVEY}. Bereits das siebte Jahr in Folge führt JavaScript dort die Rangliste der populärsten Programmiersprachen an. Der seit vielen Jahren anhaltende Trend dass zunehmend mehr Software als Webanwendung statt konventioneller Desktop-Anwendung konzipiert wird, hat stark zum Bedeutungszuwachs JavaScripts beigetragen~\autocite{TAIVALSAARI:2017,CASTELEYN:2014}. Neue Konzepte wie \enquote{Asynchronous JavaScript and XML} (AJAX)~\autocite{GARRET:AJAX} und \enquote{Single-page applications} (SPA) haben Teile der ehemals serverseitigen Anwendungslogik in den Client und damit in die Domäne von JavaScript verlagert. Mit Aufkommen der Laufzeitumgebung \enquote{Node.js}~\autocite{SOFTWARE:NODEJS} im Jahr 2009 hat sich die Sprache darüber hinaus von der Lingua Franca des Webbrowsers zu einer Alternative zu etablierten serverseitigen Programmiersprachen wie Java oder C\# entwickelt~\autocite{TILKOV:NODEJS}.

% - anfangs keine Vererbung etc.
% - global überall global
% - Subtiles Verhalten (level of wtf is high)
% - vergibt viel zu viel (keine exceptions)

Die heutige große Beliebtheit der Sprache steht in starkem Kontrast zu ihren Anfängen: Aus verschiedenen Gründen wurde JavaScript von professionellen Software"=Entwicklern zu Beginn als eine mangelhaft entworfene Programmiersprache betrachtet~\autocite{CROCKFORD:JS_POPULAR}. JavaScript galt als eine Sprache, die \enquote{nur von Amateuren}~\autocite{CROCKFORD:JS_MISUNDERSTOOD} genutzt wurde und besaß eine zweifelhafte Reputation~\autocite{THIEMANN:2005,THOMAS:2007}. Die uneinheitliche und teilweise fehlerbehaftete Implementierung in den frühen Webbrowsern und der Mangel an Entwicklungswerkzeugen wie Debuggern erschwerte die Programmierung von JavaScript-Anwendung enorm~\autocite{OREILLY:JS_HOW_DID_WE_GET_THERE}. Darüber hinaus behinderte die anfängliche Unbeständigkeit der Sprache und \enquote{schlechte Qualität}~\autocite{CROCKFORD:JS_MISUNDERSTOOD} der ersten ECMAScript-Spezifikationen~\autocite{ECMASCRIPT:1997} eine breite Akzeptanz der Sprache in der Entwickler-Szene. ECMAScript stellt die formale Spezifikation JavaScripts dar. Netscape beauftrage die Normungsorganisation \textit{Ecma International} im November 1996 mit der Erstellung dieser~\autocite{ECMASCRIPT:1997}. Im Jahr darauf wurde der Standard unter der Bezeichnung \enquote{ECMA-262} veröffentlicht.

\section{JavaScripts dynamisches Typsystem}

Ein weiterer Aspekt JavaScripts, der oft kontrovers betrachtet wird ist, das dynamische Typsystem, da dieses teilweise zu unerwarteten Ergebnissen führt und sich inkonsistent verhält~\autocite{PRADEL:2015,RICHARDS:2010}. Eine dynamische Typisierung ist dadurch charakterisiert, dass jedem Wert zur \emph{Laufzeit} ein Typ zugewiesen wird und sich dieser je nach Striktheit des Typsystems zu einem späteren Zeitpunkt implizit oder explizit ändern kann.
Das Typsystem von JavaScript wird manchmal auch als \enquote{schwach} bezeichnet. Eine solche Kategorisierung in \enquote{schwache} und \enquote{starke} Typsysteme ist umstritten, da keine allgemein anerkannte Definition dieser unpräzisen Klassifizierung existiert. Im Allgemeinen wird von starker Typisierung gesprochen, wenn eine sehr strikte Typisierung vorliegt, d.~h. wenn im Extremfall der Typ einer Variablen wie beispielsweise in Haskell~\autocite{HASKELL} lediglich durch explizite Sprachkonstrukte umgewandelt werden kann. Werden Typen hingegen wie in JavaScript bei Bedarf implizit in andere Typen konvertiert, so wird dies als schwache Typisierung angesehen.
Die Spezifikation von JavaScript beschreibt die folgenden sieben Datentypen~\footcite[Abschn.~6.1]{ECMASCRIPT:2019}. Diese legen fest wie Werte des Programms interpretiert werden und welche Operationen mit ihnen möglich sind. Alle Datentypen außer \enquote{Object} sind dabei primitiv, d.~h. nicht weiter zerlegbar (atomar)~\footcite[Abschn. 4.3.2]{ECMASCRIPT:2019}.

\begin{enumerate}
  \item \texttt{Undefined}: Undefinierte Werte
  \item \texttt{Null}: Nullwert
  \item \texttt{Boolean}: Wahrheitswerte
  \item \texttt{String}: Zeichenketten
  \item \texttt{Symbol}: Eindeutige Bezeichner
  \item \texttt{Number}: Gleitkommazahlen
  \item \texttt{Object}: Alles Weitere (Felder, Objekte, Funktionen, usw.)
\end{enumerate}

Tabelle~\ref{tab:js-type-coercion} veranschaulicht einige der überraschenden Effekte der impliziten Typumwandlung von JavaScript, indem verschiedene Ausdrücke mit ihren jeweiligen Gegenstücken in Python~\autocite{PYTHON3} und Ruby~\autocite{RUBY} verglichen werden. Sowohl Python, als auch Ruby sind dynamisch typisierte Skriptsprachen, die beide wie JavaScript in den Neunzigerjahren entstanden sind (1991 bzw. 1995).
In den ersten drei Zeilen werden Feld- und Objektliterale durch den Konkatenationsoperator \enquote{\texttt{+}} verknüpft. Dieser Operator kann in JavaScript sowohl für die Addition, als auch die Verknüpfung \emph{beliebiger} anderer Typen verwendet werden. Während die Konkatenation von Zeichenketten und die Addition von Zahlen zweckmäßig ist, ist sie für die anderen Datentypen unsinnig, aber durch das dynamische Typsystem möglich. Die Argumente des Operators werden je nach Datentyp und ihrer Reihenfolge entsprechend den Regeln der Spezifikation~\footcite[Abschn.~12.8.3]{ECMASCRIPT:2019} zuerst implizit umgewandelt und daraufhin durch Addition oder String-Verkettung verknüpft. In Python und Ruby führt die Verwendung des Operators auf diese Weise zu einem Typfehler. In Zeile vier und fünf werden jeweils zwei Feldliterale konkateniert. In diesem Fall reihen viele dynamische Programmiersprachen, wie auch Python und Ruby, die Werte des ersten Felds an die des zweiten an. JavaScript hingegen konvertiert die Felder unsinnigerweise zu ihrer Repräsentation als Zeichenkette und konkateniert dieses daraufhin, anstatt die Werte des Feldes zu kombinieren.

\begin{table}[tb]
  \footnotesize
  \begin{tabularx}{\textwidth}{@{}p{5.5cm}XX@{}}
    \midrule
    \libertineSB{JavaScript} & \libertineSB{Python} & \libertineSB{Ruby} \\
    \midrule
    \texttt{\{\} + []}~~$\Rightarrow$~~\texttt{0} & \texttt{\{\} + []}~~$\Rightarrow$~~\texttt{TypeError} & \texttt{\{\} + []}~~$\Rightarrow$~~\texttt{TypeError} \\
    \texttt{[] + \{\}}~~$\Rightarrow$~~\texttt{'[object Object]'} & \texttt{[] + \{\}}~~$\Rightarrow$~~\texttt{TypeError} & \texttt{[] + \{\}}~~$\Rightarrow$~~\texttt{TypeError} \\
    \texttt{\{\} + \{\}}~~$\Rightarrow$\newline\-\hspace{0.5cm}\texttt{'[object Object][object Object]'} & \texttt{\{\} + []}~~$\Rightarrow$~~\texttt{TypeError} & \texttt{\{\} + []}~~$\Rightarrow$~~\texttt{TypeError} \\
    \texttt{[] + []}~~$\Rightarrow$~~\texttt{''} & \texttt{[] + []}~~$\Rightarrow$~~\texttt{[]} & \texttt{[] + []}~~$\Rightarrow$~~\texttt{[]} \\
    \texttt{[1, 3] + [5]}~~$\Rightarrow$~~\texttt{'1,35'} & \texttt{[1, 3] + [5]}~~$\Rightarrow$~~\texttt{[1, 3, 5]} & \texttt{[1, 3] + [5]}~~$\Rightarrow$~~\texttt{[1, 3, 5]} \\
    \texttt{[] == 0}~~$\Rightarrow$~~\texttt{true} & \texttt{[] == 0}~~$\Rightarrow$~~\texttt{false} & \texttt{[] == 0}~~$\Rightarrow$~~\texttt{false} \\
    \texttt{0 == '0'}~~$\Rightarrow$~~\texttt{true} & \texttt{0 == '0'}~~$\Rightarrow$~~\texttt{false} & \texttt{0 == '0'}~~$\Rightarrow$~~\texttt{false} \\
    \texttt{false == 'false'}~~$\Rightarrow$~~\texttt{false} & \texttt{false == 'false'}~~$\Rightarrow$~~\texttt{false} & \texttt{false == 'false'}~~$\Rightarrow$~~\texttt{false} \\
    \texttt{0 === '0'}~~$\Rightarrow$~~\texttt{false} & \texttt{0 == '0'}~~$\Rightarrow$~~\texttt{false} & \texttt{0 == '0'}~~$\Rightarrow$~~\texttt{false} \\
    \texttt{typeof null}~~$\Rightarrow$~~\texttt{'object'} & \texttt{type(None)}~~$\Rightarrow$~~\texttt{NoneType} & \texttt{nil.class}~~$\Rightarrow$~~\texttt{NilClass} \\
    \midrule
  \end{tabularx}
  \caption[Dynamische Typumwandlung verschiedener JavaScript-Ausdrücke]{Demonstration der dynamischen Typumwandlung verschiedener Ausdrücke in JavaScript im Vergleich zu Python und Ruby. (Node 12.6, Python 3.7, Ruby 2.6.)}
  \label{tab:js-type-coercion}
\end{table}

Problematisch ist weiterhin das Verhalten des Vergleichsoperators \enquote{\texttt{==}}\footnote{Vgl. \textit{Abstract Equality Comparison}~\autocite[Abschn. 7.2.14]{ECMASCRIPT:2019}.}. Auch hier werden die Typen der Operator-Argumente automatisch entsprechend des Algorithmus der Spezifikation umgewandelt, um die Gleichheit der zugehörigen Werte zu überprüfen. Da die Regeln der Typumwandlung kompliziert und unintuitiv sind, verhält sich der Operator in vielen Fällen anders, als es Programmierer erwarten~\autocite{PRADEL:2015}. Deshalb wurde wurde mit der dritten Version der ECMAScript-Spezifikation~\autocite{ECMASCRIPT:1999} 1999 ein strikter Vergleichsoperator \enquote{\texttt{===}} eingeführt, welcher sowohl die Typ- als auch die Wertgleichheit überprüft\footnote{Vgl. \textit{Strict Equality Comparison}~\autocite[Abschn. 7.2.15]{ECMASCRIPT:2019}.}.
Das letzte Beispiel für die Inkonsistenz des Systems ist schließlich der \enquote{\texttt{typeof}}-Operator, welcher den derzeitigen Typ einer Variable zurückliefert. Obwohl der Operator den korrekten Wert für alle anderen Fälle zurückliefert, wird für \enquote{\texttt{null}} der mehrdeutige Wert \enquote{\texttt{object}} ausgegeben. Das Resultat der entsprechenden Ausdrücke in Python und Ruby ist eindeutig.

Natürlich stellen die ausgewählten Beispiele keine sinnvollen Programme dar, dennoch demonstrieren sie einige der fundamentalen Probleme des Typsystems von JavaScript. Die Abwärtskompatibilität der Sprache ist aufgrund ihrer sehr weiten Verbreitung auf vielen verschiedenen Laufzeitumgebungen von immenser Wichtigkeit. Eine nachträgliche, tiefgreifende Anpassung des Sprachkerns und des Typsystems ist äußerst schwierig, da viele bestehende JavaScript"=Programmen hierdurch unbrauchbar würden~\autocite[1]{CROCKFORD:JS_GOOD_PARTS}. Brendan Eich bezeichnete seinen 1995 in kurzer Zeit entwickelten JavaScript-Prototyp 2008 rückblickend als \enquote{fait accompli}~\autocite{EICH:POPULARITY}, also als eine \enquote{vollendete Tatsache}. Viele der anfänglichen Unzulänglichkeiten der Sprache konnten durch Erweiterungen der Spezifikation und zunehmend konsistenter Implementierungen nach und nach behoben werden. Dennoch bleibt die dynamische Ausprägung des Typsystems ein Hindernis für die Entwicklung umfangreicher, sicherer und gut wartbarer JavaScript-Anwendungen. Über die Jahre sind aus diesem Grund verschiedene Ansätze entstanden, um diese Problematik zu überwinden und JavaScript um ein \emph{statisches} Typsystem zu erweitern.

\section{Sinn und Nutzen statischer Typsysteme}

Eine explizite, statische Typisierung wie sie beispielsweise in C++ oder Java vorliegt, bietet viele Vorteile für den Software-Entwicklungsprozess: Im Gegensatz zu einer dynamischen Typsystem wird der Typ einer Variable in statischen Systemen \emph{explizit} deklariert oder kann selbstständig inferiert (abgeleitet) werden. Damit wird die Wertebereich einer Variable durch ihren Typ bestimmt und dynamische Typumwandlungen eingeschränkt.
% TODO: CITATION NEEDED (like a lot)
% TODO: Überarbeiten
Ein gewichtiges Argument für den Einsatz statischer Typsysteme ist die erhöhte Sicherheit während des Programmierens~\autocite{CORNELL:STRONG_TYPING}. Da der Compiler mittels statischer Analyse überprüfen kann, ob bei Zuweisungen, Funktionsaufrufen und Rückgabewerten Typfehler auftreten, können Logik- und Flüchtigkeitsfehler reduziert werden. Wenn alle Datenstrukturen typisiert sind können darüber hinaus irrtümliche Annahmen über diese bereits vor der Ausführung des Programms erkannt und zugehörige Fehler behoben werden. Auf diese Weise können Laufzeitfehler verringert und die Qualität der Software gesteigert werden. Weiterhin ist es möglich die Einschränkungen und Regeln der gegebenen Anwendungsdomäne mittels eines Typsystems präzise zu modellieren und deren Einhaltung zu erzwingen. Durch eine statische Typisierung gewinnen Software"=Entwickler die Sicherheit und Zuversicht, dass Änderungen in umfangreichen Projekten keine unerwünschte Nebenwirkung verursachen (\textit{Refactoring}).
% TODO: steile Thesen!
% Mittels statischer Analyse werden Typfehler und damit auch gegebenenfalls semantische Probleme unmittelbar erkannt. Infolgedessen steigert sich die Wartbarkeit der Anwendung.
% TODO: einfacherer Einstieg für Anfänger
Des Weiteren zwingt die Deklaration expliziter Typen den Entwickler dazu die \emph{Intension} seines Programms klar zu formulieren~\autocite[96]{WALDMANN:PPS}, wodurch sich die Ausdruckskraft und Lesbarkeit des Codes erhöht. Durch eine vernünftige Typisierung wird der Quelltext darüber hinaus bereits grundlegend an Ort und Stelle dokumentiert (\textit{inline documentation})~\footcite[Abschn. 6.1.1]{MITCHELL:CONCEPTS}.

Schließlich hat die Verwendung statischer Typsysteme auch Vorteile für die Effizienz und Ausführungsgeschwindigkeit von Software. Da bereits im Vorfeld bekannt ist, welche Typen verschiedene Datenstrukturen besitzen, kann deren Speicherung und Zugriff optimiert werden~\footcite[Abschn. 6.1.3]{MITCHELL:CONCEPTS}. Damit entfallen aufwändige Überprüfungen des Laufzeitsystems, die eine dynamische Typisierung erlauben.

\section{Zielsetzung und Aufbau der Arbeit}

Die vorliegende Masterarbeit beschäftigt sich mit Transpilierung statischer Typsysteme für JavaScript. Dabei werden zwei derzeit populäre Systeme betrachtet, welche eine statische Typisierung in JavaScript ermöglichen: einerseits Flow~\autocite{FLOW_PAPER} und andererseits TypeScript~\autocite{TYPESCRIPT_SPEC}. Ziel der Arbeit ist die Entwicklung eines Transpilers, der den gesamten Quelltext eines JavaScript-Projekts von Flow in äquivalenten TypeScript-Code übersetzt. Eine derartige Migration des eingesetzen Typsystems wird innerhalb des Unternehmens \textit{TeamShirts}~\footnote{Siehe Abschnitt~\ref{sec:status-quo}.} angestrebt, da angenommen wird, dass TypeScript verschiedener Vorteile gegenüber Flow aufweist. Es wird vermutet, dass TypeScript Typfehler und Bugs in höherem Maße erkennt und externe Software-Bibliotheken und Frameworks besser unterstützt. Weiterhin wird gemutmaßt, dass TypeScript Flow hinsichtlich Stabilität, Performance und Zukunftssicherheit überlegen ist. Die Verifizierung dieser Thesen auf Grundlage empirischer Daten und der gesammelten Erfahrung während der Migration der Projekte ist Gegenstand der anschließenden Untersuchung.

Der Aufbau der Arbeit gliedert sich wie folgt: Nachfolgend werden zunächst die benötigten Grundlagen hinsichtlich statischer Typsysteme für JavaScript und der Transpilierung von Programmen geschaffen. Anschließend wird die Ausgangslage der JavaScript-Projekte von \textit{TeamShirts} analysiert, die Ziele des Wechsels von Flow zu TypeScript erläutert und die Anforderungen an den geplanten Transpiler ausgeführt. Daraufhin werden Architektur und Details der Implementierung des Transpilers umfassend betrachtet. In Kapitel~\ref{chap:execution} wird dann die Durchführung der Migration der JavaScript-Projekte mittels des Transpilers beschrieben. Auch werden dort die aufgetretenen Schwierigkeiten und gewonnen Erfahrungen dargelegt. Die Ergebnisse der Migration werden im Anschluss ausgewertet und kritisch diskutiert. Weiterhin wird die Umsetzung vergleichbaren, bestehenden Werkzeugen gegenüber gestellt und hinsichtlich der Zielvorgabe bewertet. Schließlich wird ein Fazit der gesamten Arbeit gezogen und ein Ausblick über mögliche Erweiterungen gegeben.
