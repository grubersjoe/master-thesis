\chapter{Motivation}

\section{JavaScripts Typsystem}

Als JavaScript 1995 von Brendan Eich innerhalb von lediglich zehn Tagen als Bestandteils des Webbrowsers \textit{Netscape Communicator} entworfen wurde~\autocite{severance:2012:js10days}, war nicht abzusehen, welch enorme Bedeutung die Sprache über 20 Jahre später inne haben wird: Heute wird JavaScript oft als die am weitesten verbreitete Programmiersprache der Welt betrachtet. Dies belegt beispielsweise die alljährliche Umfrage \enquote{Stack Overflow Developer Survey} der Programmierer-Plattform \enquote{Stack Overflow}, welche die Ergebnisse der weltweiten Befragung von circa 90.000 Software-Entwicklern auswertet~\autocite{stackoverflow:survey:2019}. Bereits das siebte Jahr in Folge führt JavaScript dort die Rangliste der populärsten Programmiersprachen an.
Der seit vielen Jahren anhaltende Trend, dass zunehmend mehr Software als Webanwendung statt konventioneller Desktop-Anwendung konzipiert wird, hat wesentlich zum Bedeutungszuwachs JavaScripts beigetragen~\autocite{taivalsaari:2017}\autocite{casteleyn:2014:ria}. Mit Aufkommen der Laufzeitumgebung \enquote{Node.js}~\autocite{nodejs} hat sich die JavaScript weiterhin von der Universalsprache des Webbrowsers zu einer ernst zu nehmenden Alternative zu klassischen serverseitigen Programmiersprachen wie Java oder C\# entwickelt~\autocite{TILKOV:NODEJS}.

Die heutige große Beliebtheit der Sprache steht in starken Kontrast zu ihren Anfängen: Aufgrund der zu Beginn schlechten Qualität~\autocite{CROCKFORD:JS_MISUNDERSTOOD} der ECMAScript-Spezifikation~\autocite{ECMASCRIPT:1997}, der sehr uneinheitlichen Implementierung in den verschiedenen Webbrowsern und des dynamischen, inkonsistenten Typsystems wurde JavaScript von professionellen Software-Entwicklern zu Beginn als eine mangelhaft entworfene Programmiersprache betrachtet~\autocite{oreilly:2001:js}. JavaScript galt als eine Sprache, die nur von \enquote{Amateuren}~\autocite{CROCKFORD:JS_MISUNDERSTOOD} genutzt wurde. Das Typsystem der Skriptsprache ist notorisch bekannt für die impliziten, z.~.T inkonsistenten Typumwandlungen von Variablen. Der folgende Quelltext veranschaulicht einige dieser Inkonsistenzen und überraschenden Effekte anhand einiger Beispiele:

\bigskip
\begin{listing}[!h]
\begin{jscode}
// Array-Literal plus Array-Literal
[] + []  // -> '' (leerer String)

// Array-Literal plus Objekt-Literal
[] + {}  // -> '[object Object]'

// Erwartung: Plus-Operation sollte kommutativ sein
{} + []  // -> jedoch: 0

// Objekt-Literal plus Objekt-Literal
{} + {}  // -> '[object Object][object Object]'
\end{jscode}
\caption{Vergleich der zwei Ansätze für statische Typisierung von JavaScript mit Flow (oben) und TypeScript (unten).}
\label{code:example}
\end{listing}



% Ursprünglich war die Skriptsprache lediglich als ergänzendes Werkzeug gedacht, um den Zugriff auf das \emph{Document Object Model} (DOM) von Websites zu ermöglichen und diese dynamischer zu gestalten. Die zu Anfang sehr inkonsistente Implementierung der Sprache in den verschiedenen Webbrowsern und die schwache Typisierung JavaScripts war (und ist) Grund für große Frustration und anfängliche Ablehnung der Sprache seitens professioneller Software-Entwickler~\autocite{oreilly:2001:js}.


% Historische Entwicklung usw blabla. Warum ist das Typsystem eher nicht so gut?~\autocite{severance:2012:js10days}

\section{Sinnhaftigkeit statischer Typsysteme}

Unbeabsichtigte, implizite Typumwandlungen zur Laufzeit eines Programms und falsche Annahmen über vorliegende Datenstrukturen sind häufige Ursache von Bugs. Eine explizite, statische Typisierung, wie sie beispielsweise in C++ oder Haskell vorliegt ist erstrebenswert, da sie viele Vorteile für den Software-Entwicklungsprozess bietet:\\
Logik- und Flüchtigkeitsfehler im Quelltext können oftmals bereits vor Ausführung des Programms erkannt und behoben werden. Software-Entwickler gewinnen Sicherheit und Zuversicht, dass Änderungen in umfangreichen Projekten keine unerwünschte Nebenwirkung verursachen, wodurch sich die Wartbarkeit der Software erhöht. Darüber hinaus zwingt die Deklaration expliziter Typen den Programmierer dazu seine \emph{Intension} klar zu formulieren, wodurch sich die Ausdruckskraft des Codes verbessert. Durch eine vernünftige Typisierung wird der Quelltext weiterhin bereits grundlegend dokumentiert (\enquote{\textit{inline documentation}}).


Überleitung: genau deswegen brauchen wir statische Typsysteme. Da hätten wir zwei...

\section{Zielsetzung und Aufbau der Arbeit}
