\chapter{Motivation}
\label{chap:motiviation}

\section{Historische Entwicklung}

Als JavaScript 1995 von Brendan Eich in lediglich zehn Tagen als Bestandteils des Webbrowsers \enquote{Netscape Communicator} entworfen wurde~\autocite{severance:2012:js10days}, war nicht abzusehen, welch enorme Bedeutung die Sprache über 20 Jahre später inne haben würde: Heute wird JavaScript oft als die am weitesten verbreitete Programmiersprache der Welt angesehen~\autocite{PAULSON:2007,CROCKFORD:JS_POPULAR}. Dies belegt beispielsweise die alljährliche Umfrage \enquote{\textit{Stack Overflow Developer Survey}} der Programmierer-Plattform \enquote{Stack Overflow}, welche die Ergebnisse der weltweiten Befragung von circa 90.000 Software"=Entwicklern auswertet~\autocite{STACKOVERFLOW:SURVEY}. Bereits das siebte Jahr in Folge führt JavaScript dort die Rangliste der populärsten Programmiersprachen an. Der seit vielen Jahren anhaltende Trend, dass zunehmend mehr Software als Webanwendung statt konventioneller Desktop-Anwendung konzipiert wird, hat die Bedeutung von JavaScript stark erhöht~\autocite{TAIVALSAARI:2017,CASTELEYN:2014}. Neue Konzepte wie \enquote{\textit{Asynchronous JavaScript and XML}} (AJAX)~\autocite{GARRET:AJAX} und \enquote{\textit{Single-page applications}} (SPA) haben Teile der ehemals serverseitigen Anwendungslogik in den Client und damit in die Domäne von JavaScript verlagert.
% Mit Aufkommen der Laufzeitumgebung \textit{Node.js}~\autocite{SOFTWARE:NODEJS} im Jahr 2009 hat sich die Sprache darüber hinaus von der Lingua Franca des Webbrowsers zu einer Alternative gegenüber etablierten serverseitigen Programmiersprachen wie Java oder PHP entwickelt~\autocite{TILKOV:NODEJS}.

Die heutige große Beliebtheit der Sprache steht in starkem Kontrast zu ihren Anfängen. Zunächst besaß JavaScript eine zweifelhafte Reputation und wurde aus verschiedenen Gründen von professionellen Software"=Entwicklern als eine mangelhaft entworfene Programmiersprache angesehen~\autocite{CROCKFORD:JS_POPULAR}: Die uneinheitliche und teilweise fehlerbehaftete Implementierung in den frühen Webbrowsern und der Mangel an Entwicklungswerkzeugen wie Debuggern erschwerte die Programmierung von JavaScript-Anwendung enorm~\autocite{OREILLY:JS_HOW_DID_WE_GET_THERE}. Darüber hinaus behinderte die anfängliche Unbeständigkeit der Sprache und die \enquote{schlechte Qualität}~\autocite{CROCKFORD:JS_MISUNDERSTOOD} der ersten ECMAScript\footnote{\textit{ECMAScript} ist der Name der formalen Spezifikation von JavaScript und geht auf die Normungsorganisation \textit{Ecma International} zurück. Netscape beauftrage diese im November 1996 mit der Erstellung des Standards, welcher im Jahr darauf unter der Bezeichnung \enquote{ECMA-262} veröffentlicht wurde~\autocite{ECMASCRIPT:1997}.}-Spezifikationen~\autocite{ECMASCRIPT:1997} eine breite Akzeptanz der Sprache in der damaligen Entwickler-Szene. Auch das dynamische Typsystem von JavaScript wird bis heute kritisch betrachtet, da es die Entwicklung sicherer und korrekter Software erschwert sowie teilweise zu unerwarteten Ergebnissen führt (vgl. Tabelle~\ref{tab:js-type-coercion})~\autocite{NIKHIL:2014,PRADEL:2015}. Im Folgenden soll dieser Aspekt näher beleuchtet werden, um die Problematik zu verdeutlichen.

\section{JavaScripts dynamische Typisierung}

\subsection{Charakterisierung}

Eine dynamische Typisierung ist dadurch charakterisiert, dass jedem Wert der Programmiersprache zur \emph{Laufzeit} ein Typ zugewiesen wird und sich dieser je nach Striktheit des Typsystems zu einem späteren Zeitpunkt implizit oder explizit ändern kann~\autocite[45]{WALDMANN:PPS}. Typfehler werden dabei durch dynamische Überprüfungen der Laufzeitumgebung erkannt~\autocite[37]{CARDELLI:TYPE_SYSTEMS}. In JavaScript wird der Typ von Werten bei Bedarf automatisch implizit umgewandelt (\emph{type coercion})~\autocite{RICHARDS:2010}. Einerseits kann eine derartige Flexibilität den Entwicklungsprozess beschleunigen~\autocite[1]{FLOW:PAPER}, andererseits birgt dies das Risiko von Laufzeitfehlern, da Typverletzungen erst bei der Ausführung des Programms festgestellt werden können~\autocite{ANDERSON:2005}. Weil nicht immer offensichtlich ist, welche Datentypen die Ausdrücke in Quelltexten besitzen, ist die Programmierung so fehleranfällig. Problematisch für die Entwicklung korrekter Software ist darüber hinaus, dass JavaScript viele Operationen, die traditionell als dynamischer Typfehler gelten, nicht als solche behandelt und die Programmausführung fortsetzt~\autocite{NIKHIL:2014}. Beispielsweise kann auf nicht-existente Attribute von Objekten zugegriffen werden, ohne dass dies eine Typverletzung verursacht.

Die ECMAScript-Spezifikation definiert die folgenden sieben Datentypen~\autocite[25]{ECMASCRIPT:2019}. Diese legen fest, wie Werte des Programms interpretiert werden, welchen Wertebereich sie umfassen und welche Operationen mit ihnen möglich sind. Alle Datentypen außer \texttt{Object} sind dabei primitiv, das heißt nicht weiter zerlegbar (atomar)~\autocite[8]{ECMASCRIPT:2019}.

\pagebreak
\begin{enumerate}
  \item \code{Undefined}: Undefinierte Werte
  \item \code{Null}: Nullwert
  \item \code{Boolean}: Boolesche Werte
  \item \code{String}: Zeichenketten
  \item \code{Symbol}: Eindeutige Bezeichner
  \item \code{Number}: Gleitkommazahlen
  \item \code{Object}: Alles Weitere (Felder, Funktionen, Objekte, usw.)
\end{enumerate}

% JavaScripts Typsystem wird manchmal auch als \enquote{\emph{schwach}} bezeichnet. Eine solche Kategorisierung in \enquote{schwache} und \enquote{starke} Typsysteme ist umstritten, da keine allgemein anerkannte Definition dieser unpräzisen Klassifizierung existiert~\autocite{CARDELLI:TYPE_SYSTEMS}. Im Allgemeinen wird von starker Typisierung gesprochen, wenn eine strikte Typisierung vorliegt, d.~h. wenn im Extremfall der Typ einer Variablen \emph{lediglich} durch explizite Sprachkonstrukte wie beispielsweise in Haskell umgewandelt werden kann~\autocite{HASKELL}. Werden Typen hingegen wie in JavaScript bei Bedarf implizit in andere Typen konvertiert, so wird dies als schwache Typisierung angesehen.

\subsection{Implizite Typumwandlung}

Nachfolgend sollen einige der kontroversen Effekte der impliziten Typumwandlung in Java"=Script anhand verschiedener Beispiele in Tabelle~\ref{tab:js-type-coercion} veranschaulicht werden, indem die Ausdrücke mit ihren jeweiligen Gegenstücken in Python~\autocite{PYTHON3} und Ruby~\autocite{RUBY} verglichen werden. Python und Ruby sind dynamisch typisierte Skriptsprachen, die beide wie JavaScript in den Neunzigerjahren entstanden sind (1991 bzw. 1995).

In den ersten drei Zeilen der Tabelle werden Feld- und Objektliterale durch den Konkatenationsoperator \code{+} verknüpft. Dieser Operator kann in JavaScript sowohl für die Addition, als auch für die Verknüpfung \emph{beliebiger} anderer Typen verwendet werden. Das Ergebnis der Operation wird dabei durch Algorithmen innerhalb der Spezifikation~\autocite[220]{ECMASCRIPT:2019} festgelegt. Entsprechend dieser Regeln werden die Argumente des Operators je nach Ausgangsdatentyp und deren Reihenfolge zuerst implizit umgewandelt und daraufhin durch Addition oder String-Verkettung verknüpft. Während die Operation in JavaScript für die Konkatenation von Zeichenketten und die Addition von Zahlen zweckmäßig ist, führt sie bei anderen Argumenttypen zu unvorhergesehenen Ergebnissen. In Python und Ruby resultiert die analoge Verwendung des Operators in einen Typfehler, da derartige Ausdrücke in diesen Sprachen ungültig sind. Die Ablehnung solcher Programme durch das Laufzeitsystem ist nützlich, weil auf diese Weise Fehler unmittelbar erkannt werden können.
In Zeile 4~f. werden jeweils zwei Feldliterale konkateniert. In diesem Fall reihen viele dynamische Programmiersprachen, wie auch Python und Ruby, die Werte des zweiten Felds an die des ersten an. JavaScript konvertiert die Felder hingegen zu ihrer Repräsentation als Zeichenkette und konkateniert dieses daraufhin, statt die Werte des Feldes zu kombinieren.

% \medbreak
\input{src/1_Motivation/tables/type-coercion}

Auch beim Vergleichsoperator \texttt{==}\footnote{Vgl. \textit{Abstract Equality Comparison}~\autocite[68]{ECMASCRIPT:2019}.} (Zeile 6 ff.) werden die Typen der Operatorargumente automatisch entsprechend des Algorithmus der Spezifikation umgewandelt, um die Gleichheit der zugehörigen Werte zu überprüfen. \citeauthor{PRADEL:2015} argumentieren, dass die Regeln der impliziten Typumwandlung in JavaScript von Programmierern oft als kompliziert und unintuitiv wahrgenommen werden, sodass der Vergleich von Werten zu teilweise nicht unmittelbar nachvollziehbaren Ergebnissen führt~\autocite{PRADEL:2015}.
Mit der dritten Version der ECMAScript-Spezifikation~\autocite{ECMASCRIPT:1999} wurde 1999 ein strikter Vergleichsoperator \code{===} eingeführt, der die Überprüfung sowohl der Typ- als auch der Wertgleichheit ermöglicht und damit mehr Sicherheit bietet\footnote{Vgl. \textit{Strict Equality Comparison}~\autocite[68]{ECMASCRIPT:2019}.} (vgl. Zeile 7 versus 9).
Das letzte Beispiel für die Inkonsistenz des Systems ist schließlich der \code{typeof}-Operator, welcher den momentanen Typ eines Programmelements zurückliefert. Obwohl der Operator den korrekten Wert für alle anderen Fälle zurückliefert, wird für \code{null} der mehrdeutige Wert \code{object} ausgegeben. Das Resultat der entsprechenden Ausdrücke in Python und Ruby ist dagegen eindeutig.

Ungeachtet dessen, dass die ausgewählten Beispiele keine sinnvollen, vollständigen Programme sind, demonstrieren sie einige der umstrittenen Aspekte des Typsystems von JavaScript. Die Abwärtskompatibilität der Sprache ist aufgrund ihrer weiten Verbreitung auf vielen verschiedenen Laufzeitumgebungen von großer Bedeutung. Deshalb ist eine nachträgliche, tiefgreifende Anpassung des Typsystems und des Sprachkerns schwierig, weil viele bestehende JavaScript"=Programmen hierdurch unbrauchbar würden~\autocite[1]{CROCKFORD:JS_GOOD_PARTS}. Brendan Eich bezeichnet seinen 1995 in kurzer Zeit entwickelten Prototyp 2008 rückblickend als \enquote{fait accompli}~\autocite{EICH:POPULARITY}, also als eine \enquote{vollendete Tatsache}.

\section{Motivation für statische Typsysteme}

Viele der anfänglichen Unzulänglichkeiten der Sprache konnten durch Erweiterungen der Spezifikation und zunehmend konsistenter Implementierungen nach und nach behoben werden. Swamy et al. führen aber aus, dass JavaScripts dynamisches Typsystem weiterhin ein Hindernis für die Entwicklung sicherer und korrekter Anwendungen darstellen kann~\autocite{NIKHIL:2014}. Auch Bierman et al. vertreten die These, dass JavaScript nach wie vor ungeeignet sei für die Entwicklung und Wartung umfangreicher Software~\autocite[1]{BIERMAN:2014}. Über die Jahre sind verschiedene Ansätze entstanden, um diese Problematik zu überwinden, indem JavaScript um ein \emph{statisches} Typsystem erweitert wird. Der wesentliche Zweck statischer Typsysteme ist die Vermeidung von Programmfehlern~\autocite[1]{CARDELLI:TYPE_SYSTEMS}. Dies wird durch statische Analyse des Quelltexts realisiert, sodass Typverletzungen bereits \emph{vor} der Programmausführung festgestellt werden. Im Gegensatz zu einer dynamischen Typisierung wird der Typ von Ausdrücken in statischen Systemen explizit deklariert oder kann selbstständig inferiert (abgeleitet) werden. Eine \emph{explizite} Typisierung bedeutet, dass Typdeklarationen Bestandteil der Sprachsyntax sind~\autocite[2]{CARDELLI:TYPE_SYSTEMS}.

Eine statisches Typsystem bietet verschiedene Vorteile für den Software"=Entwicklungsprozess: Da Typen als ein Attribut angesehen werden können, die eine bestimmte Eigenschaft des Programms mittels der Mechanismen des Typsystems beweisen, tragen sie zur Verifizierung der Programmkorrektheit bei~\autocite{SMITH:TYPE_SYSTEMS}. Da der Compiler statisch berechnen kann, ob bei Ausdrücken und Anweisungen Typverletzungen auftreten, können semantische Probleme wie Logik- und Flüchtigkeitsfehler aufgedeckt und korrigiert werden. Sofern alle Schnittstellen und Datenstrukturen typisiert sind, wird deren inkorrekte Verwendung unmittelbar erkannt~\autocite[6]{CARDELLI:TYPE_SYSTEMS}. Weiterhin ist es möglich die Einschränkungen und Regeln der gegebenen Anwendungsdomäne durch des Typsystems präzise zu modellieren und deren Einhaltung mithilfe des System zu erzwingen. Auch erfordert die Deklaration expliziter Typen, dass der Entwickler die \emph{Absicht} seines Programms klar formuliert, wodurch sich die Ausdruckskraft und Lesbarkeit des Codes erhöht~\autocite[96]{WALDMANN:PPS}. Durch eine Typisierung wird das Verhalten und die Struktur der Software darüber hinaus bereits grundlegend dokumentiert~\autocite[Abschn. 6.1.1]{MITCHELL:CONCEPTS}.
% Schließlich hat die Verwendung statischer Typsysteme auch Vorteile für die Effizienz und Ausführungsgeschwindigkeit von Software. Da bereits im Vorfeld bekannt ist, welchen Typ die Elemente einer Datenstruktur besitzen, kann deren Speicherung und Zugriff auf Hardware-Ebene optimiert werden~\autocite[Abschn. 6.1.3]{MITCHELL:CONCEPTS}. Damit entfallen aufwändige Überprüfungen des Laufzeitsystems, die notwendig sind um eine dynamische Typisierung zu ermöglichen.

Derzeit existieren zwei populäre Technologien, welche eine statische Typisierung in JavaScript ermöglichen und so die Defizite des dynamischen Typsystems ausgleichen: einerseits \textit{Flow}~\autocite{FLOW:PAPER}, andererseits \textit{TypeScript}~\autocite{TYPESCRIPT:SPEC}. Eine nach wie vor ungelöste Aufgabenstellung ist jedoch die äquivalente Übersetzung dieser Systeme ineinander. Die Motivation für eine derartige automatische Transformation ist, den Wechsel des eingesetzten statischen Typsystems mit möglichst geringem manuellen Aufwand, zu realisieren. In Kapitel~\ref{chap:analysis} werden die Gründe, warum eine solche Migration angestrebt wird, für den gegebenen Fall ausführlich erläutert.

\section{Zielsetzung und Aufbau der Arbeit}

Die vorliegende Masterarbeit beschäftigt sich mit der Lösung dieser aufgeworfenen Problemstellung und ist in Zusammenarbeit mit dem Leipziger Unternehmen \textit{sprd.net AG} (\textit{Spreadshirt})\footnote{Siehe Abschnitt~\ref{sec:status-quo}.} entstanden. Ziel der Arbeit ist die Entwicklung eines \emph{Transpilers}, der es ermöglicht den gesamten Quelltext eines durch Flow typisierten JavaScript"=Projekts in äquivalenten TypeScript-Code zu übersetzen. Unter einem Transpiler wird ein spezieller Compiler verstanden, der den Quelltext einer Programmiersprache in eine andere Programmiersprache mit ähnlichem Abstraktionsniveau bedeutungsgleich übersetzt~\autocite{EVGENIY:2016}\footnote{Vgl. Abschnitt~\ref{sec:transpilers}.}.
Eine händische Migration umfangreicher Projekte ist impraktikabel, da dies zeitaufwändig und fehleranfällig wäre. Der Wechsel des eingesetzen Typsystems wird durch Spreadshirt angestrebt, da angenommen wird, dass TypeScript verschiedener Vorteile gegenüber Flow aufweist. So wird vermutet, dass TypeScript Typfehler und Bugs in höherem Maße erkennt und externe Software-Bibliotheken und Frameworks besser unterstützt. Weiterhin wird gemutmaßt, dass TypeScript Flow hinsichtlich Stabilität, Performance und Zukunftssicherheit überlegen ist. Die Verifizierung dieser Thesen auf Grundlage empirischer Daten und der gesammelten Erfahrung während der Projektmigration ist Gegenstand der anschließenden Untersuchung.

Der Aufbau der Arbeit gliedert sich in sechs Kapitel: Nachfolgend werden zunächst die benötigten Grundlagen hinsichtlich statischer Typsysteme für JavaScript und der Transpilierung von Programmen geschaffen. Anschließend wird die Ausgangslage der gegebenen JavaScript-Projekte analysiert, die Ziele des Wechsels von Flow zu TypeScript erläutert und die Anforderungen an den geplanten Transpiler ausgeführt. Daraufhin werden Architektur und Details der Implementierung des Übersetzers ausführlich betrachtet. In Kapitel~\ref{chap:evaluation} wird die Durchführung der Migration der JavaScript-Projekte mittels des Transpilers beschrieben und gewonnene Erfahrungen dargelegt. Weiterhin werden hier die Ergebnisse der Migration ausgewertet, kritisch diskutiert und hinsichtlich der Zielvorgabe bewertet. Darüber hinaus wird die Umsetzung vergleichbaren, bestehenden Werkzeugen gegenüber gestellt. Schließlich wird ein Fazit der gesamten Arbeit gezogen und ein Ausblick über mögliche Erweiterungen gegeben.
