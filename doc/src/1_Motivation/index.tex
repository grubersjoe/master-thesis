\chapter{Motivation}
\label{chap:motiviation}

\section{Historischer Abriss}

Als JavaScript 1995 von Brendan Eich in nur zehn Tagen als Bestandteil des Webbrowsers \textit{Netscape Communicator} entworfen wurde~\autocite{SEVERANCE:2012}, war nicht abzusehen, welche Relevanz die Sprache über 20 Jahre später besitzen würde: Heute wird JavaScript oft als die am weitesten verbreitete Programmiersprache der Welt angesehen~\autocite{PAULSON:2007,CROCKFORD:JS_POPULAR}. Dies belegt beispielsweise die alljährliche Umfrage \enquote{Stack Overflow Developer Survey} der Programmierer-Plattform \textit{Stack Overflow}, welche die Ergebnisse der weltweiten Befragung von circa 90.000 Software"=Entwicklern auswertet~\autocite{STACKOVERFLOW:SURVEY}. Bereits das siebte Jahr in Folge führt JavaScript dort die Rangliste der populärsten Programmiersprachen an. Der seit vielen Jahren anhaltende Trend, dass zunehmend mehr Software als Webanwendung statt konventioneller Desktop-Anwendung realisiert wird, hat die Bedeutung von JavaScript stark erhöht~\autocite{TAIVALSAARI:2017,CASTELEYN:2014}.

Die heutige große Beliebtheit der Sprache steht in starkem Kontrast zu ihren Anfängen. Zunächst besaß JavaScript eine zweifelhafte Reputation und wurde aus verschiedenen Gründen von professionellen Software"=Entwicklern als eine mangelhaft entworfene Programmiersprache angesehen~\autocite{CROCKFORD:JS_POPULAR}: Die uneinheitliche und teilweise fehlerbehaftete Implementierung in den frühen Webbrowsern und der Mangel an Entwicklungswerkzeugen wie Debuggern erschwerte die Programmierung von JavaScript-Anwendung enorm~\autocite{OREILLY:JS_HOW_DID_WE_GET_THERE}. Darüber hinaus behinderte die anfängliche Unbeständigkeit der Sprache und die \enquote{schlechte Qualität}~\autocite{CROCKFORD:JS_MISUNDERSTOOD} der ersten Versionen des ECMAScript-Standards~\autocite{ECMASCRIPT:1997} eine breite Akzeptanz der Sprache in der damaligen Entwickler-Szene. \enquote{ECMAScript} ist der Name der formalen Spezifikation von JavaScript und geht auf die Normungsorganisation \textit{Ecma International} zurück. \textit{Netscape Communications} beauftrage diese im November 1996 mit der Erstellung des Standards, welcher im Jahr darauf unter der Bezeichnung \enquote{ECMA-262} veröffentlicht wurde~\autocite{ECMASCRIPT:1997}. Ein weiterer Aspekt von JavaScript, der bis heute kritisch betrachtet wird, ist die dynamische Typisierung der Sprache, weil diese die Entwicklung sicherer und korrekter Software erschwert~\autocite{NIKHIL:2014,PRADEL:2015}. Im Folgenden soll dieser Gesichtspunkt näher beleuchtet werden, um die Problematik zu verdeutlichen.

\section{JavaScripts dynamische Typisierung}

Eine dynamische Typisierung ist dadurch charakterisiert, dass jedem Wert der Programmiersprache zur \emph{Laufzeit} ein Typ zugewiesen wird und sich dieser je nach Striktheit des Typsystems zu einem späteren Zeitpunkt implizit oder explizit ändern kann~\autocite[45]{WALDMANN:PPS}. Typfehler werden dabei durch dynamische Überprüfungen der Laufzeitumgebung erkannt~\autocite[37]{CARDELLI:TYPE_SYSTEMS}.
JavaScript besitzt die folgenden sieben Datentypen~\autocite[25]{ECMASCRIPT:2019}. Diese legen fest, wie Werte des Programms zur Laufzeit interpretiert werden, welchen Wertebereich sie umfassen und welche Operationen mit ihnen möglich sind. Alle Datentypen außer \texttt{Object} sind dabei primitiv, das heißt nicht weiter zerlegbar (atomar)~\autocite[8]{ECMASCRIPT:2019}.

\begin{itemize}
  \item \code{Undefined}: Undefinierte Werte
  \item \code{Null}: Nullwert
  \item \code{Boolean}: Boolesche Werte
  \item \code{String}: Zeichenketten
  \item \code{Symbol}: Eindeutige Bezeichner
  \item \code{Number}: Gleitkommazahlen
  \item \code{Object}: Alles Weitere (Felder, Funktionen, Objekte, usw.)
\end{itemize}

Der Typ von Werten wird in JavaScript während der Programmausführung bei Bedarf automatisch implizit umgewandelt (\emph{type coercion})~\autocite{RICHARDS:2010}. Einerseits kann argumentiert werden, dass eine derartige Flexibilität den Entwicklungsprozess beschleunigt~\autocite[1]{FLOW:PAPER}, andererseits birgt dies das Risiko von Programmfehlern, da Typverletzungen erst zur Laufzeit festgestellt werden können~\autocite{ANDERSON:2005}. Weil eine Typisierung von Ausdrücken syntaktisch nicht möglich ist, ist nicht immer offensichtlich, welche Datentypen in JavaScript-Quelltexten vorliegen. Deshalb ist die Programmierung so fehleranfällig. Problematisch für die Entwicklung korrekter Anwendungen ist darüber hinaus, dass JavaScript viele Operationen, die traditionell als dynamischer Typfehler gelten, nicht als solche behandelt, sondern die Programmausführung fortsetzt~\autocite{NIKHIL:2014}. So kann beispielsweise auf nicht-existente Attribute von Objekten zugegriffen werden, ohne dass dies eine Typverletzung verursacht. Infolgedessen ist es möglich, dass inkorrektes Programmverhalten zunächst unentdeckt bleibt, weil nicht unmittelbar ein fataler Fehler auftritt.

\section{Motivation für statische Typsysteme}

Viele der anfänglichen Unzulänglichkeiten von JavaScript konnten durch Erweiterungen der Spezifikation und zunehmend konsistenter Implementierungen nach und nach behoben werden. Swamy et al. führen aber aus, dass die dynamische Typisierung der Sprache weiterhin ein Hindernis für die Entwicklung sicherer und korrekter Anwendungen darstellen kann~\autocite{NIKHIL:2014}. Auch Bierman et al. vertreten die These, dass JavaScript nach wie vor ungeeignet sei für die Entwicklung und Wartung umfangreicher Software~\autocite[1]{BIERMAN:2014}. Über die Jahre sind verschiedene Ansätze entstanden, um diese Problematik zu überwinden, indem JavaScript um ein \emph{statisches} Typsystem erweitert wird. Der wesentliche Zweck statischer Typsysteme ist die Vermeidung von Programmfehlern~\autocite[1]{CARDELLI:TYPE_SYSTEMS}. Dies wird durch statische Analyse des Quelltexts realisiert, sodass Typverletzungen bereits vor der Programmausführung festgestellt werden können. Im Gegensatz zu einer dynamischen Typisierung wird der Typ von Ausdrücken in statischen Systemen explizit deklariert oder kann selbstständig inferiert (abgeleitet) werden~\autocite[45]{WALDMANN:PPS}. Eine \emph{explizite} Typisierung bedeutet, dass Typdeklarationen Bestandteil der Syntax der Programmiersprache bzw. des Systems sind~\autocite[2]{CARDELLI:TYPE_SYSTEMS}.

Ein statisches Typsystem bietet verschiedene Vorteile für den Software"=Entwicklungsprozess: Da Typen als ein Attribut angesehen werden können, die eine bestimmte Eigenschaft des Programms mittels der Mechanismen des Typsystems beweisen, tragen sie zur Verifizierung der Programmkorrektheit bei~\autocite{SMITH:TYPE_SYSTEMS}. Da der Compiler statisch berechnen kann, ob bei Ausdrücken und Anweisungen Typverletzungen auftreten, können semantische Probleme wie Logik- und Flüchtigkeitsfehler aufgedeckt und korrigiert werden. Sofern alle Schnittstellen und Datenstrukturen typisiert sind, wird deren inkorrekte Verwendung unmittelbar erkannt~\autocite[6]{CARDELLI:TYPE_SYSTEMS}. Weiterhin ist es möglich die Einschränkungen und Regeln der gegebenen Anwendungsdomäne durch des Typsystems präzise zu modellieren und deren Einhaltung mit Hilfe des System zu erzwingen. Auch erfordert die Deklaration expliziter Typen, dass der Entwickler die Absicht seines Programms klar formuliert, wodurch sich die Ausdruckskraft und Lesbarkeit des Codes erhöht~\autocite[96]{WALDMANN:PPS}. Durch eine Typisierung wird das Verhalten und die Struktur der Software darüber hinaus bereits grundlegend dokumentiert~\autocite[Abschn. 6.1.1]{MITCHELL:CONCEPTS}.
% Schließlich hat die Verwendung statischer Typsysteme auch Vorteile für die Effizienz und Ausführungsgeschwindigkeit von Software. Da bereits im Vorfeld bekannt ist, welchen Typ die Elemente einer Datenstruktur besitzen, kann deren Speicherung und Zugriff auf Hardware-Ebene optimiert werden~\autocite[Abschn. 6.1.3]{MITCHELL:CONCEPTS}. Damit entfallen aufwändige Überprüfungen des Laufzeitsystems, die notwendig sind um eine dynamische Typisierung zu ermöglichen.

Derzeit existieren zwei populäre Technologien, die eine statische Typisierung in JavaScript ermöglichen und so die Defizite des dynamischen Typsystems ausgleichen: einerseits \textit{Flow}~\autocite{FLOW:PAPER}, andererseits \textit{TypeScript}~\autocite{TYPESCRIPT:SPEC}. Eine nach wie vor ungelöste Problemstellung ist jedoch die äquivalente Übersetzung dieser Systeme ineinander. Die Motivation für eine derartige Transformation ist, den Wechsel des eingesetzten statischen Typsystems mit möglichst geringem manuellen Aufwand, zu realisieren. Die händische Migration umfangreicher Projekte ist impraktikabel, weil dies sehr zeitaufwändig und fehleranfällig wäre. In Kapitel~\ref{chap:analysis} werden die Gründe, warum die Migration im gegebenen Fall angestrebt wird, ausführlich erläutert.

\section{Zielsetzung und Aufbau der Arbeit}

Die vorliegende Masterarbeit beschäftigt sich mit der Lösung dieser aufgeworfenen Problemstellung und ist in Zusammenarbeit mit dem Leipziger Unternehmen \textit{sprd.net AG} (\textit{Spreadshirt}) entstanden. Ziel der Arbeit ist die Entwicklung eines \emph{Transpilers} (auch Transcompiler), der es ermöglicht den gesamten Quelltext eines durch Flow typisierten JavaScript"=Projekts in äquivalenten TypeScript-Code zu übersetzen. Unter einem Transpiler wird ein spezieller Compiler verstanden, der den Quelltext einer Programmiersprache in eine andere Programmiersprache mit ähnlichem Abstraktionsniveau bedeutungsgleich übersetzt~\autocite{EVGENIY:2016}. Der Wechsel des eingesetzen Typsystems wird durch Spreadshirt angestrebt, da angenommen wird, dass TypeScript verschiedener Vorteile gegenüber Flow aufweist. So wird vermutet, dass TypeScript Typ- und Programmfehler in höherem Maße erkennt und externe Software-Bibliotheken besser unterstützt. Außerdem wird gemutmaßt, dass TypeScript Flow hinsichtlich der Performance, Transparenz und Zukunftssicherheit überlegen ist. Die Verifizierung dieser Thesen auf Grundlage empirischer Daten und der gesammelten Erfahrung während der Projektmigration ist Gegenstand der anschließenden Untersuchung.

Der Aufbau der Arbeit gliedert sich in sechs Kapitel: Nachfolgend werden zunächst die benötigten theoretischen Grundlagen bezüglich statischer Typsysteme und der Transpilierung von Programmen geschaffen. Weiterhin werden die Typsysteme sowohl von Flow, als auch von TypeScript charakterisiert und voneinander abgegrenzt. Anschließend werden die Rahmenbedingungen zu Beginn der Arbeit beschrieben, die Ziele des Wechsels von Flow zu TypeScript erläutert und die Anforderungen an den angestrebten Transpiler ausgeführt. Daraufhin werden Architektur und Details der Implementierung des Übersetzers ausführlich betrachtet. In Kapitel~\ref{chap:evaluation} wird die Durchführung der Migration der JavaScript-Projekte von Spreadshirt mittels des umgesetzten Transcompilers dargelegt und gewonnene Erfahrungen beschrieben. Außerdem werden hier die Ergebnisse der Migration ausgewertet, kritisch diskutiert und hinsichtlich der Zielvorgabe bewertet. Darüber hinaus wird der realisierte Transpiler vergleichbaren, bestehenden Werkzeugen gegenüber gestellt. Schließlich wird ein Fazit der gesamten Arbeit gezogen und ein Ausblick über mögliche Erweiterungen gegeben.
