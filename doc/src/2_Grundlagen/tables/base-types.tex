\begin{longtabuenv}
\begin{longtabu} to \textwidth {@{}>{\raggedright}p{2.5cm}P{4.5cm}X[l]@{}}
    \midrule
    \libertineSB{Basistyp} & \libertineSB{Beispiel} & \libertineSB{Kurzbeschreibung} \\
    \midrule
  \endhead
    \midrule
    \caption{Basistypen von Flow~\autocite{FLOW:TYPE_ANNOTATIONS} mit Beispiel.}
  \endfoot
  Any type                 & any                             & Typ für beliebige Werte. Jeder Typ ist Subtyp von \code{any}. \code{any} ist jedem Typ zuweisbar und jeder Typ ist \code{any} zuweisbar. \medskip\\
  Array type               & Array<number>\newline number[]  & Felder. Der Typparameter (hier \code{number}) gibt den Typ der Feldelemente an. Der zweite Ausdruck ist eine äquivalente Kurzschreibweise.\medskip\\
  Boolean literal type     & true                            & Boolesche Literale (entweder \code{true} oder \code{false}). \medskip\\
  Boolean type             & boolean                         & Boolesche Werte. \medskip\\
  Empty type               & empty                           & Der leere Typ (\textit{bottom type} $\bot$), also der Typ mit genau 0 Elementen. Nützlich um niemals terminierende Unterprogramme zu typisieren (zum Beispiel Endlosschleife oder Exception). \medskip\\
  Exact object type        & \{| prop: boolean; |\}          & Objekte mit \emph{genau} der angegebenen Menge von Attributen. Weitere Attribute stellen eine Typverletzung dar (vgl. \type{Object type}).\medskip\\
  Function type            & (string, arg?: \{\}) => number  & Funktionen: das heißt der Typ der Parameter und des Rückgabewerts. Die Parameternamen sind dabei optional. \medskip\\
  Generic type annotation  & let v: <{}FlowType>{}           & Allgemeine Typannotation für Ausdrücke wie die Deklaration von Variablen, Funktionsparameter, -rückgabewerte et cetera. \medskip\\
  Generics                 & type Generic<{}T: Super> = T    & Generische Typen (\textit{parametrische Polymorphie}). \code{T} ist hierbei Typparameter, \code{Super} ein zugehöriger Supertyp, der mögliche Werte für T einschränkt. \medskip\\
  Interface type           & interface I \{\newline\hspace*{1.25em}prop: mixed;\newline\hspace*{1.25em}+covariant: Array<number>;\newline\}\medskip & Schnittstellen. Wie bei Objekttypen kann ein Attribute als kovariant (\code{+} nur lesbar) oder kontravariant (\code{-} nur schreibar) markiert werden. \medskip\\
  Intersection type        & type Intersection = T1 \& T2    & Schnittmenge zweier Typen. Der Typ \code{Intersection} enthält hier alle Eigenschaften von \code{T1} und \code{T2}. \medskip\\
  Mixed type               & mixed                           & Typ für unbekannte Werte, ähnlich zu \code{any}. Jeder Typ kann \code{mixed} zugewiesen werden, aber \code{mixed} kann anderen Typen erst nach Überprüfung der Kompatibilität zugewiesen werden. \medskip\\
  Null literal type        & null                            & Genau der Wert \code{null}. \medskip\\
  Nullable type (Maybe)    & ?number                         & Typ für optionale, möglicherweise undefinierte Werte. Entspricht der Vereinigung aus dem angegeben Typ, \code{null} und \code{undefined}. \medskip\\
  Number literal type      & 42                              & Genau dieser numerische Wert. \medskip\\
  Number type              & number                          & Gleitkommazahlen. \medskip\\
  Object type              & \{ {\newline\hspace*{1.25em}[}string{]}: number;\newline\hspace*{1.25em}prop: number;\newline\} & Typ für Objekte. Durch Notation mit geschweiften Klammern kann der Typ von Attributen spezifiziert werden. Im Quelltext zusätzliche auftretende Attribute stellen \emph{keine} Typverletzung dar, weil Flow \textit{width subtyping} unterstützt~\autocite{FLOW:WIDTH_SUBTYPING}. Typen in eckigen Klammern, die als Attributname angegeben werden, definieren einen Index. Der Zugriff auf Werte durch Namen dieses Typs ist damit erlaubt.\medskip\\
  Opaque type              & opaque type Opaque = number     & Opake Datentypen sind Typaliase, die ihre zugrunde liegende Implementierung vor dem Benutzer verbergen (\textit{information hiding}). \medskip\\
  String literal type      & \str{literal}                   & Genau diese Zeichenkette. \medskip\\
  String type              & string                          & Zeichenketten. \medskip\\
  This type                & this                            & Typ für Wert des Schlüsselworts \code{this} (Selbstreferenz) in Funktionen oder globalem Kontext. \medskip\\
  Tuple type               & {[}Date, number{]}              & Tupel, also Listen fester Länge mit vorgegebenen Datentyp für jedes Element. \medskip\\
  Type alias               & type Type = <{}FlowType>{}      & Ermöglicht beliebig komplexe Typkonstrukte unter einem neuen Namen, dem Alias, zusammen zu fassen. \medskip\\
  Type cast expression\medskip & (variable: string)          & Explizite Typumwandlung (statisch). \medskip\\
  Type export              & export type T = number | null   & Export von Typen aus Modulen. \medskip\\
  Type import              & import type T from './types'    & Import von Typen aus anderen Modulen. \medskip\\
  Typeof type              & typeof undefined                & Operator um Flow-Typ eines Werts zu erhalten. \medskip\\
  Union type               & number | string | null          & Vereinigungstyp. Hier: Entweder \code{number} oder \code{string} oder \code{null}. \medskip\\
  Void type                & void                            & Typ für \code{undefined}. Verwendung zum Beispiel in Funktionen ohne expliziten Rückgabewert. \medskip
  \label{tab:flow-base-types}
\end{longtabu}
\end{longtabuenv}
