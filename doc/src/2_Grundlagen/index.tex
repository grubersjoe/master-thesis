\chapter{Grundlagen}
\label{chap:basics}

\section{Typsysteme}

\subsection{Konzepte und Begrifflichkeit}

TODO

\subsection{Vorteile statischer Typsysteme}

Eine explizite, statische Typisierung wie sie beispielsweise in C++ oder Java vorliegt, bietet viele Vorteile für den Software-Entwicklungsprozess: Im Gegensatz zu einer dynamischen Typsystem wird der Typ einer Variable in statischen Systemen \emph{explizit} deklariert oder kann selbstständig inferiert (abgeleitet) werden. Der Wertebereich einer Variable wird damit durch ihren Typ bestimmt und dynamische Typumwandlungen eingeschränkt.
% TODO: CITATION NEEDED (like a lot)
% TODO: Überarbeiten
Ein gewichtiges Argument für den Einsatz statischer Typsysteme ist die erhöhte Sicherheit während des Programmierens~\autocite{CORNELL:STRONG_TYPING}. Da der Compiler mittels statischer Analyse überprüfen kann, ob bei Zuweisungen, Funktionsaufrufen und Rückgabewerten Typverletzungen auftreten, können Logik- und Flüchtigkeitsfehler reduziert werden. Wenn alle Datenstrukturen typisiert sind, können irrtümliche Annahmen über diese bereits vor der Ausführung des Programms erkannt und zugehörige Fehler behoben werden. Auf diese Weise können Laufzeitfehler verringert und die Qualität der Software gesteigert werden. Weiterhin ist es möglich die Einschränkungen und Regeln der gegebenen Anwendungsdomäne mittels eines Typsystems präzise zu modellieren und deren Einhaltung zu erzwingen. Durch eine statische Typisierung gewinnen Software"=Entwickler die Sicherheit und Zuversicht, dass umfangreiche Änderungen (\textit{Refactoring}) in Projekten keine unerwünschte Nebenwirkung verursachen.
% TODO: steile Thesen!
% Mittels statischer Analyse werden Typfehler und damit auch gegebenenfalls semantische Probleme unmittelbar erkannt. Infolgedessen steigert sich die Wartbarkeit der Anwendung.
% TODO: einfacherer Einstieg für Anfänger
Des Weiteren zwingt die Deklaration expliziter Typen den Entwickler dazu die \emph{Absicht} seines Programms klar zu formulieren, wodurch sich die Ausdruckskraft und Lesbarkeit des Codes erhöht~\autocite[96]{WALDMANN:PPS}. Durch eine vernünftige Typisierung wird der Quelltext darüber hinaus bereits grundlegend an Ort und Stelle dokumentiert (\textit{inline documentation})~\autocite[Abschn. 6.1.1]{MITCHELL:CONCEPTS}.

Schließlich hat die Verwendung statischer Typsysteme auch Vorteile für die Effizienz und Ausführungsgeschwindigkeit von Software. Da bereits im Vorfeld bekannt ist, welchen Typ die Elemente einer Datenstruktur besitzen, kann deren Speicherung und Zugriff auf Hardware-Ebene optimiert werden~\autocite[Abschn. 6.1.3]{MITCHELL:CONCEPTS}. Damit entfallen aufwändige Überprüfungen des Laufzeitsystems, die notwendig sind um eine dynamische Typisierung zu ermöglichen.


\section{Statische Typsysteme für JavaScript}
\label{sec:static-typesystems-for-js}

Die Idee JavaScript um ein statisches Typsystem zu erweitern ist nicht neu~\autocite[2]{FLOW:PAPER}. Zahlreiche Ansätze sind im Lauf der letzten Jahre entstanden.
% Dart, Closure

% Es gibt noch viele weitere: https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS


Im Folgenden sollen die zwei in dieser Arbeit behandelten Systeme \textit{Flow}~\autocite{FLOW:PAPER} und \textit{TypeScript}~\autocite{TYPESCRIPT:SPEC} näher betrachtet werden.

\subsection{Flow}
\label{subsection:flow}
% Flow beschreiben (und zwar mit entsprechender Fachsprache)

Alle Typen werden in der Online-Dokumentation von Flow~\autocite{FLOW:TYPE_ANNOTATIONS} erläutert.

Die Typannotationen von Flow können in drei Kategorien eingeordnet werden: Basistypen, Hilfstypen und Typdeklarationen. Diese werden im Folgenden vorgestellt und beschrieben.

\subsubsection{Basistypen}
\label{subsection:flow:base-types}

Unter Basistypen werden im weiteren Verlauf der Arbeit die Menge aller Typannotationen von Flow verstanden, welche keine Hilfstypen oder Typdeklarationen darstellen. Tabelle~\ref{tab:flow-base-types} gibt einen Überblick über diese. Um die Nachvollziehbarkeit zur Flow"=Dokumentation und der in Kapitel~\ref{chap:implementation} ausgeführten Implementierung zu erleichtern, werden die englischen Typbezeichnungen in allen Übersichtstabellen beibehalten und nicht ins Deutsche übersetzt.

\bigbreak
\input{src/2_Grundlagen/tables/base-types.tex}

\subsubsection{Hilfstypen}
\label{subsection:flow:utility-types}

TODO

\bigbreak
\input{src/2_Grundlagen/tables/utility-types.tex}

\subsubsection{Typdeklarationen}
\label{subsubsec:type-declarations}

TODO

\bigbreak
\input{src/2_Grundlagen/tables/declaration.tex}

\subsection{TypeScript}
% TS beschreiben (und zwar mit entsprechender Fachsprache)

\section{Transpilierung von Quelltexten}

% Was macht eigentlich so ein Compiler bzw. Transpiler? Hier Theorie (AST etc.)

\subsection{Konzeptioneller Aufbau von Transpilern}

  %  TODO: vllt eher allgemeine Konzepte von Transpilern..?

  % TODO Lexikalische und syntaktische Analyse

  % Lexikalische Analayse:
  % Quelltext (string) => Tokens
  % Parser, Tokenizer = Lexer

  % Syntaxanalyse:
  % Tokens => AST

\subsection{Bestehende Transpiler für JavaScript}
\label{subsec:js-transpilers}

% TODO: Evaluation

Im Umfeld von JavaScript sind im Lauf der Jahre eine Vielzahl von Parsern und Transpilern entstanden, welche die Entwicklung weiterer Werkzeuge wie die des angestrebten Transpilers von Flow nach TypeScript stark vereinfachen können. Im Folgenden sollen die relevantesten Ansätze evaluiert werden, sodass daraufhin die Entscheidung getroffen werden kann, welches der Werkzeuge als Grundlage der Umsetzung heran gezogen wird.

% Esprima, Acorn, Babel
% Babel basiert auf acorn.

% http://marijnhaverbeke.nl/blog/acorn.html
% https://github.com/estree/estree
% https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API
% https://babeljs.io/blog/2016/12/07/the-state-of-babel#the-future-parser-unity
% https://medium.com/@sebmck/2015-in-review-51ac7035e272#.jdoo279bl

% Am Ende: es wird Babel eingesetzt werden, um das Dingens zu bauen.

% CITATION NEEDED
Im Gegensatz zu den betrachteten Alternativen unterstützt lediglich Babel die Syntax von Flow, TypeScript und aktueller bzw. vorgeschlagener JavaScript-Sprachkonstrukte vollständig. Dieser Aspekt ist entscheidend, da nur so eine universelle Übersetzung \emph{jeglicher} Flow-Syntax in äquivalentes TypeScript umgesetzt werden kann\footnote{vgl. Anforderung~\ref{subsection:requirement:correct-translation}.}.
Ein weiteres Argument für die Wahl von Babel ist einerseits die sehr gute Erweiterbarkeit durch ein Plugin-System, andererseits die Ausgereiftheit und große Verbreitung des Projekts. Keine der anderen Optionen konnte die Anforderungen des Transpilers in vergleichbarem Maße erfüllen.

\subsection{Babel}
\label{sec:babel}

\subsubsection{Funktionsweise von Babel}

Zur Erleichterung des Verständnisses der Ausführung der Umsetzung des Flow-Transpilers in Kapitel \ref{chap:implementation} soll zunächst die grundsätzliche Funktionsweise von Babel umrissen werden. Die Ausführung von Babel gliedert sich in folgende drei Phasen~\autocite{BABEL:HANDBOOK}:

% TODO: Tokenizer, Lexer, Tokens und all den Quatsch in den Grundlagen erklären!
\begin{enumerate}
  \item {\libertineSB Parsen des Eingabecodes}\\*
    Zunächst wird der ursprüngliche Quelltext in zwei Schritten eingelesen, um den abstrakten Syntaxbaum (AST) des Programms zu erzeugen: Als Erstes wird der Code während der lexikalischen Analyse mittels des Tokenizers in Tokens zerlegt. Anschließend werden diese in der syntaktischen Analyse zu einer Datenstruktur umgeformt, die den zugehörigen Syntaxbaum repräsentiert. Jeder Knoten des Baums erhält dabei einen eindeutigen Typ, der dessen syntaktische Bedeutung widerspiegelt.
    \\

  \item {\libertineSB Transformation des Programms}\\*
    Während der zweiten Phase wird daraufhin die eigentliche Programmtransformation durchgeführt: Dabei wird der abstrakte Syntaxbaum durch das \emph{Besucher}"=Entwurfsmuster\footnote{engl. \textit{Visitor-Pattern.}.} rekursiv traversiert und die Knoten des Baums sukzessive modifiziert, gelöscht bzw. neu erstellte Elemente eingefügt. Das Besucher-Entwurfsmuster beschreibt wie Operationen auf einer Objektdatenstruktur, unabhängig von der konkreten Implementierung der zugrunde liegenden Klassen, ausgeführt werden können~\autocite[634\psq]{FREEMAN:2004}. Es gehört zu den 23 Entwurfsmustern, die im Standardwerk \citetitle{GAMMA:1994} der \enquote{Gang of Four}\footnote{E. Gamma, R. Helm, R. Johnson und J. Vlissides.} beschrieben werden~\autocite[306\psqq]{GAMMA:1994}. Im vorliegenden Fall ermöglicht die Anwendung des Musters die individuelle Adressierung einer genau eingegrenzten Untermenge der Knoten des Syntaxbaums, um dort die gewünschte Transformation des Programms umzusetzen.
    \\

  \item {\libertineSB Generierung des Ausgabequelltexts}\\*
    Schließlich kann der Ausgabecode generiert werden: Hierbei werden alle Knoten des abstrakten Syntaxbaums durch Anwendung einer Tiefensuche nach und nach durchlaufen und eine Zeichenkette aufgebaut, die den endgültigen, modifizierten Quelltext darstellt.
\end{enumerate}

\subsubsection{Babel-Plugins}
\label{subsection:babel-plugins}

Da die entscheidende Phase der Transpilierung, die Programmtransformation, bei Babel durch Plugins erzielt wird, sollen diese genauer betrachtet werden. Plugins sind die elementaren Bausteine, die eine flexible Erweiterung von Babel ermöglichen. Selbst der Kern des Compilers ist aus einer Vielzahl von Standard-Plugins zusammen gesetzt, die in ihrer Gesamtheit die Funktionalität des Systems abbilden~\autocite{BABEL}. Dies verdeutlicht die tiefgreifende Modularität der Architektur von Babel. Jedes Plugin ist eine JavaScript"=Funktion, welche gemäß der vorgegebenen Schnittstelle ein Objekt mit verschiedenen Attributen zurückliefern muss. Mindestens anzugeben ist dabei lediglich die Abbildung der gewünschten Knotentypen des abstrakten Syntaxbaums auf Besucherfunktionen~\autocite{BABEL:HANDBOOK}. Deren Implementierung setzt die angestrebte Quelltext"=Transformation um. Es ist in der Praxis gängig mehrere Plugins einzusetzen, sodass ein Knoten während der Verarbeitung durch Babel mehrere, unabhängige Transformationen durchlaufen kann. Hierdurch kann die erwünschte Transpilierung von JavaScript-Quelltexten sehr flexibel durch Kombination vieler, kleiner Bausteine realisiert werden. Auch möglich ist die Angabe einer hierarchischen Abhängigkeitsstruktur, sodass dass die Verwendung eines Plugins zur impliziten Aktivierung weiterer Plugins führt.

Der konkrete Aufbau von Babel-Plugins soll durch ein Minimalbeispiel verdeutlicht werden. Quelltext~\ref{code:babel-plugin-definition} zeigt den Code eines sehr einfachen aber vollständigen Plugins, welches lediglich den Namen aller Bezeichner (\code{Identifier}) eines JavaScript-Programms in Großbuchstaben setzt. Hierfür wird eine gleichnamige Besucherfunktion für den Knotentyp \code{Identifier} definiert. Diese erhält den \emph{Pfad} der so adressierten Identifier-Knoten als Argument und kann diesen wie gewünscht transformieren. Der Pfad eines AST-Knotens ist ein Objekt, das die Beziehung des Knotens zu seinen Elternelementen modelliert und diesen um Metainformationen anreichert~\autocite{BABEL:HANDBOOK}. Es enthält eine Vielzahl von Methoden mittels derer der Pfad und der Syntaxbaum manipuliert werden kann.
Alle Knotentypen des abstrakten Syntaxbaums werden einerseits in der Spezifikation des Parsers von Babel~\autocite{BABEL:PARSER_SPEC,BABEL:PARSER}, andererseits in der Dokumentation der Bibliothek \code{@babel/types}~\autocite{BABEL:TYPES} beschrieben. Der Aufbau des von Babel eingesetzten abstrakten Syntaxbaums basiert auf dem Standard \textit{ESTree Spec}~\autocite{ESTREE_SPEC}. Dieser wird von Mitgliedern verschiedener Projekte im Umfeld der statischen Analyse von JavaScript kontinuierlich weiterentwickelt~\autocite{BABEL:PARSER,ESTREE_SPEC}. Grund für die Abspaltung Babels von der ESTree-Spezifikation seit Version 6 ist, dass das Projekt auch \emph{vorläufige} JavaScript-Erweiterungen, welche noch nicht endgültiger Bestandteil von ECMAScript sind, unterstützen möchte\footnote{Die ECMAScript-Spezifikation wird stetig durch das \textit{Technical Committee 39} (TC39)~\autocite{TC39_COMMITTEE} weiterentwickelt. Vorgeschlagene Erweiterungen der Sprache durchlaufen einen mehrstufigen Standardisierungsprozess, der schließlich in die Aufnahme in die Spezifikation münden kann~\autocite{TC39_PROCESS}.}~\autocite{BABEL:STATE_OF_BABEL}.

\bigbreak
\begin{listing}[htb]
\begin{textcode}
// var foo => var FOO
module.exports = function() {
  return {
    visitor: {
      Identifier(path) {
        path.node.name = path.node.name.toUpperCase();
      }
    }
  };
};
\end{textcode}
\listingvspace
\caption[Minimalbeispiel eines Babel-Plugins]{Minimalbeispiel eines Babel-Plugins: Die Namen aller Bezeichner (\code{Identifier}) werden in Großbuchstaben umgewandelt.}
  \label{code:babel-plugin-definition}
\end{listing}

Im weitere Verlauf wird das Hauptaugenmerk der Untersuchung auf die zweite Phase der Transpilierung gelegt, da hier die vorliegende Problemstellung, die Transformation der Flow-Typannotationen nach TypeScript, umgesetzt wird. Das Parsen des Eingabquelltexts und das Generieren der Ausgabe kann durch Verwendung der gegebenen Bibliotheksfunktionen von Babel simpel realisiert werden und bedarf keiner tiefgründigen Betrachtung.
