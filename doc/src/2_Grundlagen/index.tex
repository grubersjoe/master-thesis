\chapter{Grundlagen}
\label{chap:basics}

\section{Typsysteme}

\subsection{Konzepte und Begrifflichkeit}

TODO

\subsection{Vorteile statischer Typsysteme}

Eine explizite, statische Typisierung wie sie beispielsweise in C++ oder Java vorliegt, bietet viele Vorteile für den Software-Entwicklungsprozess: Im Gegensatz zu einer dynamischen Typsystem wird der Typ einer Variable in statischen Systemen \emph{explizit} deklariert oder kann selbstständig inferiert (abgeleitet) werden. Der Wertebereich einer Variable wird damit durch ihren Typ bestimmt und dynamische Typumwandlungen eingeschränkt.
% TODO: CITATION NEEDED (like a lot)
% TODO: Überarbeiten
Ein gewichtiges Argument für den Einsatz statischer Typsysteme ist die erhöhte Sicherheit während des Programmierens~\autocite{CORNELL:STRONG_TYPING}. Da der Compiler mittels statischer Analyse überprüfen kann, ob bei Zuweisungen, Funktionsaufrufen und Rückgabewerten Typverletzungen auftreten, können Logik- und Flüchtigkeitsfehler reduziert werden. Wenn alle Datenstrukturen typisiert sind, können irrtümliche Annahmen über diese bereits vor der Ausführung des Programms erkannt und zugehörige Fehler behoben werden. Auf diese Weise können Laufzeitfehler verringert und die Qualität der Software gesteigert werden. Weiterhin ist es möglich die Einschränkungen und Regeln der gegebenen Anwendungsdomäne mittels eines Typsystems präzise zu modellieren und deren Einhaltung zu erzwingen. Durch eine statische Typisierung gewinnen Software"=Entwickler die Sicherheit und Zuversicht, dass umfangreiche Änderungen (\textit{Refactoring}) in Projekten keine unerwünschte Nebenwirkung verursachen.
% TODO: steile Thesen!
% Mittels statischer Analyse werden Typfehler und damit auch gegebenenfalls semantische Probleme unmittelbar erkannt. Infolgedessen steigert sich die Wartbarkeit der Anwendung.
% TODO: einfacherer Einstieg für Anfänger
Des Weiteren zwingt die Deklaration expliziter Typen den Entwickler dazu die \emph{Intension} seines Programms klar zu formulieren~\autocite[96]{WALDMANN:PPS}, wodurch sich die Ausdruckskraft und Lesbarkeit des Codes erhöht. Durch eine vernünftige Typisierung wird der Quelltext darüber hinaus bereits grundlegend an Ort und Stelle dokumentiert (\textit{inline documentation})~\footcite[Abschnitt 6.1.1]{MITCHELL:CONCEPTS}.

Schließlich hat die Verwendung statischer Typsysteme auch Vorteile für die Effizienz und Ausführungsgeschwindigkeit von Software. Da bereits im Vorfeld bekannt ist, welche Typen verschiedene Datenstrukturen besitzen, kann deren Speicherung und Zugriff optimiert werden~\footcite[Abschnitt 6.1.3]{MITCHELL:CONCEPTS}. Damit entfallen aufwändige Überprüfungen des Laufzeitsystems, die eine dynamische Typisierung erlauben.


\section{Statische Typsysteme für JavaScript}

Die Idee JavaScript um ein statisches Typsystem zu erweitern ist nicht neu. Zahlreiche Ansätze sind im Lauf der letzten Jahre entstanden.
% Dart, Closure

% Es gibt noch viele weitere: https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS


Im Folgenden sollen die zwei in dieser Arbeit behandelten Systeme \textit{Flow}~\autocite{FLOW:PAPER} und \textit{TypeScript}~\autocite{TYPESCRIPT_SPEC} näher betrachtet werden.

\subsection{Flow}
\label{subsection:flow}
% Flow beschreiben (und zwar mit entsprechender Fachsprache)

Alle Typen werden in der Online-Dokumentation von Flow~\autocite{FLOW:TYPE_ANNOTATIONS} erläutert.

Die Typannotationen von Flow können in drei Kategorien eingeordnet werden: Basistypen, Hilfstypen und Typdeklarationen. Diese werden im Folgenden vorgestellt und beschrieben.

\subsubsection{Basistypen}
\label{subsection:flow:base-types}

Unter Basistypen werden im weiteren Verlauf der Arbeit die Menge aller Typannotationen von Flow verstanden, welche keine Hilfstypen oder Typdeklarationen darstellen. Tabelle~\ref{tab:flow-base-types} gibt einen Überblick über diese. Um die Nachvollziehbarkeit zur Flow"=Dokumentation und der in Kapitel~\ref{chap:implementation} ausgeführten Implementierung zu erleichtern, werden die englischen Typbezeichnungen in allen Übersichtstabellen beibehalten und nicht ins Deutsche übersetzt.

\bigbreak
\begin{footnotesize}
\begin{longtabu} to \textwidth {@{}llX@{}}
  \midrule
  \libertineSB{Hilfstyp} & \libertineSB{Beispiel} & \libertineSB{Kurzbeschreibung} \\
  \midrule
  \endhead
  Any type                   & \texttt{any}                             & Typ für beliebige Werte. \code{any} ist jedem Typ zuweisbar und jeder Typ ist \code{any} zuweisbar. \\
  Array type                 & \texttt{Array<{}number>{}}               & Felder \\
  Array type (shorthand)     & \texttt{number[]}                        & Felder (Kurzschreibweise) \\
  Boolean literal type       & \texttt{true}                            & Boolesche Literale (entweder \code{true} oder \code{false}) \\
  Boolean type               & \texttt{boolean}                         & Boolesche Werte \\
  Empty type                 & \texttt{empty}                           & TODO \\
  Exact object type          & \texttt{\{| prop: any |\}}               & TODO, \\
  Function type              & \texttt{(string, \{\}) => number}        & Funktionen: also der Typ der Parameter und des Rückgabewerts \\
  Generic type annotation    & \texttt{let v: <{}FlowType>{}}           & TODO \\
  Generics                   & \texttt{type Generic<{}T: Super> = T}    & TODO \\
  Interface type             & \texttt{interface \{ +prop: number \}}   & TODO \\
  Intersection type          & \texttt{type Intersection = T1 \& T2}    & TODO \\
  Mixed type                 & \texttt{mixed}                           & TODO \\
  Null literal type          & \texttt{null}                            & TODO \\
  Nullable type (Maybe type) & \texttt{?number}                         & TODO \\
  Number literal type        & \texttt{42}                              & TODO \\
  Number type                & \texttt{number}                          & TODO \\
  Object type                & \texttt{\{ {[}string{]}: number \}}      & TODO \\
  Opaque type                & \texttt{opaque type Opaque = number}     & TODO \\
  String literal type        & \texttt{'literal'}                       & TODO \\
  String type                & \texttt{string}                          & TODO \\
  This type                  & \texttt{this}                            & TODO \\
  Tuple type                 & \texttt{{[}Date, number{]}}              & TODO \\
  Type alias                 & \texttt{type Type = <{}FlowType>{}}      & TODO \\
  Type cast expresssion      & \texttt{(variable: string)}              & TODO \\
  Type export                & \texttt{export type T = number | null}   & TODO \\
  Type import                & \texttt{import type T from './types'}    & TODO \\
  Typeof type                & \texttt{typeof undefined}                & TODO \\
  Union type                 & \texttt{number | null}                   & TODO \\
  Void type                  & \texttt{void}                            & TODO \\
  \midrule
  \caption{Basistypen von Flow~\autocite{FLOW:TYPE_ANNOTATIONS} mit Beispiel.}
  \label{tab:flow-base-types}
\end{longtabu}
\end{footnotesize}

\subsubsection{Hilfstypen}
\label{subsection:flow:utility-types}

TODO

\bigbreak
\begin{footnotesize}
\begin{longtabu} to \textwidth {@{}llX@{}}
  \midrule
  \libertineSB{Hilfstyp} & \libertineSB{Beispiel} & \libertineSB{Kurzbeschreibung} \\
  \midrule
  \endhead
  Call                & \texttt{\$Call<F, T...>}        & TODO   \\
  Class               & \texttt{Class<T>}               & TODO   \\
  Difference          & \texttt{\$Diff<A, B>}           & TODO   \\
  Element type        & \texttt{\$ElementType<T, K>}    & TODO   \\
  Exact               & \texttt{\$Exact<T>}             & TODO   \\
  Existential type    & \texttt{*}                      & TODO   \\
  Keys                & \texttt{\$Keys<T>}              & TODO   \\
  None maybe type     & \texttt{\$NonMaybeType<T>}      & TODO   \\
  Object map          & \texttt{\$ObjMap<T, F>}         & TODO   \\
  Object map with key & \texttt{\$ObjMapi<T, F>}        & TODO   \\
  Property type       & \texttt{\$PropertyType<T, k>}   & TODO   \\
  ReadOnly            & \texttt{\$ReadOnly<T>}          & TODO   \\
  Rest                & \texttt{\$Rest<A, B>}           & TODO   \\
  Shape               & \texttt{\$Shape<T>}             & TODO   \\
  Tuple map           & \texttt{\$TupleMap<T, F>}       & TODO   \\
  Values              & \texttt{\$Values<T>}            & TODO   \\
  Subtype             & \texttt{\$Subtype<T>}           & TODO   \\
  Supertype           & \texttt{\$Supertype<T>}         & TODO   \\
  \midrule
  \caption{Hilfstypen von Flow~\autocite{FLOW:UTILITY_TYPES} mit Beispiel.}
  \label{tab:flow-utility-types}
\end{longtabu}
\end{footnotesize}

\subsubsection{Typdeklarationen}

TODO

\bigbreak
\begin{footnotesize}
\begin{longtabu} to \textwidth {@{}lXX@{}}
  \midrule
  \libertineSB{Deklaration} & \libertineSB{Beispiel} & \libertineSB{Kurzbeschreibung} \\
  \midrule
  \endhead
  Class       & \code{declare class C {}}               & TODO \\
  Export      & \code{declare export default () => any} & TODO \\
              &                                         & TODO \\
  Function    & \code{declare function f(number): any}  & TODO \\
  Interface   & \code{declare interface I {}}           & TODO \\
  Module      & \code{declare module 'esmodule' {}}     & TODO \\
  Type alias  & \code{declare type T = number}          & TODO \\
  Variable    & \code{declare var v: string}            & TODO \\
  \midrule
  \caption{Typdeklarationen von Flow.}
  \label{tab:flow-type-declarations}
\end{longtabu}
\end{footnotesize}

\subsection{TypeScript}
% TS beschreiben (und zwar mit entsprechender Fachsprache)

\section{Transpilierung von Quelltexten}

% Was macht eigentlich so ein Compiler bzw. Transpiler? Hier Theorie (AST etc.)

\subsection{Konzeptioneller Aufbau von Transpilern}

  % TODO Lexikalische und syntaktische Analyse

  % Lexikalische Analayse:
  % Quelltext (string) => Tokens
  % Parser, Tokenizer = Lexer

  % Syntaxanalyse:
  % Tokens => AST

\subsection{Bestehende Transpiler für JavaScript}
\label{subsec:js-transpilers}

% TODO: Evaluation

Im Umfeld von JavaScript sind im Lauf der Jahre eine Vielzahl von Parsern und Transpilern entstanden, welche die Entwicklung weiterer Werkzeuge wie die des angestrebten Transpilers von Flow nach TypeScript stark vereinfachen können. Im Folgenden sollen die relevantesten Ansätze evaluiert werden, sodass daraufhin die Entscheidung getroffen werden kann, welches der Werkzeuge als Grundlage der Umsetzung heran gezogen wird.

% Esprima, Acorn, Babel
% Babel basiert auf acorn.

% http://marijnhaverbeke.nl/blog/acorn.html
% https://github.com/estree/estree
% https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API
% https://babeljs.io/blog/2016/12/07/the-state-of-babel#the-future-parser-unity
% https://medium.com/@sebmck/2015-in-review-51ac7035e272#.jdoo279bl

% Am Ende: es wird Babel eingesetzt werden, um das Dingens zu bauen.

Die ECMAScript-Spezifikation wird stetig durch das \textit{Technical Committee 39} (TC39)~\autocite{TC39_COMMITTEE} weiterentwickelt. Vorgeschlagene Erweiterungen der Sprache durchlaufen einen mehrstufigen Standardisierungsprozess, der schließlich in die Aufnahme in die Spezifikation münden kann~\autocite{TC39_PROCESS}.

% CITATION NEEDED
Im Gegensatz zu den betrachteten Alternativen unterstützt lediglich Babel die Syntax von Flow, TypeScript und aktueller bzw. vorgeschlagener JavaScript-Sprachkonstrukte vollständig. Dieser Aspekt ist entscheidend, da nur so eine universelle Übersetzung \emph{jeglicher} Flow-Syntax in äquivalentes TypeScript umgesetzt werden kann\footnote{vgl. Anforderung~\ref{subsection:requirement:correct-translation}.}.
Ein weiteres Argument für die Wahl von Babel ist einerseits die sehr gute Erweiterbarkeit durch ein Plugin-System, andererseits die Ausgereiftheit und große Verbreitung des Projekts. Keine der anderen Optionen konnte die Anforderungen des Transpilers in vergleichbarem Maße erfüllen.

\subsection{Babel}
\label{sec:babel}

\subsubsection{Funktionsweise von Babel}

Zur Erleichterung des Verständnisses der Ausführung der Umsetzung des Flow-Transpilers in Kapitel \ref{chap:implementation} soll zunächst die grundsätzliche Funktionsweise von Babel näher betrachtet werden. Die Ausführung von Babel gliedert sich in folgende drei Phasen~\autocite{BABEL:HANDBOOK}:

% TODO: Tokenizer, Lexer, Tokens und all den Quatsch in den Grundlagen erklären!
\begin{enumerate}
  \item {\libertineSB Parsen des Eingabecodes}\\*
    Zunächst wird der ursprüngliche Quelltext in zwei Schritten eingelesen, um den abstrakten Syntaxbaum (AST) des Programms zu erzeugen: Als Erstes wird der Code während der lexikalischen Analyse mittels des Tokenizers in Tokens zerlegt. Anschließend werden diese in der syntaktischen Analyse zu einer Datenstruktur umgeformt, die den zugehörigen Syntaxbaum repräsentiert. Jeder Knoten des Baums erhält dabei einen eindeutigen Typ.
    \\

  \item {\libertineSB Transformation des Programms}\\*
    Während der zweiten Phase wird daraufhin die eigentliche Programmtransformation durchgeführt: Dabei wird der abstrakte Syntaxbaum durch das \emph{Besucher}"=Entwurfsmuster\footnote{engl. \textit{Visitor-Pattern.}.} rekursiv traversiert und die Knoten des Baums sukzessive modifiziert, gelöscht bzw. neu erstellte Elemente eingefügt. Das Besucher-Entwurfsmuster beschreibt wie Operationen auf einer Objektdatenstruktur, unabhängig von der konkreten Implementierung der zugrunde liegenden Klassen, ausgeführt werden können~\autocite[634\psq]{Freeman:2004}. Es gehört zu den 23 Entwurfsmustern, die im Standardwerk \citetitle{GAMMA:1994} der \enquote{Gang of Four}\footnote{E. Gamma, R. Helm, R. Johnson und J. Vlissides.} beschrieben werden~\autocite[306\psqq]{GAMMA:1994}. Im vorliegenden Fall ermöglicht die Anwendung des Musters die individuelle Adressierung einer Untermenge der Knoten des Syntaxbaums, um dort die gewünschte Transformation des Programms umzusetzen.
    \\

  \item {\libertineSB Generierung des Ausgabequelltexts}\\*
    Schließlich kann der Ausgabecode generiert werden: Hierbei werden alle Knoten des abstrakten Syntaxbaums durch Anwendung einer Tiefensuche nach und nach durchlaufen und eine Zeichenkette aufgebaut, welche den modifizierten Quelltext darstellt.
\end{enumerate}

\subsubsection{Babel-Plugins}
\label{subsection:babel-plugins}

Plugins sind die elementaren Bausteine, die eine flexible Erweiterung von Babel ermöglichen. Der Kern des Compilers besteht selbst aus einer Vielzahl von Plugins, die in ihrer Gesamtheit die Funktionalität des Systems abbilden~\autocite{BABEL}. Dies verdeutlicht die tiefgreifend verankerte Modularität der Architektur von Babel. Jedes Plugin ist eine JavaScript"=Funktion, die ein Objekt mit verschiedenen vorgegebenen Attributen zurückliefern muss. Verpflichtend anzugeben ist dabei lediglich die Abbildung der gewünschten Knotentypen des abstrakten Syntaxbaums auf Besucher-Funktionen~\autocite{BABEL:HANDBOOK}. Deren Implementierung realisiert die angestrebte Quelltext"=Transformation. Es ist in der Praxis gängig, dass mehrere Plugins eingesetzt werden, sodass ein Knoten während der Verarbeitung durch Babel mehrere, unabhängige Transformationen durchlaufen kann. Hierdurch kann die erwünschte Transpilierung von JavaScript-Quelltexten sehr flexibel durch Verwendung vieler, kleiner Bausteine zusammen gesetzt werden. Auch möglich ist der Aufbau einer hierarchischen Abhängigkeitsstruktur, d.~h. dass die Verwendung eines Plugins zur impliziten Aktivierung weiterer Plugins führt.

Quelltext~\ref{code:babel-plugin-definition} zeigt das Minimalbeispiel eines sehr einfachen, vollständigen Plugins, welches lediglich den Namen aller Bezeichner (\code{Identifier}) eines JavaScript-Programms in Großbuchstaben setzt. Hierfür wird eine gleichnamige Besucher-Funktion für den Knotentyp \code{Identifier} definiert. Diese erhält den \emph{Pfad} der so adressierten Identifier-Knoten als Argument und kann diesen wie gewünscht transformieren. Der Pfad eines AST-Knotens ist ein Objekt, das die Beziehung des Knotens zu seinen Elternelementen abbildet und diesen um Metainformationen anreichert~\autocite{BABEL:HANDBOOK}. Es enthält weiterhin eine Vielzahl von Methoden mittels derer der Pfad und der Syntaxbaum manipuliert werden kann.
Alle Knotentypen des abstrakten Syntaxbaums werden einerseits in der Spezifikation des Parsers von Babel~\autocite{BABEL:PARSER_SPEC,BABEL:PARSER}, andererseits in der Dokumentation der Bibliothek \code{@babel/types}\autocite{BABEL:TYPES} beschrieben. Diese basiert auf dem Standard \textit{ESTree Spec}~\autocite{ESTREE_SPEC}, der von Mitgliedern verschiedener Projekte im Umfeld der statischen Analyse von JavaScript gemeinschaftlich entwickelt wird~\autocite{BABEL:PARSER,ESTREE_SPEC}. Grund für die Abspaltung Babels von der ESTree-Spezifikation seit Version 6 ist, dass das Projekt auch \emph{vorläufige} JavaScript-Erweiterungen, welche noch nicht endgültiger Bestandteil von ECMAScript sind, unterstützen möchte~\autocite{BABEL:STATE_OF_BABEL}.

\bigbreak
\begin{listing}[htb]
\begin{textcode}
// var foo => var FOO
module.exports = function() {
  return {
    visitor: {
      Identifier(path) {
        path.node.name = path.node.name.toUpperCase();
      }
    }
  };
};
\end{textcode}
\listingvspace
\caption[Minimalbeispiel eines Babel-Plugins]{Minimalbeispiel eines Babel-Plugins: Die Namen aller Bezeichner (\code{Identifier}) werden in Großbuchstaben umgewandelt.}
  \label{code:babel-plugin-definition}
\end{listing}

Im weitere Verlauf wird das Hauptaugenmerk der Untersuchung auf die zweite Phase gelegt, da hier die vorliegende Problemstellung, die Transformation der Flow-Typannotationen nach TypeScript, behandelt wird. Das Parsen des Eingabquelltexts und das Generieren der Ausgabe kann durch Verwendung der gegebenen Bibliotheks-Funktionen von Babel simpel umgesetzt werden und bedarf keiner tiefgründigen Betrachtung.
