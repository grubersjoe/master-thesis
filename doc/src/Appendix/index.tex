\chapter{TBA}

\section{Expose}

% \subsection{Die historische Entwicklung JavaScripts}

% JavaScript hat als Lingua Franca des World Wide Webs und primäre clientseitige Programmiersprache für Webanwendungen aller Art innerhalb der letzten Jahre enorm an Bedeutung gewonnen. Dies belegt beispielsweise die alljährliche Umfrage \enquote{\emph{Stack Overflow Developer Survey}} der Programmierer-Plattform \emph{Stack Overflow}, welche die Ergebnisse der Befragung von über 100.000 Software-Entwicklern weltweit auswertet~\autocite{stackoverflow:survey:2018}. Bereits das sechste Jahr in Folge führt JavaScript die Rangliste der populärsten Programmiersprachen an. Dies ist nicht verwunderlich hinsichtlich des ungebrochenen Trends, dass immer mehr Software als Webanwendung konzipiert wird~\autocite{taivalsaari:2017}\autocite{casteleyn:2014:ria}. Viele beliebte Applikationen wie \emph{Spotify}, \emph{Slack} oder \emph{Visual Studio Code} basieren z.~B. auf dem Framework \emph{Electron}~\autocite{electron}. Dabei wird die gesamte grafische Oberfläche der Anwendung durch HTML und CSS innerhalb eines Chromium-Webbrowsers realisiert. Derzeitige JavaScript-Frameworks und -Bibliotheken wie Angular~\autocite{angular} oder React~\autocite{react} verdeutlichen den hohen Bedarf an modernen Entwicklungsansätzen und anspruchsvollen Programmierparadigmen, die es ermöglichen, umfangreiche, skalierbare Anwendungen in JavaScript umzusetzen.

% Als JavaScript jedoch 1995 als Bestandteils des Browsers \emph{Netscape Communicator} erfunden worden ist\footnote{Zunächst \enquote{LiveScript} genannt.}~\autocite{severance:2012:js10days}, war nicht abzusehen, welche große Bedeutung die Sprache über 20 Jahre später inne haben wird. Ursprünglich war die Skriptsprache lediglich als ergänzendes Werkzeug gedacht, um den Zugriff auf das \emph{Document Object Model} (DOM) von Websites zu ermöglichen und diese dynamischer zu gestalten.
% % FIXME CITATION NEEDED
% Die zu Anfang sehr inkonsistente Implementierung der Sprache in den verschiedenen Webbrowsern und die schwache Typisierung JavaScripts war (und ist) Grund für große Frustration und anfängliche Ablehnung der Sprache seitens professioneller Software-Entwickler~\autocite{oreilly:2001:js}.
% Mit Aufkommen des Web 2.0~\autocite{oreilly:2005:web20} und des damit einhergehenden sukzessiven Bedeutungszuwachses von JavaScript\footnote{Beispielsweise als Bestandteil von \emph{AJAX} (Asynchronous JavaScript and XML)~\autocite{garret:ajax}.} begann die Sprache jedoch allmählich zu reifen. Die sechste Version der als \emph{ECMA Script} bekannten Sprachspezifikation \enquote{ECMA Script 2015}\footnote{Oft auch als \enquote{ES6} bezeichnet.}~\autocite{ecmascript:2015} versuchte viele der historisch bedingten Schwachstellen auszumerzen und führte eine Vielzahl von syntaktischen Verbesserungen sowie neuen Funktionen ein.

% Hierdurch und durch die stetige Weiterentwicklung von ECMA Script wurde der Grundstein für zukunftssichere JavaScript-Anwendungen gelegt. Dennoch stellt insbesondere das dynamische, schwache Typsystems der Programmiersprache ein Hindernis für die Entwicklung umfangreicher Software dar. Unbeabsichtigte, implizite Typumwandlungen zur Laufzeit und falsche Annahmen über vorliegende Datenstrukturen sind häufige Fehlerursachen. Eine starke, statische Typisierung, wie sie beispielsweise in C++ oder Haskell vorliegt ist erstrebenswert, denn sie bietet viele Vorteile für den Software-Entwicklungsprozess: Logik- und Flüchtigkeitsfehler im Quelltext können oftmals bereits vor Ausführung des Programms erkannt und behoben werden. Die Entwickler gewinnen Sicherheit und Zuversicht, dass Änderungen in umfangreichen Projekten keine unerwünschte Nebenwirkung verursachen, wodurch sich die Wartbarkeit der Software erhöht. Eine explizite Typisierung führt darüber hinaus dazu, dass der Programmierer gezwungen ist seine \emph{Intension} klar zu formulieren. Hierdurch verbessert sich die Ausdruckskraft des Codes. Weiterhin wird der Quelltext an Ort und Stelle durch eine vernünftige Typisierung bereits grundlegend dokumentiert (\enquote{\emph{inline documentation}}).

\subsection{Statische Typsysteme in JavaScript}

Derzeit existieren zwei Ansätze, um statische Typsicherheit für JavaScript-Code zu erzielen:

\begin{enumerate}
    \item \textbf{Flow}~\autocite{flow} ist ein von Facebook entwickeltes Werkzeug, um den Quelltext mittels Typannotationen hinsichtlich der Korrektheit der so umgesetzten Typisierung zu überprüfen. Die Annotationen und eigenen Typdefinitionen werden in den Quelltext eingefügt und müssen vor dessen Auslieferung durch einen Transpilierungsprozess entfernt werden, sodass wieder standardkonformer JavaScript-Code entsteht. Dieser Schritt kann beispielsweise durch \emph{Babel}~\autocite{babel} realisiert werden.

    \item \textbf{TypeScript}~\autocite{typescript} ist eine von Microsoft entwickelte, vollständige Programmiersprache, welche eine Obermenge von JavaScript darstellt. Ein stark ausgeprägtes Typsystem ist elementarer Bestandteil der Sprache. Im Gegensatz zu Flow wird TypeScript-Code durch einen Compiler in JavaScript übersetzt, welcher auch auch die statische Typprüfung vollzieht. Diese kann natürlich auch simultan zur Arbeit des Programmierers innerhalb der integrierten Entwicklungsumgebung ablaufen.
\end{enumerate}

\bigskip
\begin{listing}[!h]
\begin{jscode}
// Beispiel in Flow:
// @flow
type Vector = {
  +x: number,                           // + bedeutet "schreibgeschützt"
  +y: number,
}

function vectorLength<T: Vector>(vec: Vector): number {
  return Math.sqrt(Math.pow(vec.x, 2) * Math.pow(vec.y, 2));
}

const vec: Vector = { x: 2, y: 5 };
vec.x = 3;                              // Fehler: Attribut x ist schreibgeschützt

vectorLength({ x: 2, y: 5 });           // In Ordnung
vectorLength({ x: 2, y: 'string' });    // Fehler: Attribut y ist nicht vom Typ `number`
vectorLength({ y: 5 });                 // Fehler: Attribut x fehlt
vectorLength({ x: 2, z: 5 });           // Fehler: Attribut z ist nicht Teil des Typs
\end{jscode}
\end{listing}

\begin{listing}[!h]
\begin{tscode}
// ------------------------------------------------------------------------------------------

// Analoges Beispiel in TypeScript:
type Vector = {
  readonly x: number,
  readonly y: number,
}

function vectorLength<T extends Vector>(vec: Vector): number {
  return Math.sqrt(Math.pow(vec.x, 2) * Math.pow(vec.y, 2));
}

const vec: Vector = { x: 2, y: 5 };
vec.x = 3;                              // Fehler: Attribut x ist schreibgeschützt

vectorLength({ x: 2, y: 5 });           // Korrekt
// Rest analog...
\end{tscode}
\caption{Vergleich der zwei Ansätze für statische Typisierung von JavaScript mit Flow (oben) und TypeScript (unten).}
\label{code:example}
\end{listing}

\pagebreak
Wie Quelltext~\ref{code:example} verdeutlicht, haben Flow und TypeScript eine ähnliche, wenn auch in manchen Fällen nicht völlig identische Syntax:

\begin{itemize}
    \item Vgl. \enquote{\code{+x:~number}} vs. \enquote{\code{readonly x:~number}}
    \item Vgl. \enquote{\code{<T:~Vector>}} vs. \enquote{\code{<T extends Vector>}}
\end{itemize}

Innerhalb des eCommerce-Unternehmen \textbf{TeamShirts}\footnote{Ein Tochterunternehmen der Spreadshirt AG.\@ Kunden haben die Möglichkeit Textilien und andere geeignete Gegenstände wie Taschen, Mützen, Tassen etc.~mit eigenen und vorgefertigten Bildmotiven zu bedrucken. Hierfür können die Produkte in einer \href{https://wizard.teamshirts.de/de/DE/generic}{Webanwendung} selbstständig gestaltet und im Anschluss bestellt werden.} gibt es strategische Überlegungen, die bestehenden Frontend-Projekte, die im Moment allesamt auf React und Flow basieren, nach TypeScript zu migrieren. Grund hierfür ist die Annahme, dass TypeScript langfristig zukunftsträchtiger und besser geeignet als Flow sein könnte. Es gibt einige Argumente, die für TypeScript sprechen:

\begin{itemize}
    \item
        \textbf{Performance} --- Während derzeit noch keine verlässlichen Zahlen vorliegen, um diese These stichhaltig zu untermauern, wird TypeScript von vielen Entwicklern im Vergleich zu Flow als schneller hinsichtlich der Typprüfung beschrieben.
    \item
        \textbf{Vorgefertigte Typisierungen} --- Jede Software basiert im Normalfall auf externen Bibliotheken. Sowohl für TypeScript als auch für Flow gibt es von der Gemeinschaft verwaltete Projekte\footnote{\href{https://github.com/flow-typed/flow-typed}{Flow Typed} für Flow und \href{https://github.com/DefinitelyTyped/DefinitelyTyped}{Definetely Typed} für Typescript.\label{github-projects}}, welche die Typisierung dieser Abhängigkeiten bereit stellen. Hierdurch wird beispielsweise die Autovervollständigung in integrierten Entwicklungsumgebungen erheblich verbessert. Jedoch bietet TypeScript dabei eine deutlich vollständigere Unterstützung als Flow\footnote{Vgl. GitHub-Projekte in Fußnote~\ref{github-projects}.}.
    \item
        \textbf{Kontinuität / Stabilität} -- Es besteht Unsicherheit darüber, ob Facebook und Microsoft auf lange Sicht daran interessiert bleiben werden Flow bzw. TypeScript weiterzuentwickeln und zu warten. Da TypeScript als eigenständige Programmiersprache in vielen Bereichen eingesetzt wird und stetig an Popularität gewinnt~\autocite{stackoverflow:survey:2018}, erscheint es jedoch unwahrscheinlich, dass Microsoft dieses Produkt in naher Zukunft einstellen wird. Angular~\autocite{angular} ist beispielsweise ein großes, erfolgreiches Framework, welches in TypeScript geschrieben ist und die Verwendung der Sprache fördert.
    \item
        \textbf{Community / Dokumentation} -- Auch die Größe und Dynamik der \enquote{\emph{Community}} ist ein relevanter Aspekt, da eine große Nutzerzahl bei Open-Source-Projekten einen hohen Grad an Aktivität bedeutet. Offene Fragen und Probleme können durch Online-Recherche meistens schnell beantwortet werden, da das Problem oft bereits behandelt wurde. Ein einfacher, aber wichtiger Aspekt ist darüber hinaus die Aktualität und Qualität der Dokumentation.
\end{itemize}

Ziel der angestrebten Masterarbeit ist damit zunächst eine Analyse hinsichtlich der Vor- und Nachteile sowie der Machbarkeit einer Migration von Flow nach TypeScript. Der eigentliche Kern der Arbeit wäre anschließend die prototypische Entwicklung eines Werkzeugs, welches die bestehende Codebasis\footnote{Circa 150.000 Zeilen JavaScript-Code.} von TeamShirts automatisch in äquivalenten TypeScript-Programm\-text transformiert. Dabei muss die Typisierung aufgrund der unterschiedlichen Syntax von Flow und TypeScript z.~T. angepasst werden. Konzeptionell würde dies durch Einlesen (\emph{Parsing}) des Quelltexts, anschließender Manipulation des zugehörigen abstrakten Syntaxbaums und schließlich der Ausgabe als TypeScript-Code realisiert werden.
Ein funktionsfähiger Prototyp könnte darüber hinaus auch für weitere Unternehmen, die vor derselben Problematik stehen, von Vorteil sein.
