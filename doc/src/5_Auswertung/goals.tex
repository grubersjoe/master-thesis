\section{Bewertung der Ergebnisse hinsichtlich der Zielvorgabe}

Nachfolgend soll nun die Ergebnisse der Migration bezüglich der Erfüllung der in Kapitel~\ref{chap:analysis} definierten Ziele untersucht werden. Die erste Zielsetzung war hierbei die Erkennung weiterer Typ- und Programmfehler.

\subsection{Erkennung weiterer Typ- und Programmfehler}
\label{goal:new-type-errors}


% Der TypeScript-Compiler besitzt wie in Abschnitt~\ref{sec:typescript} beschrieben verschiedene Optionen, um die Striktheit der Typüberprüfungen zu erhöhen. Diese kann durch Setzen der Option \enquote{\code{strict}} angepasst werden, sodass daraufhin deutlich mehr Ausdrücke als Typfehler betrachtet werden.

% TODO: histogramme mit top 8 fehlern oder so strikt vs nicht-strikt
% TODO: erklärung: wo kommen diese fehler her? welche davon sind tatsächlich problematisch? welche nur bs von ts?
% TODO: ein paar beispiele für echte probleme

\subsection{Unterstützung externer Bibliotheken}

% TODO: vergleich flow-typed definitely typed
% TODO: 3 "schöne" bibs rauspicken (react, redux, lodash, datefns?) und libdefs vergleichen

\subsection{Performance der Typüberprüfungen}

\subsubsection{Laufzeitmessung vollständiger Typüberprüfungen}

Eine weitere Zielsetzung des Wechsels zu TypeScript war die Performance der Typüberprüfungen zu steigern bzw. diese zumindest nicht zu verschlechtern. Nachdem die Migration der zwei Projekte abgeschlossen war, konnten die Laufzeiten der vollständigen Typüberprüfung durch Flow bzw. TypeScript ermittelt werden. Die Messung der Zeitdauer von inkrementellen Überprüfungen durch den Flow- bzw. TypeScript-Sprachserver konnte nicht unabhängig von der Ausführung eines Editors  durchgeführt werden, sodass dieser Aspekt nachfolgend nicht betrachtet werden kann, da die Gefahr besteht, dass der Editor die Ergebnisse verfälscht.

Zur Bestimmung der Laufzeiten wurden für Flow und TypeScript jeweils 100 Proben (\textit{Samples}) mithilfe des GNU-Programms \textit{time}~\autocite{GNU_TIME} gemessen und die zehn kleinsten und größten Werte daraufhin verworfen, um den Einfluss von \enquote{Ausreißern} zu minimieren. Aus den verbleibenden 80 Werten wurde anschließend der Mittelwert gebildet und die Standardabweichung berechnet. Dabei wurde in allen Messungen die zum damaligen Zeitpunkt aktuelle Version~3.5 von TypeScript und die von TeamShirts eingesetzte Version~0.96 von Flow verwendet. Um auch den Einfluss von unterschiedlich leistungsfähiger Hardware miteinzubeziehen, wurden die Messreihen auf vier verschiedenen Systemen durchgeführt:

\begin{enumerate}[label=\Alph*.]
  \item AMD Phenom II X6 1055T Prozessor mit 2,9~GHz\footnote{Es wird jeweils der Grundtakt des Prozessors und nicht der maximal mögliche Wert durch dynamische Übertaktung angegeben.} und 6\footnote{} Rechenkernen (2010)\\16~GB Arbeitsspeicher, Solid State Drive, Arch Linux
  \item Intel Core i5-4258U Prozessor mit 2,4~GHz und 4 Rechenkernen (2013)\\8~GB Arbeitsspeicher, Solid State Drive, Arch Linux
  \item Intel Core i5-4210M Prozessor mit 2,6~GHz und 4 Rechenkernen (2014)\\16~GB Arbeitsspeicher, Solid State Drive, Arch Linux
  \item Intel Core i7-6700 Prozessor mit 3,4~GHz und 8 Rechenkernen (2015)\\32~GB Arbeitsspeicher, Solid State Drive, Debian Linux
\end{enumerate}

Die durch diese Methodik ermittelten Messwerte, deren Standardabweichung und die relative Veränderung der Laufzeiten werden in Tabelle~\ref{tab:performance-complete} für beide Projekte aufgelistet: Offensichtlich beschleunigen modernere, performante Prozessoren mit höherer Taktfrequenz und größeren Caches generell die Typüberprüfung durch Flow bzw. TypeScript. Die These, dass TypeScript schneller als Flow sei, lässt sich aber nur anhand des Projekts Helios für die Systeme B, C und D belegen (vgl. negative Werte für relative Veränderung der Laufzeit). Bei Components ist TypeScript dagegen stets deutlich langsamer als Flow.

\medbreak
\input{src/5_Auswertung/tables/results-performance}

Wie im Grundlagenteil bereits ausgeführt wird die Berechnung der Typkorrektheit durch Flow stark parallelisiert, um diese zu verschnellern. TypeScript bietet keine Unterstützung für eine nebenläufige Typüberprüfung durch mehrere Threads~\autocite{TS:NO_MULTICORE}, sodass die Performance hier vorrangig von der Leistungsfähigkeit der einzelnen Prozessorkerne abzuhängen scheint. Diese These wird durch die gemessenen Daten unterstützt, denn je performanter die Prozessoren sind, desto kleiner kleiner wird die Differenz zwischen den Laufzeiten von Flow und TypeScript bei Components bzw. desto größer wird diese bei Helios.
Für System D scheint jedoch die Parallelisierung von Flow aufgrund der hohen Zahl von acht Rechenkernen den größeren Effekt zu haben, als die Leistungsfähigkeit der einzelnen Kerne. Weil die Systeme B und C jeweils nur über vier Prozessorkerne verfügen, ist der Einfluss der Nebenläufigkeit hier kleiner. Als einen möglichen Grund warum Components im Vergleich zu Helios durch Flow insgesamt schneller überprüft werden kann, kann angeführt werden, dass dieses Projekt aus einer Vielzahl unabhängiger Komponenten besteht deren Verarbeitung somit gut durch Flow parallelisiert werden kann. In Helios besteht eine größere Abhängigkeit der Module zueinander.

\subsubsection{Einfluss von Parallelisierung auf die Laufzeiten}

Der Einfluss der Parallelisierung auf die Laufzeit der Berechnungen soll im Folgenden näher untersucht werden. Hierfür wurde eine weitere Testreihe durchgeführt in welcher die Zahl der einsetzbaren Rechenkerne für die Berechnung durch das Linux-Programm \textit{taskset}~\autocite{TASKSET} eingeschränkt wird. Dabei wird dem Prozess durch den Scheduler des Betriebssystems zunächst lediglich ein Rechenkern, dann zwei usw. zugeordnet. Abbildung~\ref{fig:plot-cores} auf Seite~\pageref{fig:plot-cores} zeigt jeweils ein Diagramm für Components und Helios, welche die Beeinflussung des Laufzeitverhaltens durch diese Einschränkung grafisch darstellen. Die exakten Messwerte und deren Standardabweichung wird darüber hinaus in Tabelle~\ref{tab:performance-cores} aufgelistet.

Sowohl bei Flow, als auch bei TypeScript ermöglicht bereits die Verwendung von zwei Rechenkernen eine starke Verbesserung der Laufzeiten im Vergleich zu einem einzigen Kern. Obwohl TypeScript eine Kompilierung durch mehrere Prozessorkerne grundsätzlich nicht unterstützt, wird auch dieser Prozess so beschleunigt, weil der TypeScript Compiler durch Node.js ausgeführt wird und diese Umgebung mehrere Threads startet, um beispielsweise teure Ein- und Ausgabeoperationen auf weitere Rechenkerne auszulagern~\autocite{NODE:THREADS}. Für mehr als drei Kerne bleibt die Laufzeit von TypeScript daraufhin in etwa konstant. Die Laufzeit von Flow verringert sich hingegen mit zunehmender Zahl zur Verfügung stehender Rechenkerne aufgrund der Multithreading-Unterstützung stetig. Ab etwa fünf Kernen sind die Zugewinne allerdings nur noch gering, was auf den zunehmend größeren Overhead durch die notwendige Synchronisierung der Threads zurückgeführt werden könnte.

\begin{figure}[tbp]
  \centering

  \input{../data/performance/plots/cores/components-plot}

  \vspace{.5\baselineskip}

  \input{../data/performance/plots/cores/helios-plot}
  \vspace{.5\baselineskip}
  \caption[Einfluss der zur Verfügung stehenden Rechenkerne auf durchschnittliche Laufzeit der Typüberprüfung von Flow und TypeScript]{
    Einfluss der zur Verfügung stehenden Rechenkerne auf durchschnittliche Laufzeit der Typüberprüfung von Flow 0.96 und TypeScript 3.5 der Projekte Components und Helios.
  }

  \vspace{\baselineskip}
  \caption*{
    \small
    Gemessen mit Intel Core i7-6700 CPU mit 3,4~GHz (Prozessor D).
  }

  \label{fig:plot-cores}
\end{figure}

\medbreak
\input{src/5_Auswertung/tables/results-performance-cores}

\subsubsection{Fazit}

Die angestrebte Verbesserung der Performance durch die Migration zu TypeScript kann im vorliegenden Fall nur als teilweise erreicht betrachtet werden, da nur in drei Fällen bei Helios tatsächlich geringere Laufzeiten für eine vollständige Typüberprüfung gemessen wurden. Die stark parallelisierte Architektur von Flow scheint der von TypeScript bezüglich der Geschwindigkeit in den meisten Fällen überlegen. Es wird aber vermutet, dass die Performance von TypeScript deutlich gesteigert werden könnte, wenn auch hier die Berechnung der Typkorrektheit durch mehrere Rechenkerne möglich wäre. Laut Aussage eines leitenden Entwicklers von TypeScript im März 2019 wird die Implementierung von Multithreading im TypeScript Compiler zukünftig in Betracht gezogen~\autocite{TS:MULTICORE}.

\subsection{Zukunftssicherheit und Transparenz der Technologie}

% TODO: artikel: what we've been up to
% TODO: roadmap
% TODO: evtl berechnen wie lang issues im schnitt offen bleiben?
